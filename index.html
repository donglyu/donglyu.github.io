<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> lydsnm</title><meta name="description" content="Good Time..."><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.lydsnm.top/atom.xml" title="lydsnm"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://life.lydsnm.top" target="_blank" class="nav-list-link">LYDSNM'S LIFE</a></li><li class="nav-list-item"><a href="https://weibo.com/u/2453162147" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/donglyu" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/05/30/Slice一个小而精简的Mac计时软件，拖延症神器，倒计时小工具/" class="post-title-link">Slice 一个小而简的Mac计时软件.拖延症神器.倒计时小工具</a></h2><div class="post-info">2017年5月30日</div><div class="post-content"><h3 id="Slice-一个小而精简的Mac计时软件-拖延症神器-倒计时小工具"><a href="#Slice-一个小而精简的Mac计时软件-拖延症神器-倒计时小工具" class="headerlink" title="Slice 一个小而精简的Mac计时软件. 拖延症神器.倒计时小工具"></a>Slice 一个小而精简的Mac计时软件. 拖延症神器.倒计时小工具</h3><p>&emsp;&emsp;对于常年和电脑打交道的人群来说，在很多时候, 人往往变得浮躁, 坐在电脑旁不到几分钟就像打开网页看视频啊, 打开游戏, 干些不相关的东西，专注力不够，从而导致工作效率低，工作质量不高的效果，进而影响到我们的生活，心情等。<br>        现在你试试这个小工具：<br><img src="http://ocs32tleq.bkt.clouddn.com/14961482427792.jpg" alt=""></p>
<p>&emsp;&emsp;有研究表明，合理的运用人的精力，松紧有弛，能够最大限度的发挥人的能力。自然界本身有它的脉动，一种在活动和休息之间周期性的像波浪一样的运动。想想潮涨潮落、季节变化，以及每天的日出日落。同样，所有的机体都遵循一种维持生命的有规则的变化。就像运动员，我们发现那些成绩好的运动员往往更懂得如何放松和规划自己的精力，在高强度，长时间，高压力的比赛中，很难保持长时间的高水准，因此这些人通常会抓紧一切时间储存精力，等到需要的爆发的时候，集中全部的注意力，更能发挥出好的运动水平，对于普通人，这也同样适用。</p></div><a href="/2017/05/30/Slice一个小而精简的Mac计时软件，拖延症神器，倒计时小工具/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/04/20/iOS实现实时通信或推送的常用策略/" class="post-title-link">iOS实现实时通信或推送的常用策略</a></h2><div class="post-info">2017年4月20日</div><div class="post-content"><h3 id="1-iOS静默推送，不含alert，没有声音没有弹框，具体更多可以看这儿"><a href="#1-iOS静默推送，不含alert，没有声音没有弹框，具体更多可以看这儿" class="headerlink" title="1.iOS静默推送，不含alert，没有声音没有弹框，具体更多可以看这儿"></a>1.iOS静默推送，不含alert，没有声音没有弹框，具体更多可以看<a href="http://blog.csdn.net/hherima/article/details/50469519" target="_blank" rel="noopener">这儿</a></h3><p>限制与注意：<br><code>Silent Remote Notifications</code>是在Apple的限制下有一定的频率控制，并不是所有的静默推送都能按预期到达客户端触发函数的。<br>前提：客户端需处于Background或Suspended状态。<br>Apple 官方文档说：<a href="https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html" target="_blank" rel="noopener">Configuring a Silent Notification</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Silent notifications are not meant as a way to keep your app awake in the background, nor are they meant for high priority updates. APNs treats silent notifications as low priority and may throttle their delivery altogether if the total number becomes excessive. The actual limits are dynamic and can change based on conditions, but try not to send more than a few notifications per hour.</span><br></pre></td></tr></table></figure>
<p>用户如果禁止了推送权限，还能收到静默推送吗？这将是一个问题。</p></div><a href="/2017/04/20/iOS实现实时通信或推送的常用策略/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/02/06/实现自定义UIWebView 的UIMenuController选项/" class="post-title-link">对UIMenuController菜单自定义</a></h2><div class="post-info">2017年2月6日</div><div class="post-content"><p>&emsp;&emsp;项目中遇到了需要对UIWebView中弹出菜单的一些定制，所以查找一些资料，整理记录一下。</p>
<p>首先看看UIMenuController默认支持的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)cut:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)<span class="keyword">copy</span>:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)paste:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)select:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)selectAll:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)delete:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_2);</span><br><span class="line">- (<span class="keyword">void</span>)makeTextWritingDirectionLeftToRight:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)makeTextWritingDirectionRightToLeft:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)toggleBoldface:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)toggleItalics:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)toggleUnderline:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)increaseSize:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)decreaseSize:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更多带_的私有方法可以看: https://yq.aliyun.com/articles/39475</span></span><br></pre></td></tr></table></figure></div><a href="/2017/02/06/实现自定义UIWebView 的UIMenuController选项/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/10/20/OC开发相关注意事项四/" class="post-title-link">OC开发相关注意事项四</a></h2><div class="post-info">2016年10月20日</div><div class="post-content"><h2 id="第7章-熟悉系统框架"><a href="#第7章-熟悉系统框架" class="headerlink" title="第7章 熟悉系统框架"></a>第7章 熟悉系统框架</h2><p>将一系列代码封装为动态库 (dynamic library) , 并在其中放入描述其借口的头文件, 这样做出来的东西就叫 <font color="a52a2a">框架</font> .有时为 iOS 平台构建的第三方框架实用的是静态库 (static libaray), 这是因为 iOS 应用程序不允许在其中包含动态库.</p>
<p>开发者主要会碰到<code>Foundation</code>, 像是 <code>NSOject</code>, <code>NSArray</code>, <code>NSDictionary</code> 等类都在其中, <code>Foundation</code> 是应用程序的 “基础”.</p>
<p>还有个与 <code>Foundation</code> 相伴的框架, 叫做 <code>CoreFoundation</code> , 从技术上来将, <code>CoreFoundation</code> 框架不是 <code>Objective-C</code> 框架, 但它是编写 <code>Objective-C</code> 应用程序时所应熟悉的重要框架. <code>Foundation</code> 框架中的很多功能, 都可以在此框架中找到对应的 C 语言 API. 可以用”无缝桥接”(tollfree bridging). 可以吧 <code>CoreFoundation</code> 中的 C 语言数据结构平滑转换为 <code>Foundation</code>中的 Objective-C 对象.</p>
<p>除了<code>Foundation</code> 还有 <code>CFNetwork</code> , <code>CoreAudio</code>, <code>AVFoundation</code>, <code>CoreData</code>, <code>CoreText</code> ….</p></div><a href="/2016/10/20/OC开发相关注意事项四/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/10/19/OC开发相关注意事项三/" class="post-title-link">OC开发相关注意事项三</a></h2><div class="post-info">2016年10月19日</div><div class="post-content"><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>ARC :<code>Automatic Reference Counting,ARC</code>, ARC 几乎把所有内存管理事宜都交由编译器来决定, 开发者只需专注于业务逻辑.</p>
<h3 id="1-引用计数"><a href="#1-引用计数" class="headerlink" title="1. 引用计数"></a>1. 引用计数</h3><p>Objective-C 语言实用引用计数来管理内存. 每个对象都有个可以递增和递减的计数器, 用以标识当前有多个事情想令此对象继续存活下去.<br>计数<font color="#A52A2a">>=0</font>表示对象继续存活. 当保留计数降为<font color="#A52A2a"> 0 </font>后, 对象就会被释放了.</p>
<p>ARC 只负责管理 <code>Objective-C</code> 对象的内存. 注意: <font color="#A52A2a">CoreFoundation</font>对象不归 ARC 管理, 开发者必须适时调用 <font color="#A52A2a">CFRetain/CFRelease</font>.</p>
<h3 id="2-在-dealloc-方法中只释放引用并解除监听"><a href="#2-在-dealloc-方法中只释放引用并解除监听" class="headerlink" title="2. 在 dealloc 方法中只释放引用并解除监听"></a>2. 在 dealloc 方法中只释放引用并解除监听</h3><p>对象在经历其生命周期后, 最终会为系统所回收, 这时就要执行 <code>dealloc</code> 方法了. 在每个对象的生命周期内, 此方法仅执行以此. 也就是但保留计数降为 0 的时候.</p>
<p>虽说应该于 <code>dealloc</code> 中释放引用, 但是开销较大或系统内稀缺的资源则不在此列 ,像是文件描述符( file descriptor ), 套接字 (socket), 大块内存等都属于这种资源. 不能指望 <code>dealloc</code> 方法必定会在某个特定的时机调用, 因为有一些无法预料的东西可能也会持有此对象. 在这种情况下, 如果非要等到系统调用 <code>dealloc</code> 方法时才释放, 那么保留这些稀缺资源的时间就太长了, 这么做不合适. 通常的做法时, 实现另外一个方法, 但应用程序用完资源对象后, 就调用此方法 (例如 <font color="#A52A2a">Open</font> 对应 <font color="#A52A2a">Close</font> 方法) . 这样一来, 资源对象的生命期就变得更明确了.</p></div><a href="/2016/10/19/OC开发相关注意事项三/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/10/18/本地推送之定时推送/" class="post-title-link">本地推送之定时推送</a></h2><div class="post-info">2016年10月18日</div><div class="post-content"><p>项目中使用到了定时提醒推送, 故整理记录下来.</p>
<h2 id="iOS10-之前-使用旧的本地推送注册方式"><a href="#iOS10-之前-使用旧的本地推送注册方式" class="headerlink" title="iOS10 之前, 使用旧的本地推送注册方式:"></a>iOS10 之前, 使用旧的本地推送注册方式:</h2><h3 id="1-在-AppDelegate中代理注册使用通知-和注册远程通知一致"><a href="#1-在-AppDelegate中代理注册使用通知-和注册远程通知一致" class="headerlink" title="1. 在 AppDelegate中代理注册使用通知, 和注册远程通知一致"></a>1. 在 <code>AppDelegate</code>中代理注册使用通知, 和注册远程通知一致</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIMutableUserNotificationCategory</span> *categorys = [[<span class="built_in">UIMutableUserNotificationCategory</span> alloc] init];</span><br><span class="line"><span class="built_in">UIUserNotificationSettings</span> *userSettings = [<span class="built_in">UIUserNotificationSettings</span> settingsForTypes:<span class="built_in">UIUserNotificationTypeBadge</span>|<span class="built_in">UIUserNotificationTypeSound</span>|<span class="built_in">UIUserNotificationTypeAlert</span></span><br><span class="line">                                                                                    categories:[<span class="built_in">NSSet</span> setWithObject:categorys]];</span><br><span class="line">[[<span class="built_in">UIApplication</span> sharedApplication] registerUserNotificationSettings:userSettings];</span><br><span class="line">[[<span class="built_in">UIApplication</span> sharedApplication] registerForRemoteNotifications];</span><br></pre></td></tr></table></figure></div><a href="/2016/10/18/本地推送之定时推送/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/10/08/简单明了搞定iOS10推送适配/" class="post-title-link">简单明了搞定 iOS 10推送适配</a></h2><div class="post-info">2016年10月8日</div><div class="post-content"><p>iOS 10 更新了后发现正式环境, 推送粗问题了.查了相关资料后, 整理了一下解决办法。 iOS 10后, 增加了<font color="#1E90FF">UNUserNotificationCenter</font>, 并且推送通知的处理要在代理方法</p>
<ul>
<li><p><font color="#A52A2A">userNotificationCenter:didReceiveNotificationResponse</font> 推送时 APP 在后台</p>
</li>
<li><p><font color="#A52A2A">userNotificationCenter:willPresentNotification</font> 推送时 APP 在前台</p>
</li>
</ul></div><a href="/2016/10/08/简单明了搞定iOS10推送适配/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/09/20/OC开发相关注意事项二/" class="post-title-link">OC开发相关注意事项二</a></h2><div class="post-info">2016年9月20日</div><div class="post-content"><h2 id="接口与-API-设计"><a href="#接口与-API-设计" class="headerlink" title="接口与 API 设计"></a>接口与 API 设计</h2><p>我们在构建应用程序编写接口应考虑将其设计成易于复用的形式, 方便后续项目复用或其他模块使用. 这就需要遵守一定的编程范式, 遵守一些约定俗成的”规则”.</p>
<h3 id="1-用前缀避免命名空间冲突"><a href="#1-用前缀避免命名空间冲突" class="headerlink" title="1. 用前缀避免命名空间冲突"></a>1. 用前缀避免命名空间冲突</h3><p>OC 没有其他语言内置的命名空间机制. 因此在命名时设法避免潜在的命名冲突, 否则容易就重名.否则会出现类似错误:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">duplicate symbol _OBJC_METACLASS_$_EOCTHECLASS <span class="keyword">in</span>:</span><br><span class="line">build/something.o</span><br><span class="line">build/something_else.o</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>苹果宣称其保留使用所有”两字母前缀”(two-letter prefix)的权利,因此我们的命名前缀最好避免使用两个字母当前缀.</p></div><a href="/2016/09/20/OC开发相关注意事项二/" class="read-more">...more</a></article></li></ul></main><footer><div class="paginator"><a href="/page/2/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://www.lydsnm.top">lydsnm</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>