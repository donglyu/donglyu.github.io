<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lydsnm</title>
  
  <subtitle>...多做多说...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.lydsnm.top/"/>
  <updated>2018-12-09T09:05:51.556Z</updated>
  <id>http://www.lydsnm.top/</id>
  
  <author>
    <name>lydsnm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试问题实记</title>
    <link href="http://www.lydsnm.top/2018/12/09/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%AE%9E%E8%AE%B0/"/>
    <id>http://www.lydsnm.top/2018/12/09/面试问题实记/</id>
    <published>2018-12-08T16:00:00.000Z</published>
    <updated>2018-12-09T09:05:51.556Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;部分面试问题，记录一下，时刻督促~</p><h2 id="layer层，还有哪些layer子类，有些什么作用"><a href="#layer层，还有哪些layer子类，有些什么作用" class="headerlink" title="layer层，还有哪些layer子类，有些什么作用"></a>layer层，还有哪些layer子类，有些什么作用</h2><p>CATextLayer（CALayer的一个子类，专门用来显示文字）<br>CAGradientLayer(渐变图层）<br>CAShapeLayer（波浪）<br>CATiledLayer（专为加载超大图.eg:地图资源）<br>CATransformLayer（3D变换、3D动画）<br>CAGradientLayer （渐变色Layer）<br>CAReplicatorLayer （复制图层（多个相同图层组合起来动画）<a href="https://www.cnblogs.com/xianfeng-zhang/p/7759919.html）" target="_blank" rel="noopener">https://www.cnblogs.com/xianfeng-zhang/p/7759919.html）</a><br>CAScrollLayer  （滚动图层：for scrollView负责显示）<br>CAEmitterLayer （粒子发生器系统。用来创建实时的粒子动画：烟雾，火，雨，雪等。）<br>CAEAGLLayer （用来显示任意的OpenGL图形。OpenGL由近350个不同的函数调用组成，用来从简单的图元绘制复杂的三维景象，主要用途是CAD、科学可视化程序、虚拟现实、游戏程序设计。）<br>AVPlayerLayer （视频图层：本地网络视频播放AVPlayer）</p><p>CATextLayer使用CoreText进行绘制，渲染速度比使用WebKit的UILabel快很多。而且UILabel主要是管理内容，CATextLayer则是绘制内容、渲染文本。</p><hr><h2 id="锁，常用的有哪些，优缺点对比呢"><a href="#锁，常用的有哪些，优缺点对比呢" class="headerlink" title="锁，常用的有哪些，优缺点对比呢"></a>锁，常用的有哪些，优缺点对比呢</h2><p>先说几个概念：<br>临界区：指的是一块对公共资源进行访问的代码，并非一种机制或是算法。</p><p>自旋锁：是用于多线程同步的一种锁，线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。 自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。</p><p>互斥锁（Mutex）：是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。该目的通过将代码切片成一个一个的临界区而达成。</p><p>读写锁：是计算机程序的并发控制的一种同步机制，也称“共享-互斥锁”、多读者-单写者锁) 用于解决多线程对公共资源读写问题。读操作可并发重入，写操作是互斥的。 读写锁通常用互斥锁、条件变量、信号量实现。</p><p>信号量（semaphore）：是一种更高级的同步机制，互斥锁可以说是semaphore在仅取值0/1时的特例。信号量可以有更多的取值空间，用来实现更加复杂的同步，而不单单是线程间互斥。</p><p>几种常用的锁介绍：<a href="https://blog.csdn.net/banbaodevelop/article/details/79279221" target="_blank" rel="noopener">https://blog.csdn.net/banbaodevelop/article/details/79279221</a></p><p>条件锁：就是条件变量，当进程的某些资源要求不满足时就进入休眠，也就是锁住了。当资源被分配到了，条件锁打开，进程继续运行。</p><p>@synchronized 关键字加锁 互斥锁，性能较差不推荐使用</p><p>NSLock：是Foundation以对象形式暴露的锁，NSLock 互斥锁 不能多次调用 lock方法,会造成死锁。定义了lock和unlock方法<br>NSConditionLock 条件锁<br>条件锁，一个线程获得了锁，其它线程等待。</p><p>pthread_mutex：C语言</p><p><code>dispatch_semaphore</code> 信号量实现加锁<br>GCD中也已经提供了一种信号机制，使用它我们也可以来构建一把”锁”(从本质意义上讲，信号量与锁是有区别。):</p><h2 id="信号量之间的性能，为什么有些时候不好"><a href="#信号量之间的性能，为什么有些时候不好" class="headerlink" title="信号量之间的性能，为什么有些时候不好"></a>信号量之间的性能，为什么有些时候不好</h2><p>dispatch_semaphore<br>未知</p><h2 id="夜间模式的实现方式"><a href="#夜间模式的实现方式" class="headerlink" title="夜间模式的实现方式"></a>夜间模式的实现方式</h2><p>night_updateColor  通知， 运行时分类加属性。使用<a href="https://github.com/Draveness/DKNightVersion" target="_blank" rel="noopener">参考DKNightVersion</a>深化一下记忆。</p><h2 id="cell的优化思路有哪些"><a href="#cell的优化思路有哪些" class="headerlink" title="cell的优化思路有哪些"></a>cell的优化思路有哪些</h2><p><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/</a><br>优化一般有两个方向的原因：cpu消耗和gpu消耗。</p><h3 id="cpu消耗"><a href="#cpu消耗" class="headerlink" title="cpu消耗"></a>cpu消耗</h3><p>对象创建： 对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。layer层轻量一些。</p><p>对象调整：对象的调整也经常是消耗 CPU 资源的地方。比如layer，其实内部临时会创建方法。图层调整时，UIView和layer之间会出现很多的方法调用和通知。</p><p>对象销毁：布局计算，后台线程提前计算好布局，并对布局缓存</p><p>Autolayout： 复杂布局会有严重的性能问题。手动计算frame，或者用AsyncDisplayKit框架。来处理界面的问题</p><p>文本计算：如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。</p><p>如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象，然后自己计算了，并且 CoreText 对象还能保留以供稍后绘制使用。</p><p>文本渲染</p><p>图片加载和渲染：图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。</p><h3 id="GPU资源消耗"><a href="#GPU资源消耗" class="headerlink" title="GPU资源消耗"></a>GPU资源消耗</h3><p>纹理的渲染：尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。<br>视图的混合：应用应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示。</p><p>图形的生成：CALayer 的 border、圆角、阴影、遮罩（mask），<code>CASharpLayer</code> 的矢量图形显示，通常会触发<code>离屏渲染</code>（offscreen rendering），而离屏渲染通常发生在 GPU 中。当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 <code>CALayer.shouldRasterize</code> 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。<br>最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。</p><p>以上这些来自：<a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/</a> 可以看看。</p><h2 id="断点续传的思想"><a href="#断点续传的思想" class="headerlink" title="断点续传的思想"></a>断点续传的思想</h2><p><a href="https://www.jianshu.com/p/0e6deea7de87" target="_blank" rel="noopener">https://www.jianshu.com/p/0e6deea7de87</a></p><p>NSURLSessionDataTask，按字节写入。</p><p>要实现断点续传的功能，通常都需要客户端记录下当前的下载进度，并在需要续传的时候通知服务端本次需要下载的内容片段。<br>修改http头部 content-length（示被下载文件的字节数）</p><p>请求时：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置请求头</span></span><br><span class="line"><span class="comment">// Range : bytes=xxx-xxx，从已经下载的长度开始到文件总长度的最后都要下载</span></span><br><span class="line"><span class="built_in">NSString</span> *range = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"bytes=%zd-"</span>,  DownloadLength];</span><br><span class="line">[request setValue:range forHTTPHeaderField:<span class="string">@"Range"</span>];</span><br></pre></td></tr></table></figure><p>另外AFNetworking中也有对断点续传的实现。分别通过AFURLSessionManager的<code>downloadTaskWithRequest...</code>和<code>downloadTaskWithResumeData...</code></p><h2 id="coretext"><a href="#coretext" class="headerlink" title="coretext"></a>coretext</h2><p>Coretext 原理和简单使用：<a href="https://www.cnblogs.com/purple-sweet-pottoes/p/5109413.html" target="_blank" rel="noopener">https://www.cnblogs.com/purple-sweet-pottoes/p/5109413.html</a></p><p> Core Text是和Core Graphics配合使用的，一般是在UIView的drawRect方法中的Graphics Context上进行绘制的。 且Core Text真正负责绘制的是文本部分，图片还是需要自己去手动绘制，所以你必须关注很多绘制的细节部分。<br> Core Text是用来进行文字精细排版的。<br> 参考<a href="https://yq.aliyun.com/articles/35907?spm=5176.100240.searchblog.12.TGPd0O" target="_blank" rel="noopener">CoreText 入门</a></p><p> iOS UIKit的UIView的坐标系原点在左上角。<br>往底层看，Core Graphics的context使用的坐标系的原点是在左下角。而在iOS中的底层界面绘制就是通过Core Graphics进行的，那么坐标系列是如何变换的呢？ 在UIView的drawRect方法中我们可以通过UIGraphicsGetCurrentContext()来获得当前的Graphics Context。drawRect方法在被调用前，这个Graphics Context被创建和配置好，你只管使用便是。</p><p>Core Text一开始便是定位于桌面的排版系统，使用了传统的原点在左下角的坐标系，所以它在绘制文本的时候都是参照左下角的原点进行绘制的。</p><p>说起coreText就要说说开源框架<code>YYLabel</code>。这也是一个学习方向。</p><h3 id="YYLabel"><a href="#YYLabel" class="headerlink" title="YYLabel"></a>YYLabel</h3><p>简要介绍：YYLabel 直接继承 UIView，作者自己实现 Label 的渲染。UIGraphicsBeginImageContextWithOptions。<br> 分为普通渲染和异步渲染。异步：通过后台线程渲染图片。</p><h2 id="OC的多线程开发。"><a href="#OC的多线程开发。" class="headerlink" title="OC的多线程开发。"></a>OC的多线程开发。</h2><p>GCD全解：<a href="https://www.jianshu.com/p/2d57c72016c6" target="_blank" rel="noopener">https://www.jianshu.com/p/2d57c72016c6</a></p><p>串行（每次只有一个任务被执行。让任务一个接着一个地执行。（只开启一个线程，一个任务执行完毕后，再执行下一个任务））、并行队列。</p><p>GCD 队列组：dispatch_group</p><h2 id="套接字编程（socket）"><a href="#套接字编程（socket）" class="headerlink" title="套接字编程（socket）"></a>套接字编程（socket）</h2><p><a href="https://blog.csdn.net/dolacmeng/article/details/81085905" target="_blank" rel="noopener">https://blog.csdn.net/dolacmeng/article/details/81085905</a><br>socket的方式实现长连接。<br>IM即时通讯是通过Socket的方式实现长连接，可运用于<br>（1）直播聊天室、礼物<br>（2）微信、QQ等即时聊天<br>（3）游戏对话、技能等</p><p>套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行。建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket。建立连接时所需的寻址信息为IP地址和端口号</p><p>IP地址：用于区分那一台机器需要建立连接<br>端口号：用于区分和哪一个应用程序建立连接</p><p>套接字之间的连接过程分为三个步骤：<code>服务器监听</code>，<code>客户端请求</code>，<code>连接确认</code>。</p><p>创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。</p><p>Socket是我们使用TCP/IP 或者UDP/IP协议的<code>一组编程接口</code>，其介于应用层和传输层之间。传输层可以选择TCP或UDP，UDP是不可靠传输，为了保证数据的可靠性，实现起来会更加复杂(除非加上一些很多的其他私有协议，如QQ)，所以一般项目使用TCP即可.<br>我们在应用层，使用socket，轻易的实现了进程之间的通信</p><p>iOS使用Socket的常用方式有如下：<br>（1）<code>BSD Socket</code>：是UNIX系统中通用的网络接口，基于C语言，比较底层<br>（2）<code>CF Socket</code>：苹果官方提供，来自于<code>CoreFoundation</code>框架<br>（3）<code>AsyncSocket</code>：对BSD Socket的封装，OC语言<br>（4）ysocket：对BSD Socket的封装，Swift语言 </p><p>心跳包就是在客户端和服务器间定时通知对方自己状态的一个自己定义的命令字，按照一定的时间间隔发送，类似于心跳，所以叫做心跳包。<br>心跳包的发送，通常有两种技术<br>方法1：应用层自己实现的心跳包<br>方法2：TCP的KeepAlive保活机制</p><p>心跳包的详细内容： <a href="https://blog.csdn.net/qq_32010299/article/details/51787032" target="_blank" rel="noopener">https://blog.csdn.net/qq_32010299/article/details/51787032</a>  心跳检测步骤，等机制。</p><p>AsyncSocket的客户端开发和服务端简单开发。<a href="https://www.cnblogs.com/letougaozao/p/3842113.html" target="_blank" rel="noopener">https://www.cnblogs.com/letougaozao/p/3842113.html</a></p><h3 id="webSocket"><a href="#webSocket" class="headerlink" title="webSocket"></a>webSocket</h3><h2 id="sdk制作注意事项"><a href="#sdk制作注意事项" class="headerlink" title="sdk制作注意事项"></a>sdk制作注意事项</h2><p><a href="https://www.jianshu.com/p/56941218a0df" target="_blank" rel="noopener">https://www.jianshu.com/p/56941218a0df</a></p><ul><li><p>由于OC没有命名空间概念,很大问题是重名问题.有以下几个地方都需要注意添加前缀,前缀一定要有辨识度,类名、宏定义、枚举、通知、类别等命名时加静态库统一特殊前缀，以避免命名冲突:</p></li><li><p>第三方公用库或静态库不要打入SDK进行编译<br>我们常用的网络库使用AFNetworking,SDWebImage,虽然引入到项目中,但是.m不要勾选”target membership”选项,只需要引入.h就OK.或者通过cocoapod,创建sdk工程,通过<code>cocopads</code>管理项目依赖.</p></li></ul><p>常见的第三方框架,比如libssl.a,opencv.a,libcrypto.a等等,拖入工程的时候”Add to Target”(taget membership)都不要打勾.也就是sdk对这些公共库有依赖关系,但是最终生成的sdk不包含公共库的源码文件.</p><ul><li>尽量减少使用Category<br>那么需要在Build settings-&gt;Other Linker Flags中添加-ObjC参数,解决运行时unrecognized selector send to instance的crash错误.<br>使用-all_load或者-force_load xxx在编译期间非常耗时.<br>为了减少耗时,本人是将通用的类创建成常用的全局函数,static函数,inline函数(注意添加前缀)</li></ul><ul><li>支持通用平台arm,x86等 (模拟器和真机都要去做处理）<br>arm指令集版本 ，要选好所有的设备。</li></ul><ul><li><p>Debug模式,必要Log输出与crash日志收集 。。  log信息如果需要收集的话，还需要自建一套系统。</p></li><li><p>涉及界面的问题，最好用自动约束。</p></li><li><p>bundle命名问题，文件配置问题。</p></li></ul><hr><h2 id="viewcontroller-的生命周期"><a href="#viewcontroller-的生命周期" class="headerlink" title="viewcontroller 的生命周期"></a>viewcontroller 的生命周期</h2><h2 id="socket与http的关系"><a href="#socket与http的关系" class="headerlink" title="socket与http的关系"></a>socket与http的关系</h2><p>都是应用层。http是单项， socket建立链接时是需要http的。连接完毕后的数据传输是不需要http协议的。</p><h2 id="代理为什么用assgin、weak"><a href="#代理为什么用assgin、weak" class="headerlink" title="代理为什么用assgin、weak"></a>代理为什么用assgin、weak</h2><p>弱指针引用，减少内存释放问题。assign主要用来修饰基本的数据类型,weak用来修饰NSObject,两者对所修饰的数据都是<strong> 非拥有关系 </strong></p><h2 id="optional"><a href="#optional" class="headerlink" title="optional"></a>optional</h2><p>Swift 中的普通类型不再能设为nil。那如何表示这个值不存在呢？所以引进了Optional的概念：<b><font color="10d3c4">代表 nil 或某个具体的值</font></b>。<br>所以更恰当的理解应该是：String! 只是<code>理解意义上的不为nil</code>，其本质还是一个 Optional，从声明来说它和 String? 完全等价，所以也能够赋值为 nil 。</p><h2 id="图片上传用什么。"><a href="#图片上传用什么。" class="headerlink" title="图片上传用什么。"></a>图片上传用什么。</h2><p>AFHTTPSessionManager</p><h2 id="swift常用库"><a href="#swift常用库" class="headerlink" title="swift常用库"></a>swift常用库</h2><p>snapkit objectmapper swiftyjson<br>Alamofire<br>wcdb 了解学习一波</p><h2 id="组件化，常识"><a href="#组件化，常识" class="headerlink" title="组件化，常识"></a>组件化，常识</h2><ul><li><p>url-block 把调用组件使用的url和组件提供的服务block对应起来，保存到内存中，在使用组件的服务时，通过url找到对应的block，然后获取服务</p></li><li><p>protocol来定义服务接口</p></li></ul><p>等，当然还有其他方式~</p><p>组件化实施的方式<br>组件化可以利用git的源代码管理工具的便利性来实施，具体就是建立一个项目工程的私有化仓库，然后把各个组件的podspec上传到私有仓库，在需要用到组件时，直接从仓库里面取。</p><p>1.封装公共库和基础UI库<br>在具体的项目开发过程中，我们常会用到三方库和自己封装的UI库，我们可以把这些库封装成组件，然后在项目里用pod进行管理。其中，针对三方库，最好再封装一层，使我们的项目部直接依赖三方库，方便后续开发过程中的更换。</p><p>2.独立业务模块化<br>在开发过程中，对一些独立的模块，如：登录模块、账户模块等等，也可以封装成组件，因为这些组件是项目强依赖的，调用的频次比较多。另外，在拆分组件化的过程中，拆分的粒度要合适，尽量做到组件的独立性。同时，组件化是一个渐进的过程，不可能把一个完整的工程一下子全部组件化，要分步进行，通过不停的迭代，来最终实现项目的组件化。</p><p>3.服务接口最小化<br>在前两步都完成的情况下，我们可以根据组件被调用的需求来抽象出组件对外的最小化接口。这时，就可以选择具体应用哪种组件化方案来实施组件化了。</p><h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><p><a href="http://www.cnblogs.com/ranyonsue/p/5984001.html" target="_blank" rel="noopener">关于HTTP协议，一篇就够了</a></p><h2 id="内存分配使用是什么样的。"><a href="#内存分配使用是什么样的。" class="headerlink" title="内存分配使用是什么样的。"></a>内存分配使用是什么样的。</h2><p>arc  以及简单的mrc<br><a href="https://blog.csdn.net/youngkehpu/article/details/56282885" target="_blank" rel="noopener">https://blog.csdn.net/youngkehpu/article/details/56282885</a></p><p>1、代码区：用来存放函数的二进制代码，在运行时要防止被非法修改，只允许读取不允许操作<br>2、常量区：存储常量<br>3、静态区：（比如static声明的变量）<br>数据区：存放程序静态分配的变量和全局变量<br>BSS：包含了程序中未初始化全局变量<br>4、堆：由程序员分配和释放，存放进程运行中被动态分配的内存段，可大可小，根据存储的多少来调节大小。调用alloc等分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用realse释放内存时，被释放的内存从堆中被踢除（堆被缩减），因为我们现在iOS基本都使用ARC来管理对象，所以不用我们程序员来管理，但是我们要知道这个对象存储的位置<br>5、栈：栈是由编译器自动分配并释放，用来存放函数括弧“{}”中定义的变量。当函数被调用时，函数带有的参数也会被压入发起调用的进程栈中，待到调用结束后，函数的返回值也回被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。可以把栈看成一个临时数据寄存、交换的内存区。</p><p>以上中堆和静态区以及常量区都是连续的，栈和代码区都是独立存放的，栈是向低地址扩展的数据结构，是一块连续的内存的区域。堆是向高地址扩展的数据结构，是不连续的内存区域。堆和栈不会碰到一起，之间间隔很大，绝少有机会能碰到一起，况且堆是链表方式存储！</p><h2 id="kvo"><a href="#kvo" class="headerlink" title="kvo"></a>kvo</h2><p>基于runtime</p><p>相当于系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法<br>每个类对象中都有一个 isa 指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将 isa 指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的 setter 方法。</p><p>kvc<br>KVC是Key Value Coding的简称。它是一种可以通过字符串的名字（key）来访问类属性的机制。<br>isa-swizzing就是类型混合指针机制</p><p>KVC的内部机制：<br>一个对象在调用setValue的时候进行了如下操作：</p><p>（1）根据方法名找到运行方法的时候需要的环境参数<br>（2）他会从自己的isa指针结合环境参数，找到具体的方法实现接口。<br>（3）再直接查找得来的具体的实现方法</p><h2 id="runloop"><a href="#runloop" class="headerlink" title="runloop"></a>runloop</h2><p><a href="http://www.cocoachina.com/ios/20180515/23380.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20180515/23380.html</a></p><p>深入浅出runloop： <a href="https://www.jianshu.com/p/7bc36b111774" target="_blank" rel="noopener">https://www.jianshu.com/p/7bc36b111774</a> 这个比较清楚一点。<br>一个线程一次只能执行一个任务，执行完成后线程就会退出。RunLoop 机制能让线程随时处理事件但并不退出。这里说的随时是指：程序需要运行时就保持程序的持续运行，不需要的时候就进入休眠状态。</p><p>不开启runloop的线程，运行完了后就关闭了。</p><p>苹果提供的runloop：Event Loop线程的任务直到我们主动让线程退出为止永远不会结束<br>RunLoop本质就是个Event Loop的do while循环。<br>就如小节标题保持线程的存活，而不是线性的执行完任务就退出了。<br>并且能在不处理消息的时候让线程休眠，节约资源，在接收到消息的时候唤醒线程做出对应处理的消息循环机制<br>线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p><p>线程默认不开启RunLoop，为什么我们的App或者说主线程却可以一直运行而不会结束？</p><p>主线程是唯一一个例外，当App启动以后主线程会自动开启一个RunLoop来保证主线程的存活并处理各种事件。而且从上面的源代码来看，任意一个子线程的RunLoop都会保证主线程的RunLoop的存在。</p><p>NSTimer定时器的触发正是基于RunLoop运行的，所以使用NSTimer之前必须注册到RunLoop。</p><p>FaceBook的AsyncDisplayKit</p><p>共同之处在于，通过合理利用RunLoop机制，将很多不是必须在主线程中执行的操作放在子线程中实现，然后在合适的时机同步到主线程中，这样可以节省在主线程执行操作的时间，避免卡顿</p><p>主线程中一般不需要我们手动添加autoreleasepool，但是，如果你希望某个对象或者变量尽快释放的时候我们也可以手动添加。</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>算法中，什么是哈希值，哈希值怎么生成的，有什么用？<br>2017年10月25日 15:34:50 QianSong_Promise 阅读数：8855<br>1、你可以把哈希值简单地理解成是一段数据（某个文件，或者是字符串）的DNA，或者身份证；</p><p>2、通过一定的哈希算法（典型的有MD5，SHA-1等），将一段较长的数据映射为较短小的数据，这段小数据就是大数据的哈希值。他有这样一个特点，他是唯一的，一旦大数据发生了变化，哪怕是一个微小的变化，他的哈希值也会发生变化。另外一方面，既然是DNA，那就保证了没有两个数据的哈希值是完全相同的。</p><p>3、正是因为这样的特点，它常常用来判断两个文件是否相同。比如，从网络上下载某个文件，只要把这个文件原来的哈希值同下载后得到的文件的哈希值进行对比，如果相同，则表示两个文件完全一致，下载过程没有损坏文件。而如果不一致，则表明下载得到的文件跟原来的文件不同，文件在下载过程中受到了损坏。</p><h2 id="iOS消息发送"><a href="#iOS消息发送" class="headerlink" title="iOS消息发送"></a>iOS消息发送</h2><p>消息直到运行时才会与方法实现进行绑定（在OC中方法调用是一个消息发送的过程）</p><p>消息发送的主要步骤如下：<br>1.首先检查这个selector是不是要忽略。<br>2.检测这个selector的target是不是nil，OC允许我们对一个nil对象执行任何方法不会Crash，因为运行时会被忽略掉。<br>3.如果上面两步都通过了，就开始查找这个类的实现IMP，先从cache里查找，如果找到了就运行对应的函数去执行相应的代码。<br>4.如果cache中没有找到就找类的方法列表中是否有对应的方法。<br>5.如果类的方法列表中找不到就到父类的方法列表中查找，一直找到NSObject类为止。<br>6.如果还是没找到就要开始进入动态方法解析（动态添加、重定向….）</p><p>链接：<a href="https://www.jianshu.com/p/f31871b58cf0" target="_blank" rel="noopener">https://www.jianshu.com/p/f31871b58cf0</a>  很重要~~~。</p><p>描述一下消息发送的过程？</p><h2 id="1-SEL和IMP-！！！"><a href="#1-SEL和IMP-！！！" class="headerlink" title="1. SEL和IMP ！！！"></a>1. SEL和IMP ！！！</h2><p>使用过UIControl的朋友应该知道addTarget:action:forControlEvents:这个方法，里面的action参数通常用到一个@selector()，而这个语句的结果就是得到了一个SEL变量。SEL变量我们就叫做一个selector。Selector其实很好理解，就是在发送消息/方法调用时标识是哪个消息（方法）的东西。这个通常都是通过方法全名得来的，就比如上面UIControl的（addTarget:action:forControlEvents:）。</p><p>IMP实际上就是具体的一个方法逻辑实现（implementation，貌似IMP就是这么来的）。这个和上面代码示例中的C语言函数指针概念相似。到funcA的指针和到funcB的指针都是IMP变量。</p><p>Obejctive-C的运行时系统提供的消息的分派机制把SEL和IMP关联起来。但每次消息发送/方法调用都做一遍查找显然是很麻烦很低效的，所以在Objective-C的runtime这里一定是有缓存机制的， 使得对每个类特定selector对应的IMP可以很快找到。</p><p>当然，即使用最好的数据结构和最快的查找算法，和直接执行C函数调用的静态绑定方式相比，也一定有性能损失。但比起Objective-C运行时为开发者提供的诸多动态特性相比，这些都是值得的。</p><h2 id="AFNetworking-内部实现。"><a href="#AFNetworking-内部实现。" class="headerlink" title="AFNetworking 内部实现。"></a>AFNetworking 内部实现。</h2><p>AFNSURLSessionManager.<br>它的子类： AFHTTPSessionManager</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;部分面试问题，记录一下，时刻督促~&lt;/p&gt;
&lt;h2 id=&quot;layer层，还有哪些layer子类，有些什么作用&quot;&gt;&lt;a href=&quot;#layer层，还有哪些layer子类，有些什么作用&quot; class=&quot;headerlink&quot; title=&quot;layer
      
    
    </summary>
    
      <category term="职业生涯" scheme="http://www.lydsnm.top/categories/%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>近期换工作了</title>
    <link href="http://www.lydsnm.top/2018/12/03/%E8%BF%91%E6%9C%9F%E9%9D%A2%E8%AF%95%E4%BD%93%E9%AA%8C/"/>
    <id>http://www.lydsnm.top/2018/12/03/近期面试体验/</id>
    <published>2018-12-02T16:00:00.000Z</published>
    <updated>2018-12-03T10:31:43.519Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;近期换工作，面试了很多家。突发发现我的很多表述能力还有“很大的潜力”。上家公司呆久了，没用到的基础性的知识，模糊的很，趁这个时候好好看了下，捡起来不少。</p><a id="more"></a><p>&emsp;&emsp;还是要保持竞争力才行啊。blog最好不要随心发布，还是经常学习，把笔记里的东西整理下发出来吧，满足一下~。</p><p>&emsp;&emsp;近期会更新一下面试的心得还有一些题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;近期换工作，面试了很多家。突发发现我的很多表述能力还有“很大的潜力”。上家公司呆久了，没用到的基础性的知识，模糊的很，趁这个时候好好看了下，捡起来不少。&lt;/p&gt;
    
    </summary>
    
      <category term="杂想" scheme="http://www.lydsnm.top/categories/%E6%9D%82%E6%83%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>Slice 1.0.1 —— Mac提升个人效率的一个小工具</title>
    <link href="http://www.lydsnm.top/2018/08/30/Slice%E6%9B%B4%E6%96%B01.0.1/"/>
    <id>http://www.lydsnm.top/2018/08/30/Slice更新1.0.1/</id>
    <published>2018-08-29T16:00:00.000Z</published>
    <updated>2018-11-26T07:31:46.928Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Slice更新："><a href="#一、Slice更新：" class="headerlink" title="一、Slice更新："></a>一、Slice更新：</h2><p><img src="https://upload-images.jianshu.io/upload_images/1106214-2ef452181b188f6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="SlicePrevie"></p><p>&emsp;&emsp;你是否有这样的体验，如果给你一上午的周末时间，可能会想着反正时间也多，打扫个卫生，刷刷微博一上午就过去，但如果是把这些时间划分成15分钟的片段，每个片段做一件事，一上午能做的事绝对超出你的想象。</p><p>&emsp;&emsp;在短暂的片刻时间内，指定一个几十分钟内要完成的任务。这几十分钟内只专做这件事，不要被其他打扰。只有倒计时才会给人紧迫感。与其在期望未来虚幻的成就，不如着眼现在，把握即将到来的一小段时间。</p><p>&emsp;&emsp;我个人也在用这个软件，使用下来，确实提升了不少效率。</p><a id="more"></a><h2 id="二、正确使用姿势："><a href="#二、正确使用姿势：" class="headerlink" title="二、正确使用姿势："></a>二、正确使用姿势：</h2><p>&emsp;&emsp;脑中指定一件接下来要做的事，接下来的一段时间内只专注于这一件事（一段时间：就是自己输入的时间）。亲测，效率提升不少，并且有一丝紧迫感。</p><p>&emsp;&emsp;建议15分钟一次，太长会集中不了注意力，影响效率。此外，永远也不要做一件事，超过1个小时。利用碎片时间，将整块的时间分成小片段，去做任何琐碎的事，而不会花掉整块时间处理。</p><h2 id="三、功能特点："><a href="#三、功能特点：" class="headerlink" title="三、功能特点："></a>三、功能特点：</h2><ul><li>占用极小。</li><li>始终悬停在所有窗口最前面。</li><li>菜单栏点击，可以创建一个新的倒计时窗口（即支持多个计时器）</li><li>自定义提醒信息</li></ul><p>Slice 1.0.1. 在上一个版本的基础上，精简了一些功能。新增了以下一些功能：</p><ul><li>暂停功能：<br>可能在中途出现突发事情要去处理，可以暂停Slice时间。</li><li>更明显的提醒信息</li></ul><hr><h2 id="四、后期功能计划"><a href="#四、后期功能计划" class="headerlink" title="四、后期功能计划"></a>四、后期功能计划</h2><ul><li>提醒音效可选择。</li><li>后期会加统计功能。</li></ul><hr><h2 id="五、使用"><a href="#五、使用" class="headerlink" title="五、使用"></a>五、使用</h2><p>下载链接:<a href="https://pan.baidu.com/s/1roNYPESUcKJJhXRkOl6uzw" target="_blank" rel="noopener">https://pan.baidu.com/s/1roNYPESUcKJJhXRkOl6uzw</a>  密码:s1vx</p><p>解压后将<code>slice.app</code>拖动到系统的应用程序中</p><p>另外，针对某些用户所说，在10.11以后系统可能安装不了的情况，可以在“设置”中“安全与隐私”的“通用”选项下， 设置<b>允许从任何来源的应用</b>。然后就可以正常使用Slice了。因为Slice是本人在业余时间开发，并未上架App store，且OS X系统有这么一个保护机制，故有这样现象。</p><p><img src="http://ocs32tleq.bkt.clouddn.com/PastedGraphic-1-systemSettingforMac.png" width="500"></p><p>如果在这个地方没有“任何来源”一项的话，就需要打开系统应用“终端”，输入</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo spctl --master-disable</span><br></pre></td></tr></table></figure><p>然后再输入你的系统密码回车即可（不屏显）。</p><h2 id="六、联系我"><a href="#六、联系我" class="headerlink" title="六、联系我"></a>六、联系我</h2><p>如果你有什么建议或意见，请告诉我~<br>[邮箱]：<a href="mailto:dongingdao@163.com" target="_blank" rel="noopener">dongingdao@163.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、Slice更新：&quot;&gt;&lt;a href=&quot;#一、Slice更新：&quot; class=&quot;headerlink&quot; title=&quot;一、Slice更新：&quot;&gt;&lt;/a&gt;一、Slice更新：&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1106214-2ef452181b188f6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;SlicePrevie&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;你是否有这样的体验，如果给你一上午的周末时间，可能会想着反正时间也多，打扫个卫生，刷刷微博一上午就过去，但如果是把这些时间划分成15分钟的片段，每个片段做一件事，一上午能做的事绝对超出你的想象。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;在短暂的片刻时间内，指定一个几十分钟内要完成的任务。这几十分钟内只专做这件事，不要被其他打扰。只有倒计时才会给人紧迫感。与其在期望未来虚幻的成就，不如着眼现在，把握即将到来的一小段时间。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;我个人也在用这个软件，使用下来，确实提升了不少效率。&lt;/p&gt;
    
    </summary>
    
      <category term="tools" scheme="http://www.lydsnm.top/categories/tools/"/>
    
    
  </entry>
  
  <entry>
    <title>应用审核通过，但是内购项目一直处于正在审核中</title>
    <link href="http://www.lydsnm.top/2018/07/03/2018-07-03%E5%BA%94%E7%94%A8%E5%AE%A1%E6%A0%B8%E9%80%9A%E8%BF%87%EF%BC%8C%E4%BD%86%E6%98%AF%E5%86%85%E8%B4%AD%E9%A1%B9%E7%9B%AE%E4%B8%80%E7%9B%B4%E5%A4%84%E4%BA%8E%E6%AD%A3%E5%9C%A8%E5%AE%A1%E6%A0%B8%E4%B8%AD/"/>
    <id>http://www.lydsnm.top/2018/07/03/2018-07-03应用审核通过，但是内购项目一直处于正在审核中/</id>
    <published>2018-07-03T14:52:43.852Z</published>
    <updated>2018-07-03T14:54:22.967Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;近期应用上架会员功能，新增了几个内购项目，按部就班，应用测试通过后，提交应用商店审核。自信的勾选上审核通过后自动发布，可是应用通过审核并自动释放了，内购项目没有通过，导致线上用户版本，点击购买会员获取不到商品信息，没有任何反应，特难受。现在记录一下我的解决过程，希望对其他有遇到这个问题的朋友有所帮助。</p><a id="more"></a><p>&emsp;&emsp;尝试过重新修改下判断没有商店信息给出提醒，按照一些网友的解决方法：重新提交一个新版本审核，并改成了手动发布。然而事实告诉我，这样并没有用。审核员再次遗漏了我的内购项目。无奈之下，尝试了邮件申诉反馈。</p><p>附：<a href="https://developer.apple.com/" target="_blank" rel="noopener">https://developer.apple.com/</a> -&gt; Contact Us -&gt; App Review -&gt; Other App Review questions -&gt; I would like to <code>get the status of my app</code>。这是我的选择步骤。</p><p>&emsp;&emsp;第二天，早上8点多邮件有通知，内购通过了，线上版本不用更新可以直接用了（PS：服务器同步要时间，等到下午的时候，会员才可以正常购买）。</p><h2 id="结语："><a href="#结语：" class="headerlink" title="结语："></a>结语：</h2><p>&emsp;&emsp;如果一个版本有新增的内购项，那么这个版本还是改成<code>手动释放</code>比较好。点击发布前要检查你的内购项是否是处于<code>已批准</code>状态。如果发现应用通过后，内购审核没有红点（也就说没有按要求填写而打回）处于正在审核中，请联系苹果客服，不要重新发包了，至少我这里的经验是这样的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;近期应用上架会员功能，新增了几个内购项目，按部就班，应用测试通过后，提交应用商店审核。自信的勾选上审核通过后自动发布，可是应用通过审核并自动释放了，内购项目没有通过，导致线上用户版本，点击购买会员获取不到商品信息，没有任何反应，特难受。现在记录一下我的解决过程，希望对其他有遇到这个问题的朋友有所帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.lydsnm.top/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>私有API检测系统中是否安装了某款指定的软件</title>
    <link href="http://www.lydsnm.top/2018/06/25/2018-06-25%E7%A7%81%E6%9C%89API%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E4%BA%86%E6%9F%90%E6%AC%BE%E6%8C%87%E5%AE%9A%E7%9A%84%E8%BD%AF%E4%BB%B6/"/>
    <id>http://www.lydsnm.top/2018/06/25/2018-06-25私有API检测系统中是否安装了某款指定的软件/</id>
    <published>2018-06-25T12:34:11.000Z</published>
    <updated>2018-07-08T01:56:23.146Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;前段时间，在一个积分任务墙的项目，需要跳转到市场去安装App，了需要检测iOS设备已安装应用列表的需求，要能获取到安装情况（包括安装进度啊，完成回调等）。经过一段时间的了解，还算完成了既定任务。</p><a id="more"></a><h2 id="URL-Scheme"><a href="#URL-Scheme" class="headerlink" title="URL Scheme"></a>URL Scheme</h2><p>&emsp;&emsp;前期考虑过<code>URL Scheme</code>来判断是否安装了某个应用，但是每个app是否设置了URL scheme不知道，而且iOS9上  <code>[[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:url]]</code>的能判断的上限是50个，因此这个实际情况下无法使用。但是我们可能在其他场景下使用到URL Scheme(比如打开系统应用)，可以下面的方法列出所有的URL Scheme，但是哪个scheme是哪个应用就得靠猜了，一个应用也可能有多个URL Scheme。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span>*)privateURLSchemes&#123;</span><br><span class="line">    <span class="keyword">return</span> [_workspace privateURLSchemes];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span>*)publicURLSchemes&#123;</span><br><span class="line">    <span class="keyword">return</span> [_workspace publicURLSchemes];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取系统中安装列表和各应用的bundleId。"><a href="#获取系统中安装列表和各应用的bundleId。" class="headerlink" title="获取系统中安装列表和各应用的bundleId。"></a>获取系统中安装列表和各应用的bundleId。</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class LSApplicationWorkspace_class = objc_getClass(<span class="string">"LSApplicationWorkspace"</span>);  </span><br><span class="line">SEL selector=<span class="built_in">NSSelectorFromString</span>(<span class="string">@"defaultWorkspace"</span>);  </span><br><span class="line"><span class="built_in">NSObject</span>* workspace = [LSApplicationWorkspace_class performSelector:selector];  </span><br><span class="line">_workspace = workspace</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">&lt;objc/runtime.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"> SEL selectorALL = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"allApplications"</span>);  </span><br><span class="line"> <span class="built_in">NSArray</span> *apps = [_workspace performSelector:selectorALL];</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"apps: %@"</span>, );  </span><br><span class="line"> [apps[<span class="number">0</span>] performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"applicationIdentifier"</span>)];<span class="comment">//shortVersionString等。</span></span><br></pre></td></tr></table></figure><p>其余一些方法可以去这儿<a href="https://github.com/nst/iOS-Runtime-Headers/blob/master/Frameworks/MobileCoreServices.framework/LSApplicationProxy.h" target="_blank" rel="noopener">查看</a>：</p><p>关于LSApplicationWorkspace的使用可以查看<a href="https://www.jianshu.com/p/b8d882069197" target="_blank" rel="noopener">iOS私有方法LSApplicationWorkspace.h的一些使用</a></p><h2 id="通过定时器不断的调度-可以用下面的方法得到-所有正在下载的app"><a href="#通过定时器不断的调度-可以用下面的方法得到-所有正在下载的app" class="headerlink" title="通过定时器不断的调度 可以用下面的方法得到 所有正在下载的app"></a>通过定时器不断的调度 可以用下面的方法得到 所有正在下载的app</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 通过定时器不断调用来获取系统中所有正在下载的内容及进度。*/</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)TimerUpdateToGetDownloadProgress:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *lib = dlopen(<span class="string">"/System/Library/Frameworks/MobileCoreServices.framework/MobileCoreServices"</span>, RTLD_LAZY);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (lib)&#123;</span><br><span class="line">        Class LSApplicationWorkspace = <span class="built_in">NSClassFromString</span>(<span class="string">@"LSApplicationWorkspace"</span>);</span><br><span class="line">        <span class="keyword">id</span> AAURLConfiguration1 = [LSApplicationWorkspace performSelector:<span class="keyword">@selector</span>(defaultWorkspace)];</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (AAURLConfiguration1)&#123;</span><br><span class="line">            <span class="keyword">id</span> arrApp = [AAURLConfiguration1 performSelector:<span class="keyword">@selector</span>(allApplications)];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;[arrApp count]; i++) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">id</span> LSApplicationProxy = [arrApp objectAtIndex:i];</span><br><span class="line">                <span class="built_in">NSString</span>* bundleId =[LSApplicationProxy performSelector:<span class="keyword">@selector</span>(applicationIdentifier)];</span><br><span class="line">                <span class="built_in">NSString</span>* name = [LSApplicationProxy localizedName];</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">NSProgress</span> *progress = (<span class="built_in">NSProgress</span> *)[LSApplicationProxy performSelector:<span class="keyword">@selector</span>(installProgress)];</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"current progress:%lf bundleId:%@"</span>, [<span class="built_in">NSProgress</span> currentProgress], bundleId);</span><br><span class="line">                <span class="comment">// 正在安装的模型数据</span></span><br><span class="line"><span class="comment">//                InstallingModel *model = [self getInstallModel:bundleId];</span></span><br><span class="line">                <span class="comment">//如果是正在下载状态</span></span><br><span class="line">                <span class="keyword">if</span> (progress)&#123;</span><br><span class="line">                    <span class="comment">//已经检测到的</span></span><br><span class="line"><span class="comment">//                    if (model) &#123;</span></span><br><span class="line"><span class="comment">//                        model.progress = [progress localizedDescription];</span></span><br><span class="line"><span class="comment">//                        model.status  =  [NSString stringWithFormat:@"%@",[[progress userInfo] valueForKey:@"installState"]];</span></span><br><span class="line">                        <span class="comment">//第一次检测到的</span></span><br><span class="line"><span class="comment">//                    &#125;else&#123;</span></span><br><span class="line"><span class="comment">//                        InstallingModel *model = [[InstallingModel alloc] init];</span></span><br><span class="line"><span class="comment">//                        model.appName = name;</span></span><br><span class="line"><span class="comment">//                        model.bundleID = bundleId;</span></span><br><span class="line"><span class="comment">//                        model.progress = [progress localizedDescription];</span></span><br><span class="line"><span class="comment">//                        model.status  = [NSString stringWithFormat:@"%@",[[progress userInfo] valueForKey:@"installState"]];</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                        [_installedAry addObject:model];</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lib) dlclose(lib);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过bundle-id判断是否安装并打开app"><a href="#通过bundle-id判断是否安装并打开app" class="headerlink" title="通过bundle id判断是否安装并打开app"></a>通过bundle id判断是否安装并打开app</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过applicationIdentifier id。判断是否安装某个APP</span></span><br><span class="line">        <span class="built_in">BOOL</span> isInstall = [workspace performSelector:<span class="keyword">@selector</span>(applicationIsInstalled:) withObject:<span class="string">@"com.tencent.xin"</span>];</span><br><span class="line">        <span class="keyword">if</span> (isInstall) &#123;</span><br><span class="line">            <span class="comment">//通过bundle id打开APP</span></span><br><span class="line">            [workspace performSelector:<span class="keyword">@selector</span>(openApplicationWithBundleID:) withObject:<span class="string">@"com.tencent.xin"</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"您还没安装"</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上一些方法大都使用到了私有API、故切记要上架到app store的应用不要使用。<br>在了解过程中，一并完成了一个测试demo，有需要的可以在此基础上试验。<br><a href="https://github.com/donglyu/CheckInstalledAppEtcIniOS" target="_blank" rel="noopener">Demo地址</a></p><p>- EOF -</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;前段时间，在一个积分任务墙的项目，需要跳转到市场去安装App，了需要检测iOS设备已安装应用列表的需求，要能获取到安装情况（包括安装进度啊，完成回调等）。经过一段时间的了解，还算完成了既定任务。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.lydsnm.top/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>记一则iOS封装SDK的开发过程之WebView和JS交互</title>
    <link href="http://www.lydsnm.top/2018/05/20/%E8%AE%B0%E4%B8%80%E5%88%99iOS%E5%B0%81%E8%A3%85SDK%E7%9A%84%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B9%8BWebView%E5%92%8CJS%E4%BA%A4%E4%BA%92/"/>
    <id>http://www.lydsnm.top/2018/05/20/记一则iOS封装SDK的开发过程之WebView和JS交互/</id>
    <published>2018-05-19T16:00:00.000Z</published>
    <updated>2018-06-25T14:49:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;近来接触了一个封装sdk的项目，过程中遇到了一些问题，现在空了下来，将这个过程记录一下。<br>项目主要由<u>iOS封装一个framework静态库，库里面引入由甲方提供的js方法库（一个js文件），原生调用js中的方法，将方法返回值通过原生方法回调会去</u>。相当于一个中间件的功能。</p><p>&emsp;&emsp;我首先想到的是通过 <font color="a52a2a"><b>UIWebView</b></font> 或 <font color="a52a2a"><b>WKWebView</b></font> 来加载js，然后通过javascriptCore和WKWebView自带的方法来处理。这个甲方要求又不要显示html页面，所以使用WebView有点用了牛刀的感觉。查了查资料，没有找到直接能和js文件交互的方法，无奈还是采用了WKWebView。</p><a id="more"></a><p>&emsp;&emsp;由于wkwebView是iOS8以后推出的新框架，故而一开始就使用使用了wkwebview。当对应的html、js到位后，发现js中的回调很奇怪，原生偶尔可以得到回调，猜测可能js方法库中方法太过繁忙，从而导致消息堵塞进而丢失掉。经过延时的操作，发现并不是这个问题。</p><p>&emsp;&emsp;正如之前说的，项目并不需要展示webView，html中的内容也不需要展示。而需求是提供.framework，不可能头文件提供一个webView给开发者，添加到对应的界面上吧。因此做了一个小尝试，快速改换成了UIWebView，相应的js方法，和调用方法，以及回调方法改了下来测试。发现可以正常使用。这下得出结论WkWebView如果没有正常显示的话，内部有种“惰性”的感觉，某些js方法执行和回调很“迟缓”，往往点几次才会响应。</p><p>&emsp;&emsp;研究到这，应该是换成UIWebView了。但是抱着不甘心，多查了些资料，和试验了几波，是真的因为那个原因吗？不多说了，总结了下我的两个解决方法：</p><h2 id="最终解决"><a href="#最终解决" class="headerlink" title="最终解决"></a>最终解决</h2><h3 id="1-使用UIWebView"><a href="#1-使用UIWebView" class="headerlink" title="1.使用UIWebView"></a>1.使用UIWebView</h3><p>js中使用下面的代码回调原生</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bclMiddlecallback(callbackScheme, callbackPath);</span><br></pre></td></tr></table></figure><p>UIWebView可以不加在任何View上，也可以设置<code>.hidden = YES;</code></p><h3 id="2-继续使用WKWebView"><a href="#2-继续使用WKWebView" class="headerlink" title="2.继续使用WKWebView"></a>2.继续使用WKWebView</h3><p>js中使用下面的方法回调原生</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.webkit.messageHandlers.bclMiddlecallback.postMessage(callbackScheme + callbackPath);</span><br></pre></td></tr></table></figure><p>！！！WKWebView必须加在某个View上，内部一些机制才能正常运转、回调才能正常发生。.hidden设置或者不设置不影响。</p><p>所以：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WKWebView</span> *wkWebView = [[<span class="built_in">WKWebView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, [[<span class="built_in">UIScreen</span> mainScreen] bounds].size.height, <span class="number">320</span>, <span class="number">480</span>) configuration:configuration];</span><br><span class="line">_wkWebView = wkWebView;</span><br><span class="line">[[[<span class="built_in">UIApplication</span> sharedApplication] windows].firstObject addSubview:wkWebView];</span><br><span class="line">wkWebView.hidden = <span class="literal">YES</span>;</span><br></pre></td></tr></table></figure><p>收工！</p><hr><p>如果你也遇到此问题，如果你有新的想法请联系我：<a href="mailto:dongigndao@163.com" target="_blank" rel="noopener">dongigndao@163.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;近来接触了一个封装sdk的项目，过程中遇到了一些问题，现在空了下来，将这个过程记录一下。&lt;br&gt;项目主要由&lt;u&gt;iOS封装一个framework静态库，库里面引入由甲方提供的js方法库（一个js文件），原生调用js中的方法，将方法返回值通过原生方法回调会去&lt;/u&gt;。相当于一个中间件的功能。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;我首先想到的是通过 &lt;font color=&quot;a52a2a&quot;&gt;&lt;b&gt;UIWebView&lt;/b&gt;&lt;/font&gt; 或 &lt;font color=&quot;a52a2a&quot;&gt;&lt;b&gt;WKWebView&lt;/b&gt;&lt;/font&gt; 来加载js，然后通过javascriptCore和WKWebView自带的方法来处理。这个甲方要求又不要显示html页面，所以使用WebView有点用了牛刀的感觉。查了查资料，没有找到直接能和js文件交互的方法，无奈还是采用了WKWebView。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.lydsnm.top/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS WebView修改userAgent的问题与解决</title>
    <link href="http://www.lydsnm.top/2018/03/22/iOS%20WebView%E4%BF%AE%E6%94%B9userAgent%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/"/>
    <id>http://www.lydsnm.top/2018/03/22/iOS WebView修改userAgent的问题与解决/</id>
    <published>2018-03-21T16:00:00.000Z</published>
    <updated>2018-11-08T15:37:20.907Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;前阵子做一个阅读应用，需要嵌入H5页面，要让网页检测到是App的webView访问。网页有个loading数据过程，这个loading效果比较复杂，于是乎由客户端实现，需要网页告诉客户端什么时候该关掉Loading动画遮罩层（还有一些其他交互效果）。这就涉及到了网页和原生的交互了。客户端使用的是<font color="a52a2a">WKWebView</font>。</p><a id="more"></a><p>&emsp;&emsp;在UIWebView上修改全局userAgent就使用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIWebView</span> *webView = [[<span class="built_in">UIWebView</span> alloc] initWithFrame:<span class="built_in">CGRectZero</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *userAgent = [webView stringByEvaluatingJavaScriptFromString:<span class="string">@"navigator.userAgent"</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *newUserAgent = [userAgent stringByAppendingString:<span class="string">@" AppFlag"</span>];</span><br><span class="line">        newUserAgent = [newUserAgent stringByAppendingString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@" token/%@"</span>, token]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *dictionary = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:newUserAgent, <span class="string">@"UserAgent"</span>, <span class="literal">nil</span>];</span><br><span class="line">    [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] registerDefaults:dictionary];</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在UIWebView上获取userAgent的方法是同步的(Synchronous)。</p><p>&emsp;&emsp;如果实在WKWebView上则使用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WKWebView</span> *wkWebView = [[<span class="built_in">WKWebView</span> alloc] initWithFrame:<span class="built_in">CGRectZero</span>];</span><br><span class="line">    <span class="keyword">self</span>.wkWebView = wkWebView;</span><br><span class="line">    [wkWebView evaluateJavaScript:<span class="string">@"navigator.userAgent"</span> completionHandler:^(<span class="keyword">id</span> result, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *userAgent = result;</span><br><span class="line">        <span class="built_in">NSString</span> *newUserAgent = [userAgent stringByAppendingString:<span class="string">@" AppFlag"</span>];</span><br><span class="line">      </span><br><span class="line">    newUserAgent = [newUserAgent stringByAppendingString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@" token/%@"</span>, token]];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSDictionary</span> *dictionary = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:newUserAgent, <span class="string">@"UserAgent"</span>, <span class="literal">nil</span>];</span><br><span class="line">        [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] registerDefaults:dictionary];</span><br><span class="line">         [<span class="keyword">self</span>.wkWebView setCustomUserAgent:customUserAgent]</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在WKWebView上获取userAgent就是异步的(Asynchronous)。</p><p>&emsp;&emsp;如果在webView loadRequest之前使用WKWebView的方式修改了userAgent之后，在Safari中调试发现userAgent实际上可能并没有成功修改。其实是因为异步修改没有修改成功，如果再次load了一个新页面，再在Safari中控制台输入<code>navigator.userAgent</code>就可以查看到修改后的内容，这就是很多其他朋友说遇到的要第二次才能显示自定义的值。<strong><font color="10d3c4">这里建议使用UIWebView的方式修改全局userAgent，然后再使用WKWebView取加载内容，最简单最通用</font></strong>。如果使用WKWebView修改后再用WKWebView加载页面，需要注意获取并修改 userAgent 的 webView 对象，跟加载网页的 webView 不能是同一个对象，也就说在获取到当前的userAgent的回调里需要重新初始化 wKWebView来加载页面。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIWebView</span> *webView = [[<span class="built_in">UIWebView</span> alloc] initWithFrame:<span class="built_in">CGRectZero</span>];</span><br><span class="line"><span class="built_in">NSString</span> *userAgent = [webView stringByEvaluatingJavaScriptFromString:<span class="string">@"navigator.userAgent"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *newUserAgent = [userAgent stringByAppendingString:<span class="string">@" native_iOS"</span>];<span class="comment">//自定义需要拼接的字符串</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *dictionary = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:newUserAgent, <span class="string">@"UserAgent"</span>, <span class="literal">nil</span>];</span><br><span class="line">[[<span class="built_in">NSUserDefaults</span> standardUserDefaults] registerDefaults:dictionary];</span><br><span class="line">[<span class="keyword">self</span>.wkWebView setCustomUserAgent:customUserAgent]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>参考链接：</strong></p><p><a href="https://stackoverflow.com/questions/26994491/set-useragent-in-wkwebview" target="_blank" rel="noopener">https://stackoverflow.com/questions/26994491/set-useragent-in-wkwebview</a><br><a href="https://cloud.tencent.com/developer/article/1158832" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1158832</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;前阵子做一个阅读应用，需要嵌入H5页面，要让网页检测到是App的webView访问。网页有个loading数据过程，这个loading效果比较复杂，于是乎由客户端实现，需要网页告诉客户端什么时候该关掉Loading动画遮罩层（还有一些其他交互效果）。这就涉及到了网页和原生的交互了。客户端使用的是&lt;font color=&quot;a52a2a&quot;&gt;WKWebView&lt;/font&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="OC" scheme="http://www.lydsnm.top/categories/OC/"/>
    
    
  </entry>
  
  <entry>
    <title>苹果的Marzipan</title>
    <link href="http://www.lydsnm.top/2017/12/27/%E8%8B%B9%E6%9E%9C%E7%9A%84Marzipan/"/>
    <id>http://www.lydsnm.top/2017/12/27/苹果的Marzipan/</id>
    <published>2017-12-26T16:00:00.000Z</published>
    <updated>2018-11-14T11:35:26.931Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;听说有个新的东西：为了增强Mac上的软件产品，苹果正在计划模糊macOS和iOS平台之间的界限，允许iOS App Store上的iPhone和iPad应用程序在Mac上运行：</p><p>&emsp;&emsp;<code>Marzipan</code>  <a href="https://baijiahao.baidu.com/s?id=1587358985291753758&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">新闻来源</a>    <em>一个App适配所有设备。</em></p><a id="more"></a><p>&emsp;&emsp;一方面，熟悉苹果生态的人都比较清楚，iOS上软件质量一向很高，数量也很多，几乎能够找到所有功能的App。而对应的MAC OS平台上相比较iOS，软件上数量上就少很多了（软件质量上我个人认为是不差的。）。<br>如果iOS上的App能够跨在MAC OS上使用就好了。</p><p>&emsp;&emsp;另一方面，如果苹果能将这条通道打通的话，那么iPad的用武之地就大许多了，随之而来iPad的销量也将会大幅上升。毕竟现阶段iPad还是处于一个尴尬的处境，处理复杂事物时，还是需要Mac的文件管理系统，能够更加灵活的处理。处理文档、简单任务时，iPad还是有优势的。</p><p>&emsp;&emsp;期待一下吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;听说有个新的东西：为了增强Mac上的软件产品，苹果正在计划模糊macOS和iOS平台之间的界限，允许iOS App Store上的iPhone和iPad应用程序在Mac上运行：&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;code&gt;Marzipan&lt;/code&gt;  &lt;a href=&quot;https://baijiahao.baidu.com/s?id=1587358985291753758&amp;amp;wfr=spider&amp;amp;for=pc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;新闻来源&lt;/a&gt;    &lt;em&gt;一个App适配所有设备。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Apple" scheme="http://www.lydsnm.top/categories/Apple/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift中的值类型引用类型相关内容</title>
    <link href="http://www.lydsnm.top/2017/10/14/Swift%E4%B8%AD%E7%9A%84%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/"/>
    <id>http://www.lydsnm.top/2017/10/14/Swift中的值类型引用类型相关内容/</id>
    <published>2017-10-13T16:00:00.000Z</published>
    <updated>2018-11-14T11:36:38.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Swift中的值类型和引用类型"><a href="#一、Swift中的值类型和引用类型" class="headerlink" title="一、Swift中的值类型和引用类型"></a>一、Swift中的值类型和引用类型</h2><h3 id="值类型和引用类型是啥"><a href="#值类型和引用类型是啥" class="headerlink" title="值类型和引用类型是啥"></a>值类型和引用类型是啥</h3><p>&emsp;&emsp;最近在用Swift写代码，发现Swift中的值类型和引用类型好像有些奇怪，包括之前了解到的NSArray和Array之间的关系，有些混淆了。现在静下来来学习下，记录一下，防止后面防错。</p><p>&emsp;&emsp;首先来回顾一下基础概念：什么是值类型和引用类型。</p><blockquote><ul><li>值类型：每个实例都拥有数据的一份副本。当被赋值给一个变量或常量，或传递给一个函数时，它都会拷贝一份新的副本。</li><li>引用类型：所有实例共享一个数据副本。当被赋值给一个变量或常量，或传递给一个函数时候，一个引用类型一旦被初始化，会返回一个指向已存在实例的引用。</li></ul></blockquote><p>&emsp;&emsp;类(class)是一个引用类型，复制一个引用，即表示建立一个共享的实例。复制之后，两个变量都使用数据中同一份实例。<br>&emsp;&emsp;类(Class)是一个引用类型，意味着类中的变量不会存储实例，而是一个向内存(堆)中存储该实例位置的引用。</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"张三"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> badStudent = <span class="type">People</span>()</span><br><span class="line"><span class="keyword">var</span> goodStudent = badStudent</span><br><span class="line"></span><br><span class="line">goodStudent.name = <span class="string">"李四"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"badStudent's name:\(badStudent)"</span>) <span class="comment">// 李四</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"goodStudent's name:\(goodStudent)"</span>) <span class="comment">// 李四</span></span><br><span class="line"><span class="comment">// 修改goodStudent中的内容就相当于修改badStudent。它们所代表的是同一个东西。</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但除了Class外，Swift还有一种常用的类型：结构体。而结构体就是一个值类型。而Swift中用Struct的场景变多了。<br>类似<code>Array</code>、<code>Dictonary</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"张三"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> firstStudent = <span class="type">People</span>()</span><br><span class="line"><span class="keyword">var</span> secondStudent = firstStudent</span><br><span class="line"></span><br><span class="line">firstStudent.name = <span class="string">"李四"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"firstStudent's name:\(firstStudent)"</span>) <span class="comment">// 李四</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"secondStudent's name:\(secondStudent)"</span>) <span class="comment">// 张三</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// secondStudent用firstStudent赋值后，就是一个独立的数据实例了。</span></span><br></pre></td></tr></table></figure><p>当然，Swift中值类型和引用类型还有很多：</p><p><img src="http://cc.cocimg.com/api/uploads//20180503/1525333385999865.png" alt="Swift中值类型和引用类型表"></p><blockquote><p>Swift把一个引用类型看成一个类，这和Objective-C中很像。Objective-C中一切继承于NSObject都被按照引用类型存储。</p></blockquote><h3 id="什么时候用值引用和引用类型好"><a href="#什么时候用值引用和引用类型好" class="headerlink" title="什么时候用值引用和引用类型好"></a>什么时候用值引用和引用类型好</h3><ul><li>以下时候使用值类型：</li></ul><p>想要用==比较实例数据。一个双等号(==)用于比较值。</p><p>你想复制来建立独立数据。</p><p>数据要在多线程的代码中使用，那么你就不用担心数据会被其他线程改变。</p><ul><li>以下时候使用引用类型(比如一个类)：</li></ul><p>想要用==比较实例一致性。==会检查两个对象是否完全一致，包括存储数据的内存地址。</p><p>你想要创建用于共享，可改变的数据。</p><hr><h3 id="值类型和引用类型的存储"><a href="#值类型和引用类型的存储" class="headerlink" title="值类型和引用类型的存储"></a>值类型和引用类型的存储</h3><blockquote><p>值类型-在栈内存中存储、而引用类型-在托管堆内存中存储。</p></blockquote><p>像前面说的，引用类型实例存在堆中，值类型实例比如结构存在于一个称为栈的内存区域中。如果值类型实例是一个类的一部分，值会和类一起存在堆中。</p><p>栈被用于静态存储分配，栈用于动态存储分配，它们都存在计算机的RAM中。</p><p>栈被CPU紧密管理并优化，当一个函数创建一个变量，栈会存储这个变量，并在函数退出时候被毁掉。被分配到栈的变量直接存储在内存上，访问这段内存非常快。当一个函数或者方法调用另一个函数，另一个函数再依次调用其他函数等等，直到最后一个函数返回它的值之前，其他所有函数都会保持暂停执行。</p><p>栈总是按照LIFO顺序保留，最新保留的区块总是会下一个释放。这使得跟踪记录栈非常简单，释放一个栈上的区块不过是调整一个指针。因为栈非常组织有序，所以它快捷高效。</p><p>系统使用堆存储被其他对象引用的数据，堆是一大片内存，系统可以从中请求并动态分配内存区块。堆并不会像栈一样自动毁掉它的对象，需要外部工作来处理这些。在苹果设备中ARC就做这个工作。引用数量会被ARC追踪，当它变为0时对象会被释放。因此整个过程(分配，追踪引用，释放)会比栈要慢。所以值类型要快于引用类型。</p><h2 id="二、Swift中的Array"><a href="#二、Swift中的Array" class="headerlink" title="二、Swift中的Array"></a>二、Swift中的Array</h2><p>&emsp;&emsp;在OC中数组可以copy或者mutablecopy，可变数组和不可变数组可以来回拷贝数据。NSArray、NSMutableArray之间是不同点实例，来回处理过后，内部存储的元素其实指针所指向内容都是同一个。</p><p>而在Swift中常用的数组对象<code>Array</code>。跳转到其定义处：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Array</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;发现其实Array是一个结构体，是一个值类型，且不自带copy方法的方法，数组分成:可变数组和不可变数组，分别使用let修饰的数组是不可变数组，使用var修饰的数组是可变数组。如果想要实现拷贝方法，则需要对对象实现拷贝方法。即遵守NSCopying协议和实现copyWithZone方法<br>eg:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现NSCopying协议。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">NSObject</span>, <span class="title">NSCopying</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">copyWithZone</span><span class="params">(zone: NSZone)</span></span> -&gt; <span class="type">AnyObject</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> person = <span class="type">Person</span>()</span><br><span class="line">        person.name = <span class="keyword">self</span>.name</span><br><span class="line">        person.age = <span class="keyword">self</span>.age</span><br><span class="line">        <span class="keyword">return</span> person</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;所以在Swift中，像Array、Dictinary和Set这样的值类型集合，注意和OC中的NSArray、NSDictionary和NSSet有区别了。当被传递后，将会拷贝一份副本，之前那份数据的变更后面并不会同步更新过来，这点需要注意点。刚开始在这儿按照OC的惯性思维遇到了数据不一致的问题。另外提一句，像Array、Dictionary和Set这些是通过一个叫写时复制 (copy-on-write)的技术实现。<br>（简单提一下：就是为了提供高效的写时复制特性，我们需要知道一个对象 (比如这里的 NSMutableData) 是否是唯一的。如果它是唯一引用，那么我们就可以直接原地修改对象。否则，我们需要在修改前创建对象的复制。）。</p><p>—- 完 —-</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、Swift中的值类型和引用类型&quot;&gt;&lt;a href=&quot;#一、Swift中的值类型和引用类型&quot; class=&quot;headerlink&quot; title=&quot;一、Swift中的值类型和引用类型&quot;&gt;&lt;/a&gt;一、Swift中的值类型和引用类型&lt;/h2&gt;&lt;h3 id=&quot;值类型和引用类型是啥&quot;&gt;&lt;a href=&quot;#值类型和引用类型是啥&quot; class=&quot;headerlink&quot; title=&quot;值类型和引用类型是啥&quot;&gt;&lt;/a&gt;值类型和引用类型是啥&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;最近在用Swift写代码，发现Swift中的值类型和引用类型好像有些奇怪，包括之前了解到的NSArray和Array之间的关系，有些混淆了。现在静下来来学习下，记录一下，防止后面防错。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;首先来回顾一下基础概念：什么是值类型和引用类型。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;值类型：每个实例都拥有数据的一份副本。当被赋值给一个变量或常量，或传递给一个函数时，它都会拷贝一份新的副本。&lt;/li&gt;
&lt;li&gt;引用类型：所有实例共享一个数据副本。当被赋值给一个变量或常量，或传递给一个函数时候，一个引用类型一旦被初始化，会返回一个指向已存在实例的引用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;类(class)是一个引用类型，复制一个引用，即表示建立一个共享的实例。复制之后，两个变量都使用数据中同一份实例。&lt;br&gt;&amp;emsp;&amp;emsp;类(Class)是一个引用类型，意味着类中的变量不会存储实例，而是一个向内存(堆)中存储该实例位置的引用。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="http://www.lydsnm.top/categories/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift中常见的`$0` `$1`有什么用？</title>
    <link href="http://www.lydsnm.top/2017/09/08/Swift%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84$0%E4%BD%9C%E7%94%A8/"/>
    <id>http://www.lydsnm.top/2017/09/08/Swift中常见的$0作用/</id>
    <published>2017-09-07T16:00:00.000Z</published>
    <updated>2018-11-08T15:36:42.606Z</updated>
    
    <content type="html"><![CDATA[<p><code>$0</code>，<code>$1</code>… 是对闭包中参数的简化写法</p><p>&emsp;&emsp;swift自动为 <b><font color="red">闭包</font></b> 提供参数名缩写功能，可以直接通过<code>$0</code>和<code>$1</code>等来表示闭包中的第一个第二个参数，并且对应的参数类型会根据函数类型来进行判断。如下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用`$0` `$1`这些来代替</span></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>]</span><br><span class="line">        sortNumbers = numbers.sorted(by: &#123; (a, b) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> a &lt; b</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"numbers -"</span> + <span class="string">"\(sortNumbers)"</span>)</span><br><span class="line"><span class="comment">// 使用$0,$1</span></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>]</span><br><span class="line"> <span class="keyword">var</span> sortNumbers = numbers.sorted(by: &#123;$<span class="number">0</span> &lt; $<span class="number">1</span>&#125;)</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">"numbers -"</span> + <span class="string">"\(sortNumbers)"</span>)</span><br></pre></td></tr></table></figure> <a id="more"></a><p>&emsp;&emsp;使用<code>$0</code>、<code>$1</code>的话，参数类型可以自动判断，并且<code>in</code>关键字也可以省略，也就是只用写函数体就可以了。来看看另外个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = &#123; (arg1: <span class="type">Int</span>, arg2: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2</span><br><span class="line">&#125;</span><br><span class="line">add = &#123; (arg1, arg2) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2</span><br><span class="line">&#125;</span><br><span class="line">add = &#123; arg1, arg2 <span class="keyword">in</span></span><br><span class="line">    arg1 + arg2</span><br><span class="line">&#125;</span><br><span class="line">add = &#123;</span><br><span class="line">    $<span class="number">0</span> + $<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = add(<span class="number">10</span>, <span class="number">10</span>) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>—– 完 —–</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;$0&lt;/code&gt;，&lt;code&gt;$1&lt;/code&gt;… 是对闭包中参数的简化写法&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;swift自动为 &lt;b&gt;&lt;font color=&quot;red&quot;&gt;闭包&lt;/font&gt;&lt;/b&gt; 提供参数名缩写功能，可以直接通过&lt;code&gt;$0&lt;/code&gt;和&lt;code&gt;$1&lt;/code&gt;等来表示闭包中的第一个第二个参数，并且对应的参数类型会根据函数类型来进行判断。如下代码：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 不使用`$0` `$1`这些来代替&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; numbers = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sortNumbers = numbers.sorted(by: &amp;#123; (a, b) -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a &amp;lt; b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;numbers -&quot;&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&quot;\(sortNumbers)&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用$0,$1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; numbers = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; sortNumbers = numbers.sorted(by: &amp;#123;$&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;lt; $&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;numbers -&quot;&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&quot;\(sortNumbers)&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="swift" scheme="http://www.lydsnm.top/categories/swift/"/>
    
    
  </entry>
  
  <entry>
    <title>关于术业有专攻的小小感悟</title>
    <link href="http://www.lydsnm.top/2017/09/01/%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%B0%8F%E7%9A%84%E7%BB%8F%E9%AA%8C/"/>
    <id>http://www.lydsnm.top/2017/09/01/一个小小的经验/</id>
    <published>2017-08-31T16:00:00.000Z</published>
    <updated>2018-11-14T11:39:09.690Z</updated>
    
    <content type="html"><![CDATA[<p>那就是 <b><font color="a52a2a" size="5">写些小工具如果要发布，还是和其他专业的人合作比较好一些。</font></b></p><a id="more"></a><p>&emsp;&emsp;最近在做一个项目，在APP的菜单结构犯了难，不知道该用这种比较符合。我的目的是尽量精致而简洁，没有一些花里胡哨的设计内容。<br>&emsp;&emsp;今天突然就想记录一下。也贴出来一些，我觉得还可以的设计。就算不在现在在做的sideProject中用，以后也有用的到的。</p><p>&emsp;&emsp;以前只是了解术业有专攻，每个人都不可能每个方面都擅长。跑道上领先的都是很懂的合作的人<del>~</del>~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;那就是 &lt;b&gt;&lt;font color=&quot;a52a2a&quot; size=&quot;5&quot;&gt;写些小工具如果要发布，还是和其他专业的人合作比较好一些。&lt;/font&gt;&lt;/b&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="http://www.lydsnm.top/categories/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>Slice 一个小而简的Mac计时软件.拖延症神器.倒计时小工具</title>
    <link href="http://www.lydsnm.top/2017/05/30/Slice%E4%B8%80%E4%B8%AA%E5%B0%8F%E8%80%8C%E7%B2%BE%E7%AE%80%E7%9A%84Mac%E8%AE%A1%E6%97%B6%E8%BD%AF%E4%BB%B6%EF%BC%8C%E6%8B%96%E5%BB%B6%E7%97%87%E7%A5%9E%E5%99%A8%EF%BC%8C%E5%80%92%E8%AE%A1%E6%97%B6%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <id>http://www.lydsnm.top/2017/05/30/Slice一个小而精简的Mac计时软件，拖延症神器，倒计时小工具/</id>
    <published>2017-05-29T16:00:00.000Z</published>
    <updated>2018-06-25T14:50:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;对于常年和电脑打交道的人群来说，在很多时候, 人往往变得浮躁, 坐在电脑旁不到几分钟就像打开网页看视频啊, 打开游戏, 干些不相关的东西，专注力不够，从而导致工作效率低，工作质量不高的效果，进而影响到我们的生活，心情等。<br>        现在你试试这个小工具：<br><img src="http://ocs32tleq.bkt.clouddn.com/14961482427792.jpg" alt=""></p><p>&emsp;&emsp;有研究表明，合理的运用人的精力，松紧有弛，能够最大限度的发挥人的能力。自然界本身有它的脉动，一种在活动和休息之间周期性的像波浪一样的运动。想想潮涨潮落、季节变化，以及每天的日出日落。同样，所有的机体都遵循一种维持生命的有规则的变化。就像运动员，我们发现那些成绩好的运动员往往更懂得如何放松和规划自己的精力，在高强度，长时间，高压力的比赛中，很难保持长时间的高水准，因此这些人通常会抓紧一切时间储存精力，等到需要的爆发的时候，集中全部的注意力，更能发挥出好的运动水平，对于普通人，这也同样适用。</p><a id="more"></a><p><img src="http://ocs32tleq.bkt.clouddn.com/%E5%92%96%E5%95%A1.jpg" alt="咖啡"></p><p>&emsp;&emsp;现在针对这种情况，您可以使用Slice这个小工具，别看它小，但是简洁简单有效，可以有效指定完成某项工作要花的时间，让您有一种紧迫感来做事，进而提高注意力提高工作效率。也可以用来控制工作时间，毕竟人的精力精神不会连续好几个小时高度保持注意，懂得平衡的奥秘，累了，渴了不如出去走走，喝喝水，看看远方，说不定工作的难题就在这些休息过程中想到的最佳的解决方案la😄。</p><h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><p><img src="http://ocs32tleq.bkt.clouddn.com/14961479652001.jpg" alt=""></p><p>写好要做的事，订好一个时间，就可以开始啦。</p><p>&emsp;&emsp;还可以做一些小的设置：<br><img src="http://ocs32tleq.bkt.clouddn.com/14961482832008.jpg" alt=""></p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>自定义下一件唯一要做的事，让你专注于工作中…</li><li>自定义提示文字信息。</li><li>可简单控制结束的音效播放。</li><li>CPU 占用率超低, 不会影响您的工作。</li></ul><p>&emsp;&emsp;总之，可以通过Slice，可以平复烦躁杂乱的心，专注于单线程，提升效率。</p><p><br></p><font size="6" color="10d3c4">您唯一要做的事就是自己要遵守自己定的要做的事</font><h3 id="可能遇到的问题："><a href="#可能遇到的问题：" class="headerlink" title="可能遇到的问题："></a>可能遇到的问题：</h3><p>&emsp;&emsp;针对某些用户所说，在10.11以后系统可能安装不了的情况。</p><p>可以在“设置”中“安全与隐私”的“通用”选项下， 设置<b>允许从任何来源的应用</b>。然后就可以正常使用Slice了。<br>因为Slice是本人在业余时间开发，并未上架App store，且OS X系统有这么一个保护机制，故有这样现象。</p><p><img src="http://ocs32tleq.bkt.clouddn.com/PastedGraphic-1-systemSettingforMac.png" alt="系统设置"></p><p>&emsp;&emsp;如果在这个地方没有“任何来源”一项的话，就需要打开系统应用“终端”，输入</p><p><code>sudo spctl --master-disable</code><br>然后再输入你的系统密码回车即可（不屏显）。</p><h3 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a>下载地址：</h3><p><a href="http://pan.baidu.com/s/1mium0J2" target="_blank" rel="noopener">Slice 1.0</a></p><p><br></p><h3 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h3><p>&emsp;&emsp;这个小的app希望对你有用。虽然很小，还还算有用，平时提醒喝喝茶或者短暂休息下。<br>如果你希望能更新此软件的功能，或者有什么建议或者意见，可以通过下面的方式联系我：<br><a href="mailto:dongingdao@163.com" target="_blank" rel="noopener">dongingdao@163.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;对于常年和电脑打交道的人群来说，在很多时候, 人往往变得浮躁, 坐在电脑旁不到几分钟就像打开网页看视频啊, 打开游戏, 干些不相关的东西，专注力不够，从而导致工作效率低，工作质量不高的效果，进而影响到我们的生活，心情等。&lt;br&gt;        现在你试试这个小工具：&lt;br&gt;&lt;img src=&quot;http://ocs32tleq.bkt.clouddn.com/14961482427792.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;有研究表明，合理的运用人的精力，松紧有弛，能够最大限度的发挥人的能力。自然界本身有它的脉动，一种在活动和休息之间周期性的像波浪一样的运动。想想潮涨潮落、季节变化，以及每天的日出日落。同样，所有的机体都遵循一种维持生命的有规则的变化。就像运动员，我们发现那些成绩好的运动员往往更懂得如何放松和规划自己的精力，在高强度，长时间，高压力的比赛中，很难保持长时间的高水准，因此这些人通常会抓紧一切时间储存精力，等到需要的爆发的时候，集中全部的注意力，更能发挥出好的运动水平，对于普通人，这也同样适用。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://www.lydsnm.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="tool" scheme="http://www.lydsnm.top/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>iOS实现实时通信或推送的常用策略</title>
    <link href="http://www.lydsnm.top/2017/04/20/iOS%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E9%80%9A%E4%BF%A1%E6%88%96%E6%8E%A8%E9%80%81%E7%9A%84%E5%B8%B8%E7%94%A8%E7%AD%96%E7%95%A5/"/>
    <id>http://www.lydsnm.top/2017/04/20/iOS实现实时通信或推送的常用策略/</id>
    <published>2017-04-19T16:00:00.000Z</published>
    <updated>2018-03-04T15:42:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-iOS静默推送，不含alert，没有声音没有弹框，具体更多可以看这儿"><a href="#1-iOS静默推送，不含alert，没有声音没有弹框，具体更多可以看这儿" class="headerlink" title="1.iOS静默推送，不含alert，没有声音没有弹框，具体更多可以看这儿"></a>1.iOS静默推送，不含alert，没有声音没有弹框，具体更多可以看<a href="http://blog.csdn.net/hherima/article/details/50469519" target="_blank" rel="noopener">这儿</a></h3><p>限制与注意：<br><code>Silent Remote Notifications</code>是在Apple的限制下有一定的频率控制，并不是所有的静默推送都能按预期到达客户端触发函数的。<br>前提：客户端需处于Background或Suspended状态。<br>Apple 官方文档说：<a href="https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html" target="_blank" rel="noopener">Configuring a Silent Notification</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Silent notifications are not meant as a way to keep your app awake in the background, nor are they meant for high priority updates. APNs treats silent notifications as low priority and may throttle their delivery altogether if the total number becomes excessive. The actual limits are dynamic and can change based on conditions, but try not to send more than a few notifications per hour.</span><br></pre></td></tr></table></figure><p>用户如果禁止了推送权限，还能收到静默推送吗？这将是一个问题。</p><a id="more"></a><h3 id="2-轮询"><a href="#2-轮询" class="headerlink" title="2.轮询"></a>2.轮询</h3><p>1.Http polling<br>2.Http Long-polling</p><blockquote><p>Http polling也就是轮询的策略，它唯一的优点就是实现简单，技术门槛低。但是缺点也很明显：不够实时，且效率低下，导致server端负载较高。</p></blockquote><blockquote><p>Http Long-polling（长轮询，也称作comet）技术，是在Http polling基础上优化而来。在长轮询策略下，当server端没有数据推送到client端时，请求不会立即返回，而是被server端hold住，直到有数据发送，或者超时，才发送响应。Client端收到响应之后，立即重新发起http请求。<br>这种策略比简单的轮询优化了许多，但开发和维护成本也提高了许多。并且，效率还不够高，存在资源的浪费。而这主要是因为http协议头本身带来的overhead。</p></blockquote><h3 id="3-长连接"><a href="#3-长连接" class="headerlink" title="3.长连接"></a>3.长连接</h3><blockquote><p>Socket长连接是目前认为优点最多的解决方案。这一方案的原理是client端向server端建立一个TCP长连接，通过心跳的机制维护连接畅通，当有数据需要交互时，双方都可以通过这个长连接进行通信。</p></blockquote><blockquote><p>多年前这种方案无法应用在浏览器端，然而随着html5的兴起和浏览器的发展，目前主流的浏览器都已经支持websocket了，可以很好的实现长连接。</p></blockquote><blockquote><p>Socket长连接是最理想的方案，但开发成本也相应的最高。服务端需要支持大量的连接数，且长连接本身的特性也决定了服务不再是无状态的，这给服务的稳定性和可扩展性带来了一定的挑战。</p></blockquote><h2 id="评估："><a href="#评估：" class="headerlink" title="评估："></a>评估：</h2><p>从成本来说，客户端轮询请求 服务器压力最小，但是不太敏感<br>tcp长连接呢，服务器压力大些，但是消息及时。</p><p>iOS如果要用socket长连接的话，可以用<a href="http://www.cocoachina.com/ios/20160602/16572.html" target="_blank" rel="noopener">这篇文章</a>提到的<a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="noopener">CocoaAsyncSocket</a></p><p>可以用<code>CocoaAsyncSocket</code>先写一个<a href="http://www.cnblogs.com/XYQ-208910/p/5169209.html" target="_blank" rel="noopener">Demo</a></p><p>如果想了解更多CocoaAsyncSocket可以从这篇文章入手：<a href="http://www.cocoachina.com/ios/20170127/18619.html" target="_blank" rel="noopener">iOS即时通讯进阶 - CocoaAsyncSocket源码解析(Connect篇)</a></p><p>备选：<a href="https://github.com/facebook/SocketRocket" target="_blank" rel="noopener">SocketRocket</a></p><hr><p>— 备注区，不算入文章内。</p><ul><li>其他</li></ul><p>&emsp;&emsp;建立tcp连接，定期发keep alive防止socket超时断开。发消息直接发tcp数据包。<br>或者直接用第三方的push notification服务。原理类似，只不过平台统一keep alive省电。需要注册在服务提供方注册。</p><p>&emsp;&emsp;服务端给客户端推送，普遍做法是客户端与服务端维持一个长连接，客户端定时向服务端发送心跳以维持这个长连接。当有新消息过来的时候，服务端查出该消息对应的TCP Channel的ID并找到对应的通道进行消息下发。</p><p>&emsp;&emsp;国内安卓应用，如果没有使用GCM，绝大多数没有使用，那就起后台Service定时唤醒系统查询，一个是为了保持心跳，一个是为了查询消息。这种机制非常浪费运营商的资源，也非常费电。所以，建议把所有的应用设置都看清楚，尽量选择非推送。尤其是天气预报，手工查一下就行了，否则，那个所谓的墨迹天气，5分钟查一次，频率比得上微信了。完全没有必要，太费电了。要是赶上小区拥堵的情况，频繁的PDP激活，建立RRC连接，再释放，电池消耗特别大。而且还会发热，用户体验会很糟糕。</p><p>&emsp;&emsp;连接都是由客户端发起的！（因为客户端通常在子网下，没有公网IP，根本没办法接受连接）所谓『推送』的实现方式无外乎两种：一是基于长连接，客户端发起连接，双方维护这个连接，服务器端有变动随时拿这个连接通知客户端。这就是正常意义上的『推送』。二是基于短连接，客户端轮询发起短连接，询问服务器端变化。这实际上是『拉取』，并不是『推送』。燃鹅，维护连接的成本太大了，除了即时性要求苛刻的场景之外，大家普遍采用了第二种方法。</p><h3 id="iOS中应用内部实现长连接发送接受机制。"><a href="#iOS中应用内部实现长连接发送接受机制。" class="headerlink" title="iOS中应用内部实现长连接发送接受机制。"></a>iOS中应用内部实现长连接发送接受机制。</h3><ol><li>基于Http的长连接。（用的比较少）</li><li>基于Socket的长连接。</li><li>基于xmpp的消息P2P消息机制</li></ol><p>貌似普通的socket连接对服务器的消耗太大了。（是否有其他协议，比较有名的是MQTT协议）</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-iOS静默推送，不含alert，没有声音没有弹框，具体更多可以看这儿&quot;&gt;&lt;a href=&quot;#1-iOS静默推送，不含alert，没有声音没有弹框，具体更多可以看这儿&quot; class=&quot;headerlink&quot; title=&quot;1.iOS静默推送，不含alert，没有声音没有弹框，具体更多可以看这儿&quot;&gt;&lt;/a&gt;1.iOS静默推送，不含alert，没有声音没有弹框，具体更多可以看&lt;a href=&quot;http://blog.csdn.net/hherima/article/details/50469519&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这儿&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;限制与注意：&lt;br&gt;&lt;code&gt;Silent Remote Notifications&lt;/code&gt;是在Apple的限制下有一定的频率控制，并不是所有的静默推送都能按预期到达客户端触发函数的。&lt;br&gt;前提：客户端需处于Background或Suspended状态。&lt;br&gt;Apple 官方文档说：&lt;a href=&quot;https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Configuring a Silent Notification&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Silent notifications are not meant as a way to keep your app awake in the background, nor are they meant for high priority updates. APNs treats silent notifications as low priority and may throttle their delivery altogether if the total number becomes excessive. The actual limits are dynamic and can change based on conditions, but try not to send more than a few notifications per hour.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;用户如果禁止了推送权限，还能收到静默推送吗？这将是一个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.lydsnm.top/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://www.lydsnm.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>对UIMenuController菜单自定义</title>
    <link href="http://www.lydsnm.top/2017/02/06/%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89UIWebView%20%E7%9A%84UIMenuController%E9%80%89%E9%A1%B9/"/>
    <id>http://www.lydsnm.top/2017/02/06/实现自定义UIWebView 的UIMenuController选项/</id>
    <published>2017-02-05T16:00:00.000Z</published>
    <updated>2018-03-04T15:42:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;项目中遇到了需要对UIWebView中弹出菜单的一些定制，所以查找一些资料，整理记录一下。</p><p>首先看看UIMenuController默认支持的方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)cut:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)<span class="keyword">copy</span>:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)paste:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)select:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)selectAll:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)delete:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_2);</span><br><span class="line">- (<span class="keyword">void</span>)makeTextWritingDirectionLeftToRight:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)makeTextWritingDirectionRightToLeft:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)toggleBoldface:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)toggleItalics:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)toggleUnderline:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)increaseSize:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)decreaseSize:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更多带_的私有方法可以看: https://yq.aliyun.com/articles/39475</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>而我们常用的是<code>cut</code>，<code>copyt</code>，<code>past</code>，<code>selct</code>等。因此主要是对这几个方法的处理。</p><h3 id="实现自定义菜单（UITextView、UITextField）"><a href="#实现自定义菜单（UITextView、UITextField）" class="headerlink" title="实现自定义菜单（UITextView、UITextField）"></a>实现自定义菜单（UITextView、UITextField）</h3><p>&emsp;&emsp;要想实现自定义显示的长按文字菜单, subClass UIWebViewController. 然后重写方法:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">BOOL</span>)canPerformAction:(SEL)action withSender:(<span class="keyword">id</span>)sender&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">@selector</span>(selectAll:) || action == <span class="keyword">@selector</span>(cut:)\</span><br><span class="line">        || action == <span class="keyword">@selector</span>(delete:)\</span><br><span class="line">        || action == <span class="keyword">@selector</span>(toggleUnderline:)\</span><br><span class="line">        || action == <span class="keyword">@selector</span>(toggleBoldface:)\</span><br><span class="line">        || action == <span class="keyword">@selector</span>(toggleItalics:)\</span><br><span class="line">        || action == <span class="built_in">NSSelectorFromString</span>(<span class="string">@"_showTextStyleOptions:"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> canPerformAction:action withSender:sender];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可编辑的UIWebView自定义UIMenuController选项"><a href="#可编辑的UIWebView自定义UIMenuController选项" class="headerlink" title="可编辑的UIWebView自定义UIMenuController选项"></a>可编辑的UIWebView自定义UIMenuController选项</h3><p>&emsp;&emsp;前期尝试过创建UIWebView之类, 然后重写<code>canPerformAction:(SEL)action withSender:(id)sender</code>方法来控制显示和隐藏哪些菜单项, 但是发现不行(UITextView等可以)。查看UIWebView的subViews, 可以发现一个类: <font color="a52a2a">UIWebBrowserView</font>which has a text property, from this we know what class we need to subclass.然而这个UIWebBrowserView又是一个私有类,通过正常方式又获取不到.<br>思路有两个: 一个是通过运行时替换这个class的方法成我们自己的方法。二是通过创建<code>UIWebBrowserView</code>的类别，并用我们的方法替换掉原来的方法(私有API,传App Store会被打回)。</p><hr><h4 id="1-通过runtime替换方法"><a href="#1-通过runtime替换方法" class="headerlink" title="1. 通过runtime替换方法"></a>1. 通过runtime替换方法</h4><p>添加方法<code>mightPerformAction:withSender:</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)mightPerformAction:(SEL)action withSender:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"******Action!! %@******"</span>,<span class="built_in">NSStringFromSelector</span>(action));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (action == <span class="keyword">@selector</span>(<span class="keyword">copy</span>:))</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"Copy Selector"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (action == <span class="keyword">@selector</span>(cut:))</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"cut Selector"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (action == <span class="built_in">NSSelectorFromString</span>(<span class="string">@"_define:"</span>))</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"define Selector"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (action == <span class="keyword">@selector</span>(paste:))</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"paste Selector"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">return</span> [<span class="keyword">super</span> canPerformAction:action withSender:sender];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是替换旧的<code>canPerformAction:action withSender:sender</code>方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) replaceUIWebBrowserView: (<span class="built_in">UIView</span> *)view</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Iterate through subviews recursively looking for UIWebBrowserView</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">UIView</span> *sub <span class="keyword">in</span> view.subviews) &#123;</span><br><span class="line">    [<span class="keyword">self</span> replaceUIWebBrowserView:sub];</span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSStringFromClass</span>([sub <span class="keyword">class</span>]) isEqualToString:<span class="string">@"UIWebBrowserView"</span>]) &#123;</span><br><span class="line"></span><br><span class="line">        Class <span class="keyword">class</span> = sub.class;</span><br><span class="line"></span><br><span class="line">        SEL originalSelector = <span class="keyword">@selector</span>(canPerformAction:withSender:);</span><br><span class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(mightPerformAction:withSender:);</span><br><span class="line"></span><br><span class="line">        Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(<span class="keyword">self</span>.class, swizzledSelector);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//add the method mightPerformAction:withSender: to UIWebBrowserView</span></span><br><span class="line">        <span class="built_in">BOOL</span> didAddMethod =</span><br><span class="line">        class_addMethod(<span class="keyword">class</span>,</span><br><span class="line">                        originalSelector,</span><br><span class="line">                        method_getImplementation(swizzledMethod),</span><br><span class="line">                        method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        <span class="comment">//replace canPerformAction:withSender: with mightPerformAction:withSender:</span></span><br><span class="line">        <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">            class_replaceMethod(<span class="keyword">class</span>,</span><br><span class="line">                                swizzledSelector,</span><br><span class="line">                                method_getImplementation(originalMethod),</span><br><span class="line">                                method_getTypeEncoding(originalMethod));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在ViewController的viewDidLoad中调用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> replaceUIWebBrowserView:<span class="keyword">self</span>.webView];</span><br></pre></td></tr></table></figure><blockquote><p>注意1: 在viewController中添加 #import &lt;objc/runtime.h&gt; 避免 error(Method).</p></blockquote><blockquote><p>注意2:  使用<code>NSSelectorFromString</code>方法避免审核过程中被检测到使用到了私有API.</p></blockquote><p>参考: <a href="http://stackoverflow.com/questions/25263687/disable-long-press-menu-in-text-area-input-uiwebview/25263688#25263688" target="_blank" rel="noopener">http://stackoverflow.com/questions/25263687/disable-long-press-menu-in-text-area-input-uiwebview/25263688#25263688</a> </p><h4 id="2-通过扩展类别"><a href="#2-通过扩展类别" class="headerlink" title="2.通过扩展类别"></a>2.通过扩展类别</h4><p>另外在查找资料的过程中还发现种方法(UIWebBrowserView), 但是这种方法使用到了私有api, 会被打回. 切记:<br><a href="http://www.ios-blog.co.uk/tutorials/rich-text-editing-highlighting-and-uimenucontroller-part-3/" target="_blank" rel="noopener">http://www.ios-blog.co.uk/tutorials/rich-text-editing-highlighting-and-uimenucontroller-part-3/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;项目中遇到了需要对UIWebView中弹出菜单的一些定制，所以查找一些资料，整理记录一下。&lt;/p&gt;
&lt;p&gt;首先看看UIMenuController默认支持的方法：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)cut:(&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;:(&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)paste:(&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)select:(&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)selectAll:(&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)delete:(&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;_2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)makeTextWritingDirectionLeftToRight:(&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)makeTextWritingDirectionRightToLeft:(&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)toggleBoldface:(&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)toggleItalics:(&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)toggleUnderline:(&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)increaseSize:(&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)decreaseSize:(&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 更多带_的私有方法可以看: https://yq.aliyun.com/articles/39475&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.lydsnm.top/categories/iOS/"/>
    
    
      <category term="-runtime -运行时" scheme="http://www.lydsnm.top/tags/runtime-%E8%BF%90%E8%A1%8C%E6%97%B6/"/>
    
  </entry>
  
  <entry>
    <title>OC开发相关注意事项</title>
    <link href="http://www.lydsnm.top/2016/10/20/OC%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%9B%9B/"/>
    <id>http://www.lydsnm.top/2016/10/20/OC开发相关注意事项四/</id>
    <published>2016-10-19T16:00:00.000Z</published>
    <updated>2018-08-30T14:36:56.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第7章-熟悉系统框架"><a href="#第7章-熟悉系统框架" class="headerlink" title="第7章 熟悉系统框架"></a>第7章 熟悉系统框架</h2><p>将一系列代码封装为动态库 (dynamic library) , 并在其中放入描述其借口的头文件, 这样做出来的东西就叫 <font color="a52a2a">框架</font> .有时为 iOS 平台构建的第三方框架实用的是静态库 (static libaray), 这是因为 iOS 应用程序不允许在其中包含动态库.</p><p>开发者主要会碰到<code>Foundation</code>, 像是 <code>NSOject</code>, <code>NSArray</code>, <code>NSDictionary</code> 等类都在其中, <code>Foundation</code> 是应用程序的 “基础”.</p><p>还有个与 <code>Foundation</code> 相伴的框架, 叫做 <code>CoreFoundation</code> , 从技术上来将, <code>CoreFoundation</code> 框架不是 <code>Objective-C</code> 框架, 但它是编写 <code>Objective-C</code> 应用程序时所应熟悉的重要框架. <code>Foundation</code> 框架中的很多功能, 都可以在此框架中找到对应的 C 语言 API. 可以用”无缝桥接”(tollfree bridging). 可以吧 <code>CoreFoundation</code> 中的 C 语言数据结构平滑转换为 <code>Foundation</code>中的 Objective-C 对象.</p><p>除了<code>Foundation</code> 还有 <code>CFNetwork</code> , <code>CoreAudio</code>, <code>AVFoundation</code>, <code>CoreData</code>, <code>CoreText</code> ….</p><a id="more"></a><p><br></p><h3 id="1-构建缓存时选用-NSCache-而非-NSDictionary"><a href="#1-构建缓存时选用-NSCache-而非-NSDictionary" class="headerlink" title="1. 构建缓存时选用 NSCache 而非 NSDictionary"></a>1. 构建缓存时选用 <code>NSCache</code> 而非 <code>NSDictionary</code></h3><p>因为 <code>NSCache</code> 可以提供优雅的自动删减功能, 而且是 “线程安全的”. 此外, 它与字典不同, 不会拷贝键.<br>可以给 <code>NSCache</code> 对象设置上限, 用以限制缓存中的对象总个数及”总成本”<br>将 <code>NSPurgeableData</code> 与 <code>NSCache</code> 搭配使用, 可实现自动清除数据的功能.</p><h3 id="2-loadView-amp-initialize"><a href="#2-loadView-amp-initialize" class="headerlink" title="2. loadView &amp; initialize"></a>2. <code>loadView</code> &amp; <code>initialize</code></h3><p><code>loadView</code> &amp; <code>initialize</code> 中的代码要尽量精简.这有助于保持应用程序的响应能力, 也能减少引入 “依赖环” 的几率.</p><p><code>initialize</code>是惰性调用的, 只有当程序用到了相关的类时, 才会调用. 而对于<code>loadView</code>来说, 应用程序必须阻塞并等着所有类的 load 都执行万, 才能继续.</p><p><code>initialize</code>方法 只应该用来设置内部数据.</p><ul><li>在加载阶段, 如果类实现了 load 方法, 那么系统就会调用它. 分类里也可以定义此方法, 类的 load 方法要比分类中的先调用.</li><li>首次实用某个类之前, 系统会向其发送 <code>initialize</code> 消息. 由于此方法遵从普通的覆写规则, 所以通常应该在里面判断当前要初始化的是哪个类.</li><li>无法在编译期设定的全局常量, 可以放在 <code>initialize</code> 方法里初始化.</li></ul><h3 id="3-NSTimer-会保留其目标对象"><a href="#3-NSTimer-会保留其目标对象" class="headerlink" title="3. NSTimer 会保留其目标对象."></a>3. NSTimer 会保留其目标对象.</h3><p>记得 手动调用或 <code>delloc</code> 方法中调用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[_timer invalidate];</span><br><span class="line">_timer = <span class="literal">nil</span>;</span><br></pre></td></tr></table></figure><p>反复执行任务的计时器, 很容易引入保留环.</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>快速遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(for ... in ...)</span><br></pre></td></tr></table></figure></p><hr><p><br></p><p>本篇文章参考摘自 <font color="#B8860B">Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的52个有效方法</font></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第7章-熟悉系统框架&quot;&gt;&lt;a href=&quot;#第7章-熟悉系统框架&quot; class=&quot;headerlink&quot; title=&quot;第7章 熟悉系统框架&quot;&gt;&lt;/a&gt;第7章 熟悉系统框架&lt;/h2&gt;&lt;p&gt;将一系列代码封装为动态库 (dynamic library) , 并在其中放入描述其借口的头文件, 这样做出来的东西就叫 &lt;font color=&quot;a52a2a&quot;&gt;框架&lt;/font&gt; .有时为 iOS 平台构建的第三方框架实用的是静态库 (static libaray), 这是因为 iOS 应用程序不允许在其中包含动态库.&lt;/p&gt;
&lt;p&gt;开发者主要会碰到&lt;code&gt;Foundation&lt;/code&gt;, 像是 &lt;code&gt;NSOject&lt;/code&gt;, &lt;code&gt;NSArray&lt;/code&gt;, &lt;code&gt;NSDictionary&lt;/code&gt; 等类都在其中, &lt;code&gt;Foundation&lt;/code&gt; 是应用程序的 “基础”.&lt;/p&gt;
&lt;p&gt;还有个与 &lt;code&gt;Foundation&lt;/code&gt; 相伴的框架, 叫做 &lt;code&gt;CoreFoundation&lt;/code&gt; , 从技术上来将, &lt;code&gt;CoreFoundation&lt;/code&gt; 框架不是 &lt;code&gt;Objective-C&lt;/code&gt; 框架, 但它是编写 &lt;code&gt;Objective-C&lt;/code&gt; 应用程序时所应熟悉的重要框架. &lt;code&gt;Foundation&lt;/code&gt; 框架中的很多功能, 都可以在此框架中找到对应的 C 语言 API. 可以用”无缝桥接”(tollfree bridging). 可以吧 &lt;code&gt;CoreFoundation&lt;/code&gt; 中的 C 语言数据结构平滑转换为 &lt;code&gt;Foundation&lt;/code&gt;中的 Objective-C 对象.&lt;/p&gt;
&lt;p&gt;除了&lt;code&gt;Foundation&lt;/code&gt; 还有 &lt;code&gt;CFNetwork&lt;/code&gt; , &lt;code&gt;CoreAudio&lt;/code&gt;, &lt;code&gt;AVFoundation&lt;/code&gt;, &lt;code&gt;CoreData&lt;/code&gt;, &lt;code&gt;CoreText&lt;/code&gt; ….&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.lydsnm.top/categories/iOS/"/>
    
    
      <category term="OC" scheme="http://www.lydsnm.top/tags/OC/"/>
    
  </entry>
  
  <entry>
    <title>OC开发相关注意事项</title>
    <link href="http://www.lydsnm.top/2016/10/19/OC%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%89/"/>
    <id>http://www.lydsnm.top/2016/10/19/OC开发相关注意事项三/</id>
    <published>2016-10-18T16:00:00.000Z</published>
    <updated>2018-08-30T14:37:42.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>ARC :<code>Automatic Reference Counting,ARC</code>, ARC 几乎把所有内存管理事宜都交由编译器来决定, 开发者只需专注于业务逻辑.</p><h3 id="1-引用计数"><a href="#1-引用计数" class="headerlink" title="1. 引用计数"></a>1. 引用计数</h3><p>Objective-C 语言实用引用计数来管理内存. 每个对象都有个可以递增和递减的计数器, 用以标识当前有多个事情想令此对象继续存活下去.<br>计数<font color="#A52A2a">>=0</font>表示对象继续存活. 当保留计数降为<font color="#A52A2a"> 0 </font>后, 对象就会被释放了.</p><p>ARC 只负责管理 <code>Objective-C</code> 对象的内存. 注意: <font color="#A52A2a">CoreFoundation</font>对象不归 ARC 管理, 开发者必须适时调用 <font color="#A52A2a">CFRetain/CFRelease</font>.</p><h3 id="2-在-dealloc-方法中只释放引用并解除监听"><a href="#2-在-dealloc-方法中只释放引用并解除监听" class="headerlink" title="2. 在 dealloc 方法中只释放引用并解除监听"></a>2. 在 dealloc 方法中只释放引用并解除监听</h3><p>对象在经历其生命周期后, 最终会为系统所回收, 这时就要执行 <code>dealloc</code> 方法了. 在每个对象的生命周期内, 此方法仅执行以此. 也就是但保留计数降为 0 的时候.</p><p>虽说应该于 <code>dealloc</code> 中释放引用, 但是开销较大或系统内稀缺的资源则不在此列 ,像是文件描述符( file descriptor ), 套接字 (socket), 大块内存等都属于这种资源. 不能指望 <code>dealloc</code> 方法必定会在某个特定的时机调用, 因为有一些无法预料的东西可能也会持有此对象. 在这种情况下, 如果非要等到系统调用 <code>dealloc</code> 方法时才释放, 那么保留这些稀缺资源的时间就太长了, 这么做不合适. 通常的做法时, 实现另外一个方法, 但应用程序用完资源对象后, 就调用此方法 (例如 <font color="#A52A2a">Open</font> 对应 <font color="#A52A2a">Close</font> 方法) . 这样一来, 资源对象的生命期就变得更明确了.</p><a id="more"></a><h3 id="3-以-“自动释放池块”-降低内存峰值"><a href="#3-以-“自动释放池块”-降低内存峰值" class="headerlink" title="3. 以 “自动释放池块” 降低内存峰值"></a>3. 以 “自动释放池块” 降低内存峰值</h3><p>在 Objective-C 的引用计数架构中, 有一项特性叫做 “<font color="#A52A2a">自动释放池</font>“ (autorelease pool). 释放对象有两种方式: 一种时调用 <code>release</code> 方法, 另一种时调用 <code>autorelease</code> 方法, 将其降入 “自动释放池” 中. 自动释放池用于存放那些需要在稍后某个时刻释放的对象. 清空(drain)自动释放池时, 系统会向其中的对象发送 <code>release</code> 消息.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)&#123;</span><br><span class="line">[<span class="keyword">self</span> doSomethingWithInt:i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <font color="#A52A2a">自动释放池</font> 来降低应用程序的 <font color="#A52A2a">峰值内存</font>.</p><p><br></p><hr><h2 id="block与GCD"><a href="#block与GCD" class="headerlink" title="block与GCD"></a>block与GCD</h2><p>GCD 是一种与块有关的计数, 它提供了对线程的抽象, 而这种抽象则机遇 “派发队列”(<code>dispatch queue</code>). 开发者可将块排入队列中, 由 GCD 负责处理所有调度事宜.</p><h3 id="1-block"><a href="#1-block" class="headerlink" title="1. block"></a>1. block</h3><p>每个 Objective-C 对象都占据着某个内存区域. 因为实例变量的个数及对象所包含的关联数据不同, 所以每个对象所占的内存区域也有大有小. 块对象也是对象, 在存放块对象的内存区域中, 首个变量时指向 Class 对象的指针, 该指针叫做 <font color="A52A2A">isa</font> .其余内存里含有块对象正常运转所需的各种信息.</p><p><img src="http://ocs32tleq.bkt.clouddn.com/blockMemory.png" alt="块对象的内存布局"></p><p>在内存布局中, 最重要的时 <font color="a52a2a">invoke</font> 变量, 这是个函数指针, 指向块的实现代码. 块其实就是一种代替函数指针的语法结构.</p><p>定义块的时候, 其所占的内存是分配在 <font color="a52a2a">栈 </font>中的. 块只在定义它的那个范围有效. 编译器有可能把分配给块的内存覆写掉. 给 block 对象发送 copy 消息拷贝, 就拷贝到堆上, 块就成了带引用计数的对象了.后续的复制操作都不会真的执行复制, 只是增加对象的引用计数.</p><h3 id="2-GCD"><a href="#2-GCD" class="headerlink" title="2. GCD"></a>2. GCD</h3><p>少用 <code>performSelector</code> 系列方法, 用 GCD 相关方法来实现.</p><ul><li>通过 <code>Dispatch Group</code> 机制, 根据系统资源状况来执行任务.一系列任务可关于一个 <code>dispatch group</code> 中. 开发者可以再这组任务执行完毕时获得通知.</li></ul><p>使用下面这个函数可以创建 <code>dispatch group</code>:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_tdispatch_group_create();</span><br></pre></td></tr></table></figure><p>另外可选 使用 <code>dispatch_apply</code> 方法, 此函数会将块仿佛执行一定的次数, 每次传给块的参数值都会递增..</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIRITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">dispatch_apply(array.count, queue, ^(size_t i)&#123;</span><br><span class="line"><span class="keyword">id</span> object = array[i];</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而, <code>dispatch_apply</code> 会持续阻塞队列, 直到所有任务都执行完毕为止. 若想到后台执行任务, 则应使用 <code>dispatch group</code></p><p>更多内容请看我的另外一篇 : <a href="http://www.donglyu.com/2016/02/08/GCD处理多个异步处理的同步方法/" target="_blank" rel="noopener">GCD 多任务</a></p><ul><li>使用 <code>dispatch_once</code> 来执行只需运行以此的线程安全代码.<br>单例模式中使用的多.</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)sharedInstance&#123;</span><br><span class="line"><span class="keyword">static</span> EOCClass *sharedInstance = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">shareInstance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li>调试内存管理问题时, 可以将 <font color="#A52A2a">NSZombieEnabled</font> 环境变量设为 YES . 给僵尸对象(应该是是否的对象, 不应再被调用) 发送消息, 控制台会打印消息, 应用程序会终止.</li></ul><hr><p><br></p><p>本篇文章参考摘自 <font color="#B8860B">Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的52个有效方法</font></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理&quot;&gt;&lt;a href=&quot;#内存管理&quot; class=&quot;headerlink&quot; title=&quot;内存管理&quot;&gt;&lt;/a&gt;内存管理&lt;/h2&gt;&lt;p&gt;ARC :&lt;code&gt;Automatic Reference Counting,ARC&lt;/code&gt;, ARC 几乎把所有内存管理事宜都交由编译器来决定, 开发者只需专注于业务逻辑.&lt;/p&gt;
&lt;h3 id=&quot;1-引用计数&quot;&gt;&lt;a href=&quot;#1-引用计数&quot; class=&quot;headerlink&quot; title=&quot;1. 引用计数&quot;&gt;&lt;/a&gt;1. 引用计数&lt;/h3&gt;&lt;p&gt;Objective-C 语言实用引用计数来管理内存. 每个对象都有个可以递增和递减的计数器, 用以标识当前有多个事情想令此对象继续存活下去.&lt;br&gt;计数&lt;font color=&quot;#A52A2a&quot;&gt;&gt;=0&lt;/font&gt;表示对象继续存活. 当保留计数降为&lt;font color=&quot;#A52A2a&quot;&gt; 0 &lt;/font&gt;后, 对象就会被释放了.&lt;/p&gt;
&lt;p&gt;ARC 只负责管理 &lt;code&gt;Objective-C&lt;/code&gt; 对象的内存. 注意: &lt;font color=&quot;#A52A2a&quot;&gt;CoreFoundation&lt;/font&gt;对象不归 ARC 管理, 开发者必须适时调用 &lt;font color=&quot;#A52A2a&quot;&gt;CFRetain/CFRelease&lt;/font&gt;.&lt;/p&gt;
&lt;h3 id=&quot;2-在-dealloc-方法中只释放引用并解除监听&quot;&gt;&lt;a href=&quot;#2-在-dealloc-方法中只释放引用并解除监听&quot; class=&quot;headerlink&quot; title=&quot;2. 在 dealloc 方法中只释放引用并解除监听&quot;&gt;&lt;/a&gt;2. 在 dealloc 方法中只释放引用并解除监听&lt;/h3&gt;&lt;p&gt;对象在经历其生命周期后, 最终会为系统所回收, 这时就要执行 &lt;code&gt;dealloc&lt;/code&gt; 方法了. 在每个对象的生命周期内, 此方法仅执行以此. 也就是但保留计数降为 0 的时候.&lt;/p&gt;
&lt;p&gt;虽说应该于 &lt;code&gt;dealloc&lt;/code&gt; 中释放引用, 但是开销较大或系统内稀缺的资源则不在此列 ,像是文件描述符( file descriptor ), 套接字 (socket), 大块内存等都属于这种资源. 不能指望 &lt;code&gt;dealloc&lt;/code&gt; 方法必定会在某个特定的时机调用, 因为有一些无法预料的东西可能也会持有此对象. 在这种情况下, 如果非要等到系统调用 &lt;code&gt;dealloc&lt;/code&gt; 方法时才释放, 那么保留这些稀缺资源的时间就太长了, 这么做不合适. 通常的做法时, 实现另外一个方法, 但应用程序用完资源对象后, 就调用此方法 (例如 &lt;font color=&quot;#A52A2a&quot;&gt;Open&lt;/font&gt; 对应 &lt;font color=&quot;#A52A2a&quot;&gt;Close&lt;/font&gt; 方法) . 这样一来, 资源对象的生命期就变得更明确了.&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.lydsnm.top/categories/iOS/"/>
    
    
      <category term="OC" scheme="http://www.lydsnm.top/tags/OC/"/>
    
  </entry>
  
  <entry>
    <title>本地推送之定时推送</title>
    <link href="http://www.lydsnm.top/2016/10/18/%E6%9C%AC%E5%9C%B0%E6%8E%A8%E9%80%81%E4%B9%8B%E5%AE%9A%E6%97%B6%E6%8E%A8%E9%80%81/"/>
    <id>http://www.lydsnm.top/2016/10/18/本地推送之定时推送/</id>
    <published>2016-10-17T16:00:00.000Z</published>
    <updated>2018-03-04T05:52:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>项目中使用到了定时提醒推送, 故整理记录下来.</p><h2 id="iOS10-之前-使用旧的本地推送注册方式"><a href="#iOS10-之前-使用旧的本地推送注册方式" class="headerlink" title="iOS10 之前, 使用旧的本地推送注册方式:"></a>iOS10 之前, 使用旧的本地推送注册方式:</h2><h3 id="1-在-AppDelegate中代理注册使用通知-和注册远程通知一致"><a href="#1-在-AppDelegate中代理注册使用通知-和注册远程通知一致" class="headerlink" title="1. 在 AppDelegate中代理注册使用通知, 和注册远程通知一致"></a>1. 在 <code>AppDelegate</code>中代理注册使用通知, 和注册远程通知一致</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIMutableUserNotificationCategory</span> *categorys = [[<span class="built_in">UIMutableUserNotificationCategory</span> alloc] init];</span><br><span class="line"><span class="built_in">UIUserNotificationSettings</span> *userSettings = [<span class="built_in">UIUserNotificationSettings</span> settingsForTypes:<span class="built_in">UIUserNotificationTypeBadge</span>|<span class="built_in">UIUserNotificationTypeSound</span>|<span class="built_in">UIUserNotificationTypeAlert</span></span><br><span class="line">                                                                                    categories:[<span class="built_in">NSSet</span> setWithObject:categorys]];</span><br><span class="line">[[<span class="built_in">UIApplication</span> sharedApplication] registerUserNotificationSettings:userSettings];</span><br><span class="line">[[<span class="built_in">UIApplication</span> sharedApplication] registerForRemoteNotifications];</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-注册本地推送-在固定时间推送通知"><a href="#2-注册本地推送-在固定时间推送通知" class="headerlink" title="2. 注册本地推送,在固定时间推送通知"></a>2. 注册本地推送,在固定时间推送通知</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)RegisterLocalNotificationiOS10Before:(<span class="built_in">NSDate</span> *)time&#123;</span><br><span class="line">    <span class="built_in">UILocalNotification</span> *notification = [[<span class="built_in">UILocalNotification</span> alloc] init];</span><br><span class="line">    <span class="comment">// 设置触发通知的时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    NSDate *fireDate = [NSDate dateWithTimeIntervalSinceNow:10];</span></span><br><span class="line">    notification.fireDate = time; <span class="comment">// fireDate</span></span><br><span class="line">    <span class="comment">// 时区</span></span><br><span class="line">    notification.timeZone = [<span class="built_in">NSTimeZone</span> defaultTimeZone];</span><br><span class="line">    <span class="comment">// 设置重复的间隔</span></span><br><span class="line">    notification.repeatInterval = kCFCalendarUnitDay; <span class="comment">// 每天提醒.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知内容</span></span><br><span class="line">    notification.alertTitle = <span class="string">@"时光匆匆，我只在乎你"</span>;</span><br><span class="line">    notification.alertBody = <span class="string">@"今天有什么想要记录和分享吗？"</span>; </span><br><span class="line">    notification.applicationIconBadgeNumber = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 通知被触发时播放的声音</span></span><br><span class="line">    notification.soundName = <span class="built_in">UILocalNotificationDefaultSoundName</span>;</span><br><span class="line">    <span class="comment">// 通知参数</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *userDict = [<span class="built_in">NSDictionary</span> dictionaryWithObject:LPVMNoticeEveryDayKey forKey:LPVMNoticeEveryDayKey];</span><br><span class="line">    notification.userInfo = userDict;</span><br><span class="line">    </span><br><span class="line">    notification.repeatInterval = <span class="built_in">NSCalendarUnitDay</span>;</span><br><span class="line">    <span class="comment">// 执行通知注册</span></span><br><span class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] scheduleLocalNotification:notification];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-取消本地推送"><a href="#3-取消本地推送" class="headerlink" title="3. 取消本地推送"></a>3. 取消本地推送</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)CancelLocalNotificationWithKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="comment">// 获取所有本地通知数组</span></span><br><span class="line">    <span class="built_in">NSArray</span> *localNotifications = [<span class="built_in">UIApplication</span> sharedApplication].scheduledLocalNotifications;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UILocalNotification</span> *notification <span class="keyword">in</span> localNotifications) &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span> *userInfo = notification.userInfo;        </span><br><span class="line">        <span class="keyword">if</span> (userInfo) &#123;</span><br><span class="line">            <span class="comment">// 根据设置通知参数时指定的key来获取通知参数</span></span><br><span class="line">            <span class="built_in">NSString</span> *info = userInfo[key];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果找到需要取消的通知，则取消</span></span><br><span class="line">            <span class="keyword">if</span> (info != <span class="literal">nil</span>) &#123;</span><br><span class="line">                [[<span class="built_in">UIApplication</span> sharedApplication] cancelLocalNotification:notification];</span><br><span class="line">                DLog(<span class="string">@"移除一条注册了的本地推送"</span>);   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="iOS-10后本地定时推送"><a href="#iOS-10后本地定时推送" class="headerlink" title="iOS 10后本地定时推送"></a>iOS 10后本地定时推送</h2><h3 id="1-注册推送"><a href="#1-注册推送" class="headerlink" title="1. 注册推送"></a>1. 注册推送</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)RegisterLocalNotificationiOS10Later:(<span class="built_in">NSDate</span> *)time&#123;</span><br><span class="line">    <span class="comment">// 使用 UNUserNotificationCenter 来管理通知</span></span><br><span class="line">    UNUserNotificationCenter* center = [UNUserNotificationCenter currentNotificationCenter];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//需创建一个包含待通知内容的 UNMutableNotificationContent 对象，注意不是 UNNotificationContent ,此对象为不可变对象。</span></span><br><span class="line">    UNMutableNotificationContent* content = [[UNMutableNotificationContent alloc] init];</span><br><span class="line">    content.title = [<span class="built_in">NSString</span> localizedUserNotificationStringForKey:<span class="string">@"时光匆匆，我只在乎你"</span> arguments:<span class="literal">nil</span>];</span><br><span class="line">    content.body = [<span class="built_in">NSString</span> localizedUserNotificationStringForKey:<span class="string">@"今天有什么想要记录和分享吗？"</span> arguments:<span class="literal">nil</span>];</span><br><span class="line">    content.sound = [UNNotificationSound defaultSound];</span><br><span class="line">    content.userInfo = [<span class="built_in">NSDictionary</span> dictionaryWithObject:LPVMNoticeEveryDayKey forKey:LPVMNoticeEveryDayKey];</span><br><span class="line">    <span class="comment">// 1.在一段时间后推送本地推送</span></span><br><span class="line"><span class="comment">//UNTimeIntervalNotificationTrigger* trigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:10 repeats:NO];</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSDateComponents</span> *components = [[<span class="built_in">NSDateComponents</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSCalendar</span> *cal = [<span class="built_in">NSCalendar</span> currentCalendar];</span><br><span class="line">    <span class="built_in">NSInteger</span> unitFlags = <span class="built_in">NSCalendarUnitHour</span> | <span class="built_in">NSCalendarUnitMinute</span>;<span class="comment">//NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit;</span></span><br><span class="line">    <span class="built_in">NSDateComponents</span> *dd = [cal components:unitFlags fromDate:time];</span><br><span class="line"></span><br><span class="line">    components.hour = [dd hour];</span><br><span class="line">    components.minute = [dd minute]; <span class="comment">// 例如每日21:00时推送</span></span><br><span class="line">    <span class="comment">// 2. 指定日期触发</span></span><br><span class="line">    UNCalendarNotificationTrigger *trigger = [UNCalendarNotificationTrigger triggerWithDateMatchingComponents:components repeats:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 根据位置触发</span></span><br><span class="line"><span class="comment">//CLLocationCoordinate2D cen = CLLocationCoordinate2DMake(39.990465,116.333386);</span></span><br><span class="line"><span class="comment">//CLRegion *region = [[CLCircularRegion alloc] initWithCenter:cen radius:100 identifier:@"center"];</span></span><br><span class="line"><span class="comment">//region.notifyOnEntry = YES;</span></span><br><span class="line"><span class="comment">//region.notifyOnExit = NO;</span></span><br><span class="line"><span class="comment">//UNLocationNotificationTrigger *trigger = [UNLocationNotificationTrigger triggerWithRegion:region repeats:YES];</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    UNNotificationRequest* request = [UNNotificationRequest requestWithIdentifier:LPVMNoticeEveryDayKey</span><br><span class="line">                                                                          content:content trigger:trigger];</span><br><span class="line">    <span class="comment">//添加推送成功后的处理！</span></span><br><span class="line">    [center addNotificationRequest:request withCompletionHandler:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            DLog(<span class="string">@"iOS10Later addNotification Error: %@"</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明:<br>有4种触发器</p><p><code>UNPushNotificationTrigger</code> 触发APNS服务，系统自动设置（这是区分本地通知和远程通知的标识)</p><p><code>UNTimeIntervalNotificationTrigger</code> 一段时间后触发</p><p><code>UNCalendarNotificationTrigger</code> 指定日期触发</p><p><code>UNLocationNotificationTrigger</code> 根据位置触发，支持进入某地或者离开某地或者都有</p><h3 id="2-iOS10Later取消推送"><a href="#2-iOS10Later取消推送" class="headerlink" title="2. iOS10Later取消推送"></a>2. iOS10Later取消推送</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UNUserNotificationCenter* center = [UNUserNotificationCenter currentNotificationCenter];</span><br><span class="line">       [center removeAllPendingNotificationRequests];  <span class="comment">// remove all at this moment.</span></span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>本地推送的回调, 会调用 <code>AppDeleage</code> 下的<code>application:(UIApplication *)application didReceiveLocalNotification</code>方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveLocalNotification:(<span class="built_in">UILocalNotification</span> *)notification&#123;</span><br><span class="line">  <span class="comment">// TO DO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目中使用到了定时提醒推送, 故整理记录下来.&lt;/p&gt;
&lt;h2 id=&quot;iOS10-之前-使用旧的本地推送注册方式&quot;&gt;&lt;a href=&quot;#iOS10-之前-使用旧的本地推送注册方式&quot; class=&quot;headerlink&quot; title=&quot;iOS10 之前, 使用旧的本地推送注册方式:&quot;&gt;&lt;/a&gt;iOS10 之前, 使用旧的本地推送注册方式:&lt;/h2&gt;&lt;h3 id=&quot;1-在-AppDelegate中代理注册使用通知-和注册远程通知一致&quot;&gt;&lt;a href=&quot;#1-在-AppDelegate中代理注册使用通知-和注册远程通知一致&quot; class=&quot;headerlink&quot; title=&quot;1. 在 AppDelegate中代理注册使用通知, 和注册远程通知一致&quot;&gt;&lt;/a&gt;1. 在 &lt;code&gt;AppDelegate&lt;/code&gt;中代理注册使用通知, 和注册远程通知一致&lt;/h3&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UIMutableUserNotificationCategory&lt;/span&gt; *categorys = [[&lt;span class=&quot;built_in&quot;&gt;UIMutableUserNotificationCategory&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UIUserNotificationSettings&lt;/span&gt; *userSettings = [&lt;span class=&quot;built_in&quot;&gt;UIUserNotificationSettings&lt;/span&gt; settingsForTypes:&lt;span class=&quot;built_in&quot;&gt;UIUserNotificationTypeBadge&lt;/span&gt;|&lt;span class=&quot;built_in&quot;&gt;UIUserNotificationTypeSound&lt;/span&gt;|&lt;span class=&quot;built_in&quot;&gt;UIUserNotificationTypeAlert&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                                                    categories:[&lt;span class=&quot;built_in&quot;&gt;NSSet&lt;/span&gt; setWithObject:categorys]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[&lt;span class=&quot;built_in&quot;&gt;UIApplication&lt;/span&gt; sharedApplication] registerUserNotificationSettings:userSettings];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[&lt;span class=&quot;built_in&quot;&gt;UIApplication&lt;/span&gt; sharedApplication] registerForRemoteNotifications];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.lydsnm.top/categories/iOS/"/>
    
    
      <category term="推送" scheme="http://www.lydsnm.top/tags/%E6%8E%A8%E9%80%81/"/>
    
  </entry>
  
  <entry>
    <title>简单明了搞定 iOS 10推送适配</title>
    <link href="http://www.lydsnm.top/2016/10/08/%E7%AE%80%E5%8D%95%E6%98%8E%E4%BA%86%E6%90%9E%E5%AE%9AiOS10%E6%8E%A8%E9%80%81%E9%80%82%E9%85%8D/"/>
    <id>http://www.lydsnm.top/2016/10/08/简单明了搞定iOS10推送适配/</id>
    <published>2016-10-07T16:00:00.000Z</published>
    <updated>2018-03-04T05:50:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 10 更新了后发现正式环境, 推送粗问题了.查了相关资料后, 整理了一下解决办法。 iOS 10后, 增加了<font color="#1E90FF">UNUserNotificationCenter</font>, 并且推送通知的处理要在代理方法</p><ul><li><p><font color="#A52A2A">userNotificationCenter:didReceiveNotificationResponse</font> 推送时 APP 在后台</p></li><li><p><font color="#A52A2A">userNotificationCenter:willPresentNotification</font> 推送时 APP 在前台</p></li></ul><a id="more"></a><p><br></p><h4 id="1-导入头文件"><a href="#1-导入头文件" class="headerlink" title="1. 导入头文件"></a>1. 导入头文件</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UserNotifications/UserNotifications.h&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="2-遵守协议"><a href="#2-遵守协议" class="headerlink" title="2. 遵守协议"></a>2. 遵守协议</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> ()&lt;<span class="title">UNUserNotificationCenterDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="3-在application-didFinishLaunchingWithOptions方法中注册推送。"><a href="#3-在application-didFinishLaunchingWithOptions方法中注册推送。" class="headerlink" title="3. 在application: didFinishLaunchingWithOptions方法中注册推送。"></a>3. 在<font color="#1E90FF">application: didFinishLaunchingWithOptions</font>方法中注册推送。</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kiOS10Later) &#123;  <span class="comment">//iOS10 之后用UNUserNotificationCenter注册通知</span></span><br><span class="line">        UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];</span><br><span class="line">        center.delegate = <span class="keyword">self</span>;</span><br><span class="line">        [center requestAuthorizationWithOptions:(UNAuthorizationOptionBadge | UNAuthorizationOptionSound | UNAuthorizationOptionAlert) completionHandler:^(<span class="built_in">BOOL</span> granted, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">                [[<span class="built_in">UIApplication</span> sharedApplication] registerForRemoteNotifications];</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"OK!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//iOS10 之前的注册通知</span></span><br><span class="line">        <span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication] respondsToSelector:<span class="keyword">@selector</span>(registerUserNotificationSettings:)]) &#123;</span><br><span class="line">        <span class="built_in">UIUserNotificationSettings</span> *settings = [<span class="built_in">UIUserNotificationSettings</span> settingsForTypes:(<span class="built_in">UIUserNotificationTypeBadge</span> |<span class="built_in">UIUserNotificationTypeSound</span> |<span class="built_in">UIUserNotificationTypeAlert</span>)</span><br><span class="line">                                                                                 categories:<span class="literal">nil</span>];</span><br><span class="line">        [[<span class="built_in">UIApplication</span> sharedApplication] registerUserNotificationSettings:settings];</span><br><span class="line">        [[<span class="built_in">UIApplication</span> sharedApplication] registerForRemoteNotifications];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4-APP-未启动-iOS10中遗弃UIApplicationLaunchOptionsRemoteNotificationKey-采用统一的方式来处理-见下一条"><a href="#4-APP-未启动-iOS10中遗弃UIApplicationLaunchOptionsRemoteNotificationKey-采用统一的方式来处理-见下一条" class="headerlink" title="4. APP 未启动, iOS10中遗弃UIApplicationLaunchOptionsRemoteNotificationKey,采用统一的方式来处理, 见下一条."></a>4. APP 未启动, iOS10中遗弃<font color="#1E90FF">UIApplicationLaunchOptionsRemoteNotificationKey</font>,采用统一的方式来处理, 见下一条.</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// application: didFinishLaunchingWithOptions 中 iOS 9及以下,还是要保留以下代码</span></span><br><span class="line"> <span class="built_in">NSDictionary</span> *remoteUserInfo = launchOptions[<span class="built_in">UIApplicationLaunchOptionsRemoteNotificationKey</span>];  </span><br><span class="line">    <span class="keyword">if</span> (remoteUserInfo) &#123;  </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"remoteUserInfo:%@"</span>,remoteUserInfo);  </span><br><span class="line">        <span class="comment">//APP未启动，点击推送消息，iOS10下还是跟以前一样在此获取  </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="5-实现接收推送消息的回调方法"><a href="#5-实现接收推送消息的回调方法" class="headerlink" title="5. 实现接收推送消息的回调方法"></a>5. 实现接收推送消息的回调方法</h4><p>iOS10之前使用<font color="#1E90FF">application: didReceiveRemoteNotification</font> 来进行回调处理，而在iOS10里则要实现用<font color="1E90FF">UNUserNotificationCenterDelegate</font>的两个代理方法： </p><blockquote><ul><li><font color="#A52A2A">userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification</font></li><li><font color="#A52A2A">userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse</font></li></ul></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iOS10之前 接收推送消息</span></span><br><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveRemoteNotification:(<span class="built_in">NSDictionary</span> *)userInfo fetchCompletionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">UIBackgroundFetchResult</span>))completionHandler &#123;</span><br><span class="line">    Log(<span class="string">@"userInfo: %@"</span>, userInfo);</span><br><span class="line">    <span class="keyword">if</span> ( application.applicationState == <span class="built_in">UIApplicationStateActive</span>) &#123;<span class="comment">// 程序在运行过程中受到推送通知</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//在background状态受到推送通知</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    completionHandler(<span class="built_in">UIBackgroundFetchResultNewData</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iOS 10之后 后台推送消息接收</span></span><br><span class="line">- (<span class="keyword">void</span>)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(<span class="keyword">void</span> (^)())completionHandler&#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *userInfo = response.notification.request.content.userInfo;</span><br><span class="line">    <span class="comment">// TO DO</span></span><br><span class="line">    </span><br><span class="line">    completionHandler(<span class="built_in">UIBackgroundFetchResultNewData</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iOS 10之后 前台推送消息处理.</span></span><br><span class="line">- (<span class="keyword">void</span>)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(<span class="keyword">nonnull</span> UNNotification *)notification withCompletionHandler:(<span class="keyword">nonnull</span> <span class="keyword">void</span> (^)(UNNotificationPresentationOptions))completionHandler&#123;</span><br><span class="line">    DLog(<span class="string">@"iOS 10 Receive Remote Notification in foreground! [willPresentNotification]"</span>);</span><br><span class="line">    <span class="comment">// 可在APP 前台状态下,弹出推送弹窗</span></span><br><span class="line">    completionHandler(UNNotificationPresentationOptionAlert);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-而对于本地推送回调-和以前没有变化"><a href="#6-而对于本地推送回调-和以前没有变化" class="headerlink" title="6. 而对于本地推送回调, 和以前没有变化:"></a>6. 而对于本地推送回调, 和以前没有变化:</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveLocalNotification:(<span class="built_in">UILocalNotification</span> *)notification&#123;</span><br><span class="line">  <span class="comment">// TO DO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="7-其他补充"><a href="#7-其他补充" class="headerlink" title="7. 其他补充"></a>7. 其他补充</h4><ul><li>对于<font color="#1E90FF">Xcode 8</font>, 默认生成的<font color="#1E90FF">XXX.entitlements</font>中的<font color="#1E90FF">APS Enviroment</font> 发布时,可以不用从development 改成 production. Xcode 在发布时会自动帮我们处理改好.</li></ul><ul><li>推送开关记得要打开;capabilities 里面<font color="#1E90FF">Background Modes–&gt;remote notification&amp;push notification</font></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 10 更新了后发现正式环境, 推送粗问题了.查了相关资料后, 整理了一下解决办法。 iOS 10后, 增加了&lt;font color=&quot;#1E90FF&quot;&gt;UNUserNotificationCenter&lt;/font&gt;, 并且推送通知的处理要在代理方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;font color=&quot;#A52A2A&quot;&gt;userNotificationCenter:didReceiveNotificationResponse&lt;/font&gt; 推送时 APP 在后台&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;font color=&quot;#A52A2A&quot;&gt;userNotificationCenter:willPresentNotification&lt;/font&gt; 推送时 APP 在前台&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.lydsnm.top/categories/iOS/"/>
    
    
      <category term="iOS10适配" scheme="http://www.lydsnm.top/tags/iOS10%E9%80%82%E9%85%8D/"/>
    
      <category term="推送" scheme="http://www.lydsnm.top/tags/%E6%8E%A8%E9%80%81/"/>
    
  </entry>
  
  <entry>
    <title>OC开发相关注意事项</title>
    <link href="http://www.lydsnm.top/2016/09/20/OC%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%BA%8C/"/>
    <id>http://www.lydsnm.top/2016/09/20/OC开发相关注意事项二/</id>
    <published>2016-09-19T16:00:00.000Z</published>
    <updated>2018-08-30T14:37:42.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="接口与-API-设计"><a href="#接口与-API-设计" class="headerlink" title="接口与 API 设计"></a>接口与 API 设计</h2><p>我们在构建应用程序编写接口应考虑将其设计成易于复用的形式, 方便后续项目复用或其他模块使用. 这就需要遵守一定的编程范式, 遵守一些约定俗成的”规则”.</p><h3 id="1-用前缀避免命名空间冲突"><a href="#1-用前缀避免命名空间冲突" class="headerlink" title="1. 用前缀避免命名空间冲突"></a>1. 用前缀避免命名空间冲突</h3><p>OC 没有其他语言内置的命名空间机制. 因此在命名时设法避免潜在的命名冲突, 否则容易就重名.否则会出现类似错误:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">duplicate symbol _OBJC_METACLASS_$_EOCTHECLASS <span class="keyword">in</span>:</span><br><span class="line">build/something.o</span><br><span class="line">build/something_else.o</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>苹果宣称其保留使用所有”两字母前缀”(two-letter prefix)的权利,因此我们的命名前缀最好避免使用两个字母当前缀.</p><a id="more"></a><hr><h3 id="2-提供”全能初始方法”"><a href="#2-提供”全能初始方法”" class="headerlink" title="2. 提供”全能初始方法”"></a>2. 提供”全能初始方法”</h3><ul><li>在类中提供一个全能初始化方法, 并于文档中指名. 其他初始化方法均应调用此方法.</li><li>若全能初始化方法与超类不同, 则需要覆写超类中的对应方法.</li><li>如果超类的初始化方法不适用于之类, 那么应该覆写这个超类方法, 并在其中抛出异常.</li></ul><hr><h3 id="3-实现-description-方法"><a href="#3-实现-description-方法" class="headerlink" title="3. 实现 description 方法"></a>3. 实现 description 方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;object = %@&quot;, object);</span><br></pre></td></tr></table></figure><p>实现 object 的 description 方法, 打印 object 中用户关心的信息.</p><ul><li>若想在调试时打印更详尽的对象描述信息, 则应实现 debugDescription 方法.</li></ul><hr><h3 id="4-尽量使用不可变对象"><a href="#4-尽量使用不可变对象" class="headerlink" title="4. 尽量使用不可变对象"></a>4. 尽量使用不可变对象</h3><p>若属性仅可以用于对象内部修改, 则在”class-continuation 分类”中将其由<code>readonly</code>属性扩展为 readwirte.<br>不要把可变的 <code>collection</code>作为属性公开, 而应时提供相关方法, 以此修改对象中的可变 <code>collection</code>.</p><hr><h3 id="5-命名方式"><a href="#5-命名方式" class="headerlink" title="5.命名方式"></a>5.命名方式</h3><p>用<code>p_</code>开头来命名私有方法. 而苹果公司用的是拿一个下划线作为前缀, 而我们最好不要用, 不然可能因为<font color="#A52A2A">动态方法派发系统(dynamic method dispatch system)</font>可能在子类中无意覆盖了方法.</p><h3 id="6-NSCopying协议"><a href="#6-NSCopying协议" class="headerlink" title="6. NSCopying协议"></a>6. NSCopying协议</h3><p>要想让自定义类支持拷贝操作, 就需要实现<font color="#A52A2A"> NSCopying</font>协议, 该协议只有一个方法:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span>*)zone</span><br></pre></td></tr></table></figure><p>为何会出现 <code>NSZone</code> 呢? 因为以前开发程序时, 会据此把内存分成不同的”区”(<code>zone</code>), 而对象会创建在某个区里面, 而现在不用了, 每个程序只有一个<code>default zone</code></p><p>对于不可变的 <code>NSArray</code> 与可变的 <code>NSMutableArray</code> 来说, 下列关系总是成立的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (NSMutableArray copy] =&gt; NSArray</span><br><span class="line">- (NSArray mutableCopy] =&gt; NSMutableArray</span><br></pre></td></tr></table></figure><p>另外, 在可变对象上调用 <code>copy</code> 方法则是会返回另外一个不可变类的实例.</p><p><br></p><hr><h2 id="协议与分类"><a href="#协议与分类" class="headerlink" title="协议与分类"></a>协议与分类</h2><p>OC 不支持多重继承, 因而我们把某个类应该实现的一系列方法定义在协议里面. 协议最为常见的用途时实现委托模式.</p><h3 id="1-委托"><a href="#1-委托" class="headerlink" title="1. 委托"></a>1. 委托</h3><p>对于需要频繁通过数据源协议从数据源中获取多份相互独立的数据, 下面的这种优化方式, 值得使用.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCNetworkFetcher</span>()</span>&#123;</span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> didReceiveData: <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> didFailWithError: <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> didUpdateProgressTo : <span class="number">1</span>;</span><br><span class="line">&#125; _delegateFlags;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set Flag</span></span><br><span class="line">_delegateFlags.didReceiveData = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setDelegate:(<span class="keyword">id</span>&lt;EOCNetworkFetcher&gt;)delegate&#123;</span><br><span class="line">_delegate = delegate;</span><br><span class="line">_delegateFlags.didReceiveData = [delegate respondsToSelector:<span class="keyword">@selector</span>(networkFetcher:didReceiveData:)];</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就不用, 每次都去检测委托对象是否能响应给定的选择子了.</p><hr><h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h3><p>当类的实现文件过于膨胀而无法管理时, 将类分类, 提取到分别的不同的文件中区.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XXX+Friendship(.h/.m)</span><br><span class="line">XXX+Work(.h/.m)</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>另外可以创建名为<code>Private</code>的分类.一般这个类中的方法只在类或框架内部使用.以隐藏实现细节.</p><hr><h3 id="3-通过协议提供匿名对象"><a href="#3-通过协议提供匿名对象" class="headerlink" title="3. 通过协议提供匿名对象"></a>3. 通过协议提供匿名对象</h3><p>委托就使用的了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, weak) id &lt;EOCDelegate&gt; delegate;</span><br></pre></td></tr></table></figure><p>该属性的类型是<code>id&lt;EOCDelegate&gt;</code>, 所以实际上任何类的对象都能充当这一属性, 即便该类不继承自 <code>NSObject</code>, 只要遵循 <font color="#A52A2A">EOCDelegate</font> 就可以了</p><p><br></p><hr><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ol><li><p>OC 中无法将某个类标识为<font color="#A52A2A">抽象类</font>. 要想达成类似效果, 最好的方法时在那些子类必须覆写的超类方法中抛出异常.</p></li><li><p>遵循使用属性的 <code>setter</code> 方法，或通过 <code>key-path</code> 来设置：<br><code>[target setAge:30];</code> <code>[target setValue:[NSNumber numberWithInt:30] forKey:@&quot;age&quot;];</code> <font color="#A52A2A">KVO</font> 键值观察才能正确获得变化.</p></li></ol><hr><p><br></p><p>本篇文章参考摘自 <font color="#B8860B">Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的52个有效方法</font></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;接口与-API-设计&quot;&gt;&lt;a href=&quot;#接口与-API-设计&quot; class=&quot;headerlink&quot; title=&quot;接口与 API 设计&quot;&gt;&lt;/a&gt;接口与 API 设计&lt;/h2&gt;&lt;p&gt;我们在构建应用程序编写接口应考虑将其设计成易于复用的形式, 方便后续项目复用或其他模块使用. 这就需要遵守一定的编程范式, 遵守一些约定俗成的”规则”.&lt;/p&gt;
&lt;h3 id=&quot;1-用前缀避免命名空间冲突&quot;&gt;&lt;a href=&quot;#1-用前缀避免命名空间冲突&quot; class=&quot;headerlink&quot; title=&quot;1. 用前缀避免命名空间冲突&quot;&gt;&lt;/a&gt;1. 用前缀避免命名空间冲突&lt;/h3&gt;&lt;p&gt;OC 没有其他语言内置的命名空间机制. 因此在命名时设法避免潜在的命名冲突, 否则容易就重名.否则会出现类似错误:&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;duplicate symbol _OBJC_METACLASS_$_EOCTHECLASS &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;build/something.o&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;build/something_else.o&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;苹果宣称其保留使用所有”两字母前缀”(two-letter prefix)的权利,因此我们的命名前缀最好避免使用两个字母当前缀.&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.lydsnm.top/categories/iOS/"/>
    
    
      <category term="OC" scheme="http://www.lydsnm.top/tags/OC/"/>
    
  </entry>
  
  <entry>
    <title>OC开发相关注意事项</title>
    <link href="http://www.lydsnm.top/2016/08/24/OC%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://www.lydsnm.top/2016/08/24/OC开发相关注意事项/</id>
    <published>2016-08-23T16:00:00.000Z</published>
    <updated>2018-08-30T14:37:08.422Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些基本信息"><a href="#一些基本信息" class="headerlink" title="一些基本信息"></a>一些基本信息</h2><h3 id="1-内存相关"><a href="#1-内存相关" class="headerlink" title="1. 内存相关"></a>1. 内存相关</h3><p>分配在堆中的内存必须直接管理, 而分配在栈中的用于保存变量的内存则会在其栈弹出时自动清理.<br>    Objective-C将堆内存管理抽象出来了. 不需要用malloc及free来分配或释放对象所占内存. Objective-C运行期环境把这部分工作抽象为一套内存管理框架-“引用计数”</p><p>在OC中, 有时会遇到定义里不含*的变量, 可能会使用<code>栈空间</code>. 这些变量所保存的不是Objective-C对象, 比如CoreGraphics中的CGRect.</p><hr><h3 id="2-在类的头文件中尽量少引入其他头文件"><a href="#2-在类的头文件中尽量少引入其他头文件" class="headerlink" title="2. 在类的头文件中尽量少引入其他头文件"></a>2. 在类的头文件中尽量少引入其他头文件</h3><p>而是采用向前声明(forward declaring)<br>减少类的使用者, 所需引入的头文件数量,减少编译时间.<br>也能解决两个类互相引用的问题</p><a id="more"></a><hr><h3 id="3-多用字面量语法-少用与之等价的方法"><a href="#3-多用字面量语法-少用与之等价的方法" class="headerlink" title="3. 多用字面量语法, 少用与之等价的方法"></a>3. 多用字面量语法, 少用与之等价的方法</h3><p>字面量语法,比如:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *something = <span class="string">@"Effective Objective-C 2.0"</span>;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字面数值</span></span><br><span class="line"><span class="built_in">NSNumber</span> *someNumber = [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1</span>]; -&gt; <span class="built_in">NSNUmber</span> *someNumber = @<span class="number">1</span>;</span><br><span class="line"><span class="comment">//字面量数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *animals = @[<span class="string">@"cat"</span>, <span class="string">@"dog"</span>];<span class="comment">// 数组中若有nil会 抛出异常.</span></span><br><span class="line"><span class="comment">//字面量字典</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *personData = @&#123;</span><br><span class="line"><span class="string">@"firstName"</span> : <span class="string">@"Matt"</span>,</span><br><span class="line"><span class="string">@"lastName"</span> : <span class="string">@"za"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//可变数组</span></span><br><span class="line">mutableArray[<span class="number">1</span>] = <span class="string">@"dog"</span>;<span class="comment">// 尽量通过下标操作来访问数组, 或者字典中的所对应的元素.</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-多用类型常量-少用-define-预处理指令"><a href="#4-多用类型常量-少用-define-预处理指令" class="headerlink" title="4. 多用类型常量, 少用#define 预处理指令"></a>4. 多用类型常量, 少用#define 预处理指令</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> kAnimationDuration = <span class="number">0.3</span>;</span><br></pre></td></tr></table></figure><p>命名, 若常量局限于某”编译单元”(也就是实现文件中, implementation中),则在前面加字母k; 若常量在类之外可见, 则通常以类名为前缀.<br>尽量不要在头文件中声明预处理指令或定义常量 static const.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AnimatedView</span>: <span class="title">UIView</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> kAnimationDuration = <span class="number">0.3</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AnimatedView</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="comment">// static修饰意味着, 该变量仅局限于此变量的编译单元(在OC语境下, 一般通常指每个类的实现文件(.m))中.</span></span><br><span class="line">如不加<span class="keyword">static</span>, 在另一.m文件中也声明了同名变量, 会抛出常见的duplicate_symbol错误</span><br></pre></td></tr></table></figure><p>实际上, 如果一个变量既声明为static, 有声明为const, 那么编译器根本不会创建符号, 而是想#define预处理指令一样, 把所有遇到的变量都替换成常值. 不过这种方式定义的常量是带有类型信息的, 这点也相当关键.</p><ul><li>通知, 发送者和接受者都需要个外界可见的常量变量(即通知的名称).</li></ul><p>这时,此类变量需放在”全局符号表”(global symbol table)中, 以便可以在定义该变量的编译单元之外使用.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In the header file</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> EOCStringConstant;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In the implementation file</span></span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> EOCStringConstant = <span class="string">@"VALUENOTIFICATION"</span>;</span><br></pre></td></tr></table></figure><p>常量定义从右至左解读,这里是”一个常量, 而这个常量是个指针, 指向一个NSString对象”<br>这里面的命名要注意谨慎, 避免名称冲突, 最好用与值相关的类名做前缀.</p><h3 id="5-用枚举表示状态、选项、状态码"><a href="#5-用枚举表示状态、选项、状态码" class="headerlink" title="5. 用枚举表示状态、选项、状态码"></a>5. 用枚举表示状态、选项、状态码</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> EOCConnectionStateConnectionState&#123;</span><br><span class="line">EOCConnectionStateDisconnected = <span class="number">1</span>,</span><br><span class="line">EOCConnectionStateConnecting,</span><br><span class="line">EOCConnectionStateConnected,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义可以彼此组合的枚举. 定义的对后, 各选项之间就可通过”按位或操作符”(bitwise OR operator)来组合.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="built_in">UIViewAutoresizing</span> &#123;</span><br><span class="line"><span class="built_in">UIViewAutoresizingNone</span>= <span class="number">0</span>,</span><br><span class="line"><span class="built_in">UIViewAutoresizingFlexbleLeftMargin</span>= <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line"><span class="built_in">UIViewAutoresizingFlexbleWidth</span>= <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line"><span class="built_in">UIViewAutoresizingFlexbleRighMargin</span> = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在处理枚举类型的switch语句中不要实现default分支. 这样的话, 加入新枚举之后, 编译器就会提示开发者. switch语句并未处理所有枚举.</li></ul><hr><h2 id="对象、消息、运行期"><a href="#对象、消息、运行期" class="headerlink" title="对象、消息、运行期"></a>对象、消息、运行期</h2><h3 id="6-理解属性这一概念"><a href="#6-理解属性这一概念" class="headerlink" title="6.理解属性这一概念"></a>6.理解属性这一概念</h3><p>属性用来通过存取放方法来访问实例变量, 是OC提供的一个简洁方便管理的抽象机制. @property语法. 如果用了这些属性了, 编译器会自动编写访问这些属性所需的方法, 次过程叫”自动合成”(autosynthesis),并添加对应的实例变量. 也可以在类的实现代码里通过<code>@synthesize</code>语法来指定实例变量的名字</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@implementaion EOCPerson</span><br><span class="line"><span class="keyword">@synthesize</span> fireName = _myFirstname;</span><br><span class="line"><span class="keyword">@synthesize</span> lastName = _myLastName;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>可通过<code>@dynamic</code>关键字来告诉编译器不要自动创建实现属性所用的实例变量和存取方法.</p><p>修饰属性的特质关键字</p><ul><li>weak 表明定义了一种”非拥有关系”. 为这种属性设置新值时, 设置方法既不保留新值, 也不释放旧值. 当属性所指的对象遭到销毁时, 属性值也会清空(nil).</li><li>unsafe_unretained 该特质的语义表达一种”非拥有关系”, 当目标对象遭到销毁时, 属性值不会自动清空(unsafe), 这一点和weak不同.</li><li>在iOS程序是, 应用nonatomic属性, 避免影响性能</li></ul><p><br></p><hr><h3 id="7-在对对象内部尽量直接访问实例变量"><a href="#7-在对对象内部尽量直接访问实例变量" class="headerlink" title="7. 在对对象内部尽量直接访问实例变量"></a>7. 在对对象内部尽量直接访问实例变量</h3><p>直接访问实例变量, 速度会快一点, 但是对一个声明的copy的属性, 那么并不会拷贝该属性, 只会保留新值并释放旧值. 也不能触发”键值观察”(KVO), 一般比较折中的方式是写入实例变量时, 通过其”设置方法”来做, 而在读取实例变量是, 则直接访问.<br>注意的地方:<br>在初始化方法中应该如何设置属性值, 这种情况总是应该直接访问实例变量, 因为子类可能overide重写了设置方法.</p><p>对于懒加载或者说惰性初始化(lazy initialization)来说,就必须通过存取方法来访问属性.</p><p><br></p><hr><h3 id="8-理解”对象等同性”"><a href="#8-理解”对象等同性”" class="headerlink" title="8. 理解”对象等同性”"></a>8. 理解”对象等同性”</h3><p>有时,按照==操作符比较出来的结果未必是我们想要的, 该操作比较的是两个指针本身, 而不是所指的对象. 应该使用NSObject协议中声明的<code>isEqual</code><br>NSObject协议中有两个用于判断等同性的关键方法:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)isEqual:(<span class="keyword">id</span>)object;</span><br><span class="line">- (<span class="built_in">NSUInteger</span>)hash;</span><br></pre></td></tr></table></figure><ul><li><p>若想检测对象的等同性, 请提供<code>isEqual:</code>与<code>hash</code>方法.</p></li><li><p>相同的对象必须具有相同的哈希码, 但两个哈希码相同的对象却未必相同.</p></li><li><p>编写hash方法时, 应该使用计算速度快而且哈希码碰撞几率低的算法.</p></li></ul><p><br></p><hr><h3 id="9-以”类族模式”隐藏实现细节"><a href="#9-以”类族模式”隐藏实现细节" class="headerlink" title="9.以”类族模式”隐藏实现细节."></a>9.以”类族模式”隐藏实现细节.</h3><p>类方法(也叫类别方法)<br>类族模式可以把实现细节隐藏在一套简单的公共接口后面.</p><p>系统框架中经常使用类族(NSArray)</p><p><br></p><hr><h3 id="11-理解objc-msgSend的作用"><a href="#11-理解objc-msgSend的作用" class="headerlink" title="11. 理解objc_msgSend的作用"></a>11. 理解objc_msgSend的作用</h3><p>传递消息, C语言使用静态绑定(static binding), 在编译期内就能决定运行时所应调用的函数.函数地址实际上是硬编码在指令之中的.</p><p>so 对应的有动态绑定, 在OC中, 如果向某对象传递消息, 那就会使用动态绑定机制来决定需要调用的方法.</p><ul><li>给某对象”发送消息”(invoke a message)也就相当于在该对象上”调用方法”(call a method)</li><li>发给某对象的全部消息都要由”动态消息派发系统”(dynamic message dispatch system)来处理, 该系统会查处对应的方法, 并执行其代码.</li></ul><p><br></p><hr><h3 id="12-理解消息转发机制"><a href="#12-理解消息转发机制" class="headerlink" title="12. 理解消息转发机制"></a>12. 理解消息转发机制</h3><ul><li>若对象无法响应某个选择子, 则进入消息转发流程.</li><li>通过运行期的动态方法解析功能, 我们可以在需要用到某个方法时再讲其加入类中.</li><li>对象可以把其无法解读的某些选择子转交给其他对象来处理.</li><li>经过上述两步后, 如果还是没有办法处理选择子, 那就启动完整的消息转发机制.</li></ul><p><br></p><hr><h3 id="14-理解”类对象”的用意"><a href="#14-理解”类对象”的用意" class="headerlink" title="14. 理解”类对象”的用意"></a>14. 理解”类对象”的用意</h3><p>OC 有个特殊类型 <font color="#00fffff">id</font> 指代任意的 OC 对象类型. 一般情况下,消息转发给了 此 id 的对象, 但不知其具体类型是否能响应. 我们知道如果向某明确类型发送了无法解读的消息, 那么就会产生警告信息, 而 <font color="#00fffff">id</font>类型让编译器假定其能响应所有消息, 留待后续”在运行期检视对象类型”,看是否能够响应其方法.</p><ul><li>每个实例都有一个指向 Class 对象的指针, 用以表明其类型, 而这些 Class 对象则构成了类的继承体系.</li><li>如果对象类型无法在编译期确定,那么久应该实用类型信息查询方法来判断 <code>isKindOfClass</code>…</li><li>尽量实用类型信息查询方法来确定对象类型, 而不要直接比较类对象, 因为某些对象可能实现了消息转发功能.</li></ul><hr><p><br></p><p>本篇文章参考摘自 <font color="#B8860B">Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的52个有效方法</font></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一些基本信息&quot;&gt;&lt;a href=&quot;#一些基本信息&quot; class=&quot;headerlink&quot; title=&quot;一些基本信息&quot;&gt;&lt;/a&gt;一些基本信息&lt;/h2&gt;&lt;h3 id=&quot;1-内存相关&quot;&gt;&lt;a href=&quot;#1-内存相关&quot; class=&quot;headerlink&quot; title=&quot;1. 内存相关&quot;&gt;&lt;/a&gt;1. 内存相关&lt;/h3&gt;&lt;p&gt;分配在堆中的内存必须直接管理, 而分配在栈中的用于保存变量的内存则会在其栈弹出时自动清理.&lt;br&gt;    Objective-C将堆内存管理抽象出来了. 不需要用malloc及free来分配或释放对象所占内存. Objective-C运行期环境把这部分工作抽象为一套内存管理框架-“引用计数”&lt;/p&gt;
&lt;p&gt;在OC中, 有时会遇到定义里不含*的变量, 可能会使用&lt;code&gt;栈空间&lt;/code&gt;. 这些变量所保存的不是Objective-C对象, 比如CoreGraphics中的CGRect.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;2-在类的头文件中尽量少引入其他头文件&quot;&gt;&lt;a href=&quot;#2-在类的头文件中尽量少引入其他头文件&quot; class=&quot;headerlink&quot; title=&quot;2. 在类的头文件中尽量少引入其他头文件&quot;&gt;&lt;/a&gt;2. 在类的头文件中尽量少引入其他头文件&lt;/h3&gt;&lt;p&gt;而是采用向前声明(forward declaring)&lt;br&gt;减少类的使用者, 所需引入的头文件数量,减少编译时间.&lt;br&gt;也能解决两个类互相引用的问题&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.lydsnm.top/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://www.lydsnm.top/tags/iOS/"/>
    
  </entry>
  
</feed>
