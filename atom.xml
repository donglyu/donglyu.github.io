<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lydsnm</title>
  
  <subtitle>...多做多说...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.lydsnm.top/"/>
  <updated>2018-12-03T10:31:43.519Z</updated>
  <id>http://www.lydsnm.top/</id>
  
  <author>
    <name>lydsnm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>近期换工作了</title>
    <link href="http://www.lydsnm.top/2018/12/03/%E8%BF%91%E6%9C%9F%E9%9D%A2%E8%AF%95%E4%BD%93%E9%AA%8C/"/>
    <id>http://www.lydsnm.top/2018/12/03/近期面试体验/</id>
    <published>2018-12-02T16:00:00.000Z</published>
    <updated>2018-12-03T10:31:43.519Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;近期换工作，面试了很多家。突发发现我的很多表述能力还有“很大的潜力”。上家公司呆久了，没用到的基础性的知识，模糊的很，趁这个时候好好看了下，捡起来不少。</p><a id="more"></a><p>&emsp;&emsp;还是要保持竞争力才行啊。blog最好不要随心发布，还是经常学习，把笔记里的东西整理下发出来吧，满足一下~。</p><p>&emsp;&emsp;近期会更新一下面试的心得还有一些题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;近期换工作，面试了很多家。突发发现我的很多表述能力还有“很大的潜力”。上家公司呆久了，没用到的基础性的知识，模糊的很，趁这个时候好好看了下，捡起来不少。&lt;/p&gt;
    
    </summary>
    
      <category term="杂想" scheme="http://www.lydsnm.top/categories/%E6%9D%82%E6%83%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>Slice 1.0.1 —— Mac提升个人效率的一个小工具</title>
    <link href="http://www.lydsnm.top/2018/08/30/Slice%E6%9B%B4%E6%96%B01.0.1/"/>
    <id>http://www.lydsnm.top/2018/08/30/Slice更新1.0.1/</id>
    <published>2018-08-29T16:00:00.000Z</published>
    <updated>2018-11-26T07:31:46.928Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Slice更新："><a href="#一、Slice更新：" class="headerlink" title="一、Slice更新："></a>一、Slice更新：</h2><p><img src="https://upload-images.jianshu.io/upload_images/1106214-2ef452181b188f6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="SlicePrevie"></p><p>&emsp;&emsp;你是否有这样的体验，如果给你一上午的周末时间，可能会想着反正时间也多，打扫个卫生，刷刷微博一上午就过去，但如果是把这些时间划分成15分钟的片段，每个片段做一件事，一上午能做的事绝对超出你的想象。</p><p>&emsp;&emsp;在短暂的片刻时间内，指定一个几十分钟内要完成的任务。这几十分钟内只专做这件事，不要被其他打扰。只有倒计时才会给人紧迫感。与其在期望未来虚幻的成就，不如着眼现在，把握即将到来的一小段时间。</p><p>&emsp;&emsp;我个人也在用这个软件，使用下来，确实提升了不少效率。</p><a id="more"></a><h2 id="二、正确使用姿势："><a href="#二、正确使用姿势：" class="headerlink" title="二、正确使用姿势："></a>二、正确使用姿势：</h2><p>&emsp;&emsp;脑中指定一件接下来要做的事，接下来的一段时间内只专注于这一件事（一段时间：就是自己输入的时间）。亲测，效率提升不少，并且有一丝紧迫感。</p><p>&emsp;&emsp;建议15分钟一次，太长会集中不了注意力，影响效率。此外，永远也不要做一件事，超过1个小时。利用碎片时间，将整块的时间分成小片段，去做任何琐碎的事，而不会花掉整块时间处理。</p><h2 id="三、功能特点："><a href="#三、功能特点：" class="headerlink" title="三、功能特点："></a>三、功能特点：</h2><ul><li>占用极小。</li><li>始终悬停在所有窗口最前面。</li><li>菜单栏点击，可以创建一个新的倒计时窗口（即支持多个计时器）</li><li>自定义提醒信息</li></ul><p>Slice 1.0.1. 在上一个版本的基础上，精简了一些功能。新增了以下一些功能：</p><ul><li>暂停功能：<br>可能在中途出现突发事情要去处理，可以暂停Slice时间。</li><li>更明显的提醒信息</li></ul><hr><h2 id="四、后期功能计划"><a href="#四、后期功能计划" class="headerlink" title="四、后期功能计划"></a>四、后期功能计划</h2><ul><li>提醒音效可选择。</li><li>后期会加统计功能。</li></ul><hr><h2 id="五、使用"><a href="#五、使用" class="headerlink" title="五、使用"></a>五、使用</h2><p>下载链接:<a href="https://pan.baidu.com/s/1roNYPESUcKJJhXRkOl6uzw" target="_blank" rel="noopener">https://pan.baidu.com/s/1roNYPESUcKJJhXRkOl6uzw</a>  密码:s1vx</p><p>解压后将<code>slice.app</code>拖动到系统的应用程序中</p><p>另外，针对某些用户所说，在10.11以后系统可能安装不了的情况，可以在“设置”中“安全与隐私”的“通用”选项下， 设置<b>允许从任何来源的应用</b>。然后就可以正常使用Slice了。因为Slice是本人在业余时间开发，并未上架App store，且OS X系统有这么一个保护机制，故有这样现象。</p><p><img src="http://ocs32tleq.bkt.clouddn.com/PastedGraphic-1-systemSettingforMac.png" width="500"></p><p>如果在这个地方没有“任何来源”一项的话，就需要打开系统应用“终端”，输入</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo spctl --master-disable</span><br></pre></td></tr></table></figure><p>然后再输入你的系统密码回车即可（不屏显）。</p><h2 id="六、联系我"><a href="#六、联系我" class="headerlink" title="六、联系我"></a>六、联系我</h2><p>如果你有什么建议或意见，请告诉我~<br>[邮箱]：<a href="mailto:dongingdao@163.com" target="_blank" rel="noopener">dongingdao@163.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、Slice更新：&quot;&gt;&lt;a href=&quot;#一、Slice更新：&quot; class=&quot;headerlink&quot; title=&quot;一、Slice更新：&quot;&gt;&lt;/a&gt;一、Slice更新：&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1106214-2ef452181b188f6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;SlicePrevie&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;你是否有这样的体验，如果给你一上午的周末时间，可能会想着反正时间也多，打扫个卫生，刷刷微博一上午就过去，但如果是把这些时间划分成15分钟的片段，每个片段做一件事，一上午能做的事绝对超出你的想象。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;在短暂的片刻时间内，指定一个几十分钟内要完成的任务。这几十分钟内只专做这件事，不要被其他打扰。只有倒计时才会给人紧迫感。与其在期望未来虚幻的成就，不如着眼现在，把握即将到来的一小段时间。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;我个人也在用这个软件，使用下来，确实提升了不少效率。&lt;/p&gt;
    
    </summary>
    
      <category term="tools" scheme="http://www.lydsnm.top/categories/tools/"/>
    
    
  </entry>
  
  <entry>
    <title>应用审核通过，但是内购项目一直处于正在审核中</title>
    <link href="http://www.lydsnm.top/2018/07/03/2018-07-03%E5%BA%94%E7%94%A8%E5%AE%A1%E6%A0%B8%E9%80%9A%E8%BF%87%EF%BC%8C%E4%BD%86%E6%98%AF%E5%86%85%E8%B4%AD%E9%A1%B9%E7%9B%AE%E4%B8%80%E7%9B%B4%E5%A4%84%E4%BA%8E%E6%AD%A3%E5%9C%A8%E5%AE%A1%E6%A0%B8%E4%B8%AD/"/>
    <id>http://www.lydsnm.top/2018/07/03/2018-07-03应用审核通过，但是内购项目一直处于正在审核中/</id>
    <published>2018-07-03T14:52:43.852Z</published>
    <updated>2018-07-03T14:54:22.967Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;近期应用上架会员功能，新增了几个内购项目，按部就班，应用测试通过后，提交应用商店审核。自信的勾选上审核通过后自动发布，可是应用通过审核并自动释放了，内购项目没有通过，导致线上用户版本，点击购买会员获取不到商品信息，没有任何反应，特难受。现在记录一下我的解决过程，希望对其他有遇到这个问题的朋友有所帮助。</p><a id="more"></a><p>&emsp;&emsp;尝试过重新修改下判断没有商店信息给出提醒，按照一些网友的解决方法：重新提交一个新版本审核，并改成了手动发布。然而事实告诉我，这样并没有用。审核员再次遗漏了我的内购项目。无奈之下，尝试了邮件申诉反馈。</p><p>附：<a href="https://developer.apple.com/" target="_blank" rel="noopener">https://developer.apple.com/</a> -&gt; Contact Us -&gt; App Review -&gt; Other App Review questions -&gt; I would like to <code>get the status of my app</code>。这是我的选择步骤。</p><p>&emsp;&emsp;第二天，早上8点多邮件有通知，内购通过了，线上版本不用更新可以直接用了（PS：服务器同步要时间，等到下午的时候，会员才可以正常购买）。</p><h2 id="结语："><a href="#结语：" class="headerlink" title="结语："></a>结语：</h2><p>&emsp;&emsp;如果一个版本有新增的内购项，那么这个版本还是改成<code>手动释放</code>比较好。点击发布前要检查你的内购项是否是处于<code>已批准</code>状态。如果发现应用通过后，内购审核没有红点（也就说没有按要求填写而打回）处于正在审核中，请联系苹果客服，不要重新发包了，至少我这里的经验是这样的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;近期应用上架会员功能，新增了几个内购项目，按部就班，应用测试通过后，提交应用商店审核。自信的勾选上审核通过后自动发布，可是应用通过审核并自动释放了，内购项目没有通过，导致线上用户版本，点击购买会员获取不到商品信息，没有任何反应，特难受。现在记录一下我的解决过程，希望对其他有遇到这个问题的朋友有所帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.lydsnm.top/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>私有API检测系统中是否安装了某款指定的软件</title>
    <link href="http://www.lydsnm.top/2018/06/25/2018-06-25%E7%A7%81%E6%9C%89API%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E4%BA%86%E6%9F%90%E6%AC%BE%E6%8C%87%E5%AE%9A%E7%9A%84%E8%BD%AF%E4%BB%B6/"/>
    <id>http://www.lydsnm.top/2018/06/25/2018-06-25私有API检测系统中是否安装了某款指定的软件/</id>
    <published>2018-06-25T12:34:11.000Z</published>
    <updated>2018-07-08T01:56:23.146Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;前段时间，在一个积分任务墙的项目，需要跳转到市场去安装App，了需要检测iOS设备已安装应用列表的需求，要能获取到安装情况（包括安装进度啊，完成回调等）。经过一段时间的了解，还算完成了既定任务。</p><a id="more"></a><h2 id="URL-Scheme"><a href="#URL-Scheme" class="headerlink" title="URL Scheme"></a>URL Scheme</h2><p>&emsp;&emsp;前期考虑过<code>URL Scheme</code>来判断是否安装了某个应用，但是每个app是否设置了URL scheme不知道，而且iOS9上  <code>[[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:url]]</code>的能判断的上限是50个，因此这个实际情况下无法使用。但是我们可能在其他场景下使用到URL Scheme(比如打开系统应用)，可以下面的方法列出所有的URL Scheme，但是哪个scheme是哪个应用就得靠猜了，一个应用也可能有多个URL Scheme。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span>*)privateURLSchemes&#123;</span><br><span class="line">    <span class="keyword">return</span> [_workspace privateURLSchemes];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span>*)publicURLSchemes&#123;</span><br><span class="line">    <span class="keyword">return</span> [_workspace publicURLSchemes];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取系统中安装列表和各应用的bundleId。"><a href="#获取系统中安装列表和各应用的bundleId。" class="headerlink" title="获取系统中安装列表和各应用的bundleId。"></a>获取系统中安装列表和各应用的bundleId。</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class LSApplicationWorkspace_class = objc_getClass(<span class="string">"LSApplicationWorkspace"</span>);  </span><br><span class="line">SEL selector=<span class="built_in">NSSelectorFromString</span>(<span class="string">@"defaultWorkspace"</span>);  </span><br><span class="line"><span class="built_in">NSObject</span>* workspace = [LSApplicationWorkspace_class performSelector:selector];  </span><br><span class="line">_workspace = workspace</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">&lt;objc/runtime.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"> SEL selectorALL = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"allApplications"</span>);  </span><br><span class="line"> <span class="built_in">NSArray</span> *apps = [_workspace performSelector:selectorALL];</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"apps: %@"</span>, );  </span><br><span class="line"> [apps[<span class="number">0</span>] performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"applicationIdentifier"</span>)];<span class="comment">//shortVersionString等。</span></span><br></pre></td></tr></table></figure><p>其余一些方法可以去这儿<a href="https://github.com/nst/iOS-Runtime-Headers/blob/master/Frameworks/MobileCoreServices.framework/LSApplicationProxy.h" target="_blank" rel="noopener">查看</a>：</p><p>关于LSApplicationWorkspace的使用可以查看<a href="https://www.jianshu.com/p/b8d882069197" target="_blank" rel="noopener">iOS私有方法LSApplicationWorkspace.h的一些使用</a></p><h2 id="通过定时器不断的调度-可以用下面的方法得到-所有正在下载的app"><a href="#通过定时器不断的调度-可以用下面的方法得到-所有正在下载的app" class="headerlink" title="通过定时器不断的调度 可以用下面的方法得到 所有正在下载的app"></a>通过定时器不断的调度 可以用下面的方法得到 所有正在下载的app</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 通过定时器不断调用来获取系统中所有正在下载的内容及进度。*/</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)TimerUpdateToGetDownloadProgress:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *lib = dlopen(<span class="string">"/System/Library/Frameworks/MobileCoreServices.framework/MobileCoreServices"</span>, RTLD_LAZY);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (lib)&#123;</span><br><span class="line">        Class LSApplicationWorkspace = <span class="built_in">NSClassFromString</span>(<span class="string">@"LSApplicationWorkspace"</span>);</span><br><span class="line">        <span class="keyword">id</span> AAURLConfiguration1 = [LSApplicationWorkspace performSelector:<span class="keyword">@selector</span>(defaultWorkspace)];</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (AAURLConfiguration1)&#123;</span><br><span class="line">            <span class="keyword">id</span> arrApp = [AAURLConfiguration1 performSelector:<span class="keyword">@selector</span>(allApplications)];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;[arrApp count]; i++) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">id</span> LSApplicationProxy = [arrApp objectAtIndex:i];</span><br><span class="line">                <span class="built_in">NSString</span>* bundleId =[LSApplicationProxy performSelector:<span class="keyword">@selector</span>(applicationIdentifier)];</span><br><span class="line">                <span class="built_in">NSString</span>* name = [LSApplicationProxy localizedName];</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">NSProgress</span> *progress = (<span class="built_in">NSProgress</span> *)[LSApplicationProxy performSelector:<span class="keyword">@selector</span>(installProgress)];</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"current progress:%lf bundleId:%@"</span>, [<span class="built_in">NSProgress</span> currentProgress], bundleId);</span><br><span class="line">                <span class="comment">// 正在安装的模型数据</span></span><br><span class="line"><span class="comment">//                InstallingModel *model = [self getInstallModel:bundleId];</span></span><br><span class="line">                <span class="comment">//如果是正在下载状态</span></span><br><span class="line">                <span class="keyword">if</span> (progress)&#123;</span><br><span class="line">                    <span class="comment">//已经检测到的</span></span><br><span class="line"><span class="comment">//                    if (model) &#123;</span></span><br><span class="line"><span class="comment">//                        model.progress = [progress localizedDescription];</span></span><br><span class="line"><span class="comment">//                        model.status  =  [NSString stringWithFormat:@"%@",[[progress userInfo] valueForKey:@"installState"]];</span></span><br><span class="line">                        <span class="comment">//第一次检测到的</span></span><br><span class="line"><span class="comment">//                    &#125;else&#123;</span></span><br><span class="line"><span class="comment">//                        InstallingModel *model = [[InstallingModel alloc] init];</span></span><br><span class="line"><span class="comment">//                        model.appName = name;</span></span><br><span class="line"><span class="comment">//                        model.bundleID = bundleId;</span></span><br><span class="line"><span class="comment">//                        model.progress = [progress localizedDescription];</span></span><br><span class="line"><span class="comment">//                        model.status  = [NSString stringWithFormat:@"%@",[[progress userInfo] valueForKey:@"installState"]];</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                        [_installedAry addObject:model];</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lib) dlclose(lib);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过bundle-id判断是否安装并打开app"><a href="#通过bundle-id判断是否安装并打开app" class="headerlink" title="通过bundle id判断是否安装并打开app"></a>通过bundle id判断是否安装并打开app</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过applicationIdentifier id。判断是否安装某个APP</span></span><br><span class="line">        <span class="built_in">BOOL</span> isInstall = [workspace performSelector:<span class="keyword">@selector</span>(applicationIsInstalled:) withObject:<span class="string">@"com.tencent.xin"</span>];</span><br><span class="line">        <span class="keyword">if</span> (isInstall) &#123;</span><br><span class="line">            <span class="comment">//通过bundle id打开APP</span></span><br><span class="line">            [workspace performSelector:<span class="keyword">@selector</span>(openApplicationWithBundleID:) withObject:<span class="string">@"com.tencent.xin"</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"您还没安装"</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上一些方法大都使用到了私有API、故切记要上架到app store的应用不要使用。<br>在了解过程中，一并完成了一个测试demo，有需要的可以在此基础上试验。<br><a href="https://github.com/donglyu/CheckInstalledAppEtcIniOS" target="_blank" rel="noopener">Demo地址</a></p><p>- EOF -</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;前段时间，在一个积分任务墙的项目，需要跳转到市场去安装App，了需要检测iOS设备已安装应用列表的需求，要能获取到安装情况（包括安装进度啊，完成回调等）。经过一段时间的了解，还算完成了既定任务。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.lydsnm.top/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>记一则iOS封装SDK的开发过程之WebView和JS交互</title>
    <link href="http://www.lydsnm.top/2018/05/20/%E8%AE%B0%E4%B8%80%E5%88%99iOS%E5%B0%81%E8%A3%85SDK%E7%9A%84%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B9%8BWebView%E5%92%8CJS%E4%BA%A4%E4%BA%92/"/>
    <id>http://www.lydsnm.top/2018/05/20/记一则iOS封装SDK的开发过程之WebView和JS交互/</id>
    <published>2018-05-19T16:00:00.000Z</published>
    <updated>2018-06-25T14:49:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;近来接触了一个封装sdk的项目，过程中遇到了一些问题，现在空了下来，将这个过程记录一下。<br>项目主要由<u>iOS封装一个framework静态库，库里面引入由甲方提供的js方法库（一个js文件），原生调用js中的方法，将方法返回值通过原生方法回调会去</u>。相当于一个中间件的功能。</p><p>&emsp;&emsp;我首先想到的是通过 <font color="a52a2a"><b>UIWebView</b></font> 或 <font color="a52a2a"><b>WKWebView</b></font> 来加载js，然后通过javascriptCore和WKWebView自带的方法来处理。这个甲方要求又不要显示html页面，所以使用WebView有点用了牛刀的感觉。查了查资料，没有找到直接能和js文件交互的方法，无奈还是采用了WKWebView。</p><a id="more"></a><p>&emsp;&emsp;由于wkwebView是iOS8以后推出的新框架，故而一开始就使用使用了wkwebview。当对应的html、js到位后，发现js中的回调很奇怪，原生偶尔可以得到回调，猜测可能js方法库中方法太过繁忙，从而导致消息堵塞进而丢失掉。经过延时的操作，发现并不是这个问题。</p><p>&emsp;&emsp;正如之前说的，项目并不需要展示webView，html中的内容也不需要展示。而需求是提供.framework，不可能头文件提供一个webView给开发者，添加到对应的界面上吧。因此做了一个小尝试，快速改换成了UIWebView，相应的js方法，和调用方法，以及回调方法改了下来测试。发现可以正常使用。这下得出结论WkWebView如果没有正常显示的话，内部有种“惰性”的感觉，某些js方法执行和回调很“迟缓”，往往点几次才会响应。</p><p>&emsp;&emsp;研究到这，应该是换成UIWebView了。但是抱着不甘心，多查了些资料，和试验了几波，是真的因为那个原因吗？不多说了，总结了下我的两个解决方法：</p><h2 id="最终解决"><a href="#最终解决" class="headerlink" title="最终解决"></a>最终解决</h2><h3 id="1-使用UIWebView"><a href="#1-使用UIWebView" class="headerlink" title="1.使用UIWebView"></a>1.使用UIWebView</h3><p>js中使用下面的代码回调原生</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bclMiddlecallback(callbackScheme, callbackPath);</span><br></pre></td></tr></table></figure><p>UIWebView可以不加在任何View上，也可以设置<code>.hidden = YES;</code></p><h3 id="2-继续使用WKWebView"><a href="#2-继续使用WKWebView" class="headerlink" title="2.继续使用WKWebView"></a>2.继续使用WKWebView</h3><p>js中使用下面的方法回调原生</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.webkit.messageHandlers.bclMiddlecallback.postMessage(callbackScheme + callbackPath);</span><br></pre></td></tr></table></figure><p>！！！WKWebView必须加在某个View上，内部一些机制才能正常运转、回调才能正常发生。.hidden设置或者不设置不影响。</p><p>所以：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WKWebView</span> *wkWebView = [[<span class="built_in">WKWebView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, [[<span class="built_in">UIScreen</span> mainScreen] bounds].size.height, <span class="number">320</span>, <span class="number">480</span>) configuration:configuration];</span><br><span class="line">_wkWebView = wkWebView;</span><br><span class="line">[[[<span class="built_in">UIApplication</span> sharedApplication] windows].firstObject addSubview:wkWebView];</span><br><span class="line">wkWebView.hidden = <span class="literal">YES</span>;</span><br></pre></td></tr></table></figure><p>收工！</p><hr><p>如果你也遇到此问题，如果你有新的想法请联系我：<a href="mailto:dongigndao@163.com" target="_blank" rel="noopener">dongigndao@163.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;近来接触了一个封装sdk的项目，过程中遇到了一些问题，现在空了下来，将这个过程记录一下。&lt;br&gt;项目主要由&lt;u&gt;iOS封装一个framework静态库，库里面引入由甲方提供的js方法库（一个js文件），原生调用js中的方法，将方法返回值通过原生方法回调会去&lt;/u&gt;。相当于一个中间件的功能。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;我首先想到的是通过 &lt;font color=&quot;a52a2a&quot;&gt;&lt;b&gt;UIWebView&lt;/b&gt;&lt;/font&gt; 或 &lt;font color=&quot;a52a2a&quot;&gt;&lt;b&gt;WKWebView&lt;/b&gt;&lt;/font&gt; 来加载js，然后通过javascriptCore和WKWebView自带的方法来处理。这个甲方要求又不要显示html页面，所以使用WebView有点用了牛刀的感觉。查了查资料，没有找到直接能和js文件交互的方法，无奈还是采用了WKWebView。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.lydsnm.top/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS WebView修改userAgent的问题与解决</title>
    <link href="http://www.lydsnm.top/2018/03/22/iOS%20WebView%E4%BF%AE%E6%94%B9userAgent%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/"/>
    <id>http://www.lydsnm.top/2018/03/22/iOS WebView修改userAgent的问题与解决/</id>
    <published>2018-03-21T16:00:00.000Z</published>
    <updated>2018-11-08T15:37:20.907Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;前阵子做一个阅读应用，需要嵌入H5页面，要让网页检测到是App的webView访问。网页有个loading数据过程，这个loading效果比较复杂，于是乎由客户端实现，需要网页告诉客户端什么时候该关掉Loading动画遮罩层（还有一些其他交互效果）。这就涉及到了网页和原生的交互了。客户端使用的是<font color="a52a2a">WKWebView</font>。</p><a id="more"></a><p>&emsp;&emsp;在UIWebView上修改全局userAgent就使用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIWebView</span> *webView = [[<span class="built_in">UIWebView</span> alloc] initWithFrame:<span class="built_in">CGRectZero</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *userAgent = [webView stringByEvaluatingJavaScriptFromString:<span class="string">@"navigator.userAgent"</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *newUserAgent = [userAgent stringByAppendingString:<span class="string">@" AppFlag"</span>];</span><br><span class="line">        newUserAgent = [newUserAgent stringByAppendingString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@" token/%@"</span>, token]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *dictionary = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:newUserAgent, <span class="string">@"UserAgent"</span>, <span class="literal">nil</span>];</span><br><span class="line">    [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] registerDefaults:dictionary];</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在UIWebView上获取userAgent的方法是同步的(Synchronous)。</p><p>&emsp;&emsp;如果实在WKWebView上则使用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WKWebView</span> *wkWebView = [[<span class="built_in">WKWebView</span> alloc] initWithFrame:<span class="built_in">CGRectZero</span>];</span><br><span class="line">    <span class="keyword">self</span>.wkWebView = wkWebView;</span><br><span class="line">    [wkWebView evaluateJavaScript:<span class="string">@"navigator.userAgent"</span> completionHandler:^(<span class="keyword">id</span> result, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *userAgent = result;</span><br><span class="line">        <span class="built_in">NSString</span> *newUserAgent = [userAgent stringByAppendingString:<span class="string">@" AppFlag"</span>];</span><br><span class="line">      </span><br><span class="line">    newUserAgent = [newUserAgent stringByAppendingString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@" token/%@"</span>, token]];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSDictionary</span> *dictionary = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:newUserAgent, <span class="string">@"UserAgent"</span>, <span class="literal">nil</span>];</span><br><span class="line">        [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] registerDefaults:dictionary];</span><br><span class="line">         [<span class="keyword">self</span>.wkWebView setCustomUserAgent:customUserAgent]</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在WKWebView上获取userAgent就是异步的(Asynchronous)。</p><p>&emsp;&emsp;如果在webView loadRequest之前使用WKWebView的方式修改了userAgent之后，在Safari中调试发现userAgent实际上可能并没有成功修改。其实是因为异步修改没有修改成功，如果再次load了一个新页面，再在Safari中控制台输入<code>navigator.userAgent</code>就可以查看到修改后的内容，这就是很多其他朋友说遇到的要第二次才能显示自定义的值。<strong><font color="10d3c4">这里建议使用UIWebView的方式修改全局userAgent，然后再使用WKWebView取加载内容，最简单最通用</font></strong>。如果使用WKWebView修改后再用WKWebView加载页面，需要注意获取并修改 userAgent 的 webView 对象，跟加载网页的 webView 不能是同一个对象，也就说在获取到当前的userAgent的回调里需要重新初始化 wKWebView来加载页面。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIWebView</span> *webView = [[<span class="built_in">UIWebView</span> alloc] initWithFrame:<span class="built_in">CGRectZero</span>];</span><br><span class="line"><span class="built_in">NSString</span> *userAgent = [webView stringByEvaluatingJavaScriptFromString:<span class="string">@"navigator.userAgent"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *newUserAgent = [userAgent stringByAppendingString:<span class="string">@" native_iOS"</span>];<span class="comment">//自定义需要拼接的字符串</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *dictionary = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:newUserAgent, <span class="string">@"UserAgent"</span>, <span class="literal">nil</span>];</span><br><span class="line">[[<span class="built_in">NSUserDefaults</span> standardUserDefaults] registerDefaults:dictionary];</span><br><span class="line">[<span class="keyword">self</span>.wkWebView setCustomUserAgent:customUserAgent]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>参考链接：</strong></p><p><a href="https://stackoverflow.com/questions/26994491/set-useragent-in-wkwebview" target="_blank" rel="noopener">https://stackoverflow.com/questions/26994491/set-useragent-in-wkwebview</a><br><a href="https://cloud.tencent.com/developer/article/1158832" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1158832</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;前阵子做一个阅读应用，需要嵌入H5页面，要让网页检测到是App的webView访问。网页有个loading数据过程，这个loading效果比较复杂，于是乎由客户端实现，需要网页告诉客户端什么时候该关掉Loading动画遮罩层（还有一些其他交互效果）。这就涉及到了网页和原生的交互了。客户端使用的是&lt;font color=&quot;a52a2a&quot;&gt;WKWebView&lt;/font&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="OC" scheme="http://www.lydsnm.top/categories/OC/"/>
    
    
  </entry>
  
  <entry>
    <title>苹果的Marzipan</title>
    <link href="http://www.lydsnm.top/2017/12/27/%E8%8B%B9%E6%9E%9C%E7%9A%84Marzipan/"/>
    <id>http://www.lydsnm.top/2017/12/27/苹果的Marzipan/</id>
    <published>2017-12-26T16:00:00.000Z</published>
    <updated>2018-11-14T11:35:26.931Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;听说有个新的东西：为了增强Mac上的软件产品，苹果正在计划模糊macOS和iOS平台之间的界限，允许iOS App Store上的iPhone和iPad应用程序在Mac上运行：</p><p>&emsp;&emsp;<code>Marzipan</code>  <a href="https://baijiahao.baidu.com/s?id=1587358985291753758&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">新闻来源</a>    <em>一个App适配所有设备。</em></p><a id="more"></a><p>&emsp;&emsp;一方面，熟悉苹果生态的人都比较清楚，iOS上软件质量一向很高，数量也很多，几乎能够找到所有功能的App。而对应的MAC OS平台上相比较iOS，软件上数量上就少很多了（软件质量上我个人认为是不差的。）。<br>如果iOS上的App能够跨在MAC OS上使用就好了。</p><p>&emsp;&emsp;另一方面，如果苹果能将这条通道打通的话，那么iPad的用武之地就大许多了，随之而来iPad的销量也将会大幅上升。毕竟现阶段iPad还是处于一个尴尬的处境，处理复杂事物时，还是需要Mac的文件管理系统，能够更加灵活的处理。处理文档、简单任务时，iPad还是有优势的。</p><p>&emsp;&emsp;期待一下吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;听说有个新的东西：为了增强Mac上的软件产品，苹果正在计划模糊macOS和iOS平台之间的界限，允许iOS App Store上的iPhone和iPad应用程序在Mac上运行：&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;code&gt;Marzipan&lt;/code&gt;  &lt;a href=&quot;https://baijiahao.baidu.com/s?id=1587358985291753758&amp;amp;wfr=spider&amp;amp;for=pc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;新闻来源&lt;/a&gt;    &lt;em&gt;一个App适配所有设备。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Apple" scheme="http://www.lydsnm.top/categories/Apple/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift中的值类型引用类型相关内容</title>
    <link href="http://www.lydsnm.top/2017/10/14/Swift%E4%B8%AD%E7%9A%84%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/"/>
    <id>http://www.lydsnm.top/2017/10/14/Swift中的值类型引用类型相关内容/</id>
    <published>2017-10-13T16:00:00.000Z</published>
    <updated>2018-11-14T11:36:38.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Swift中的值类型和引用类型"><a href="#一、Swift中的值类型和引用类型" class="headerlink" title="一、Swift中的值类型和引用类型"></a>一、Swift中的值类型和引用类型</h2><h3 id="值类型和引用类型是啥"><a href="#值类型和引用类型是啥" class="headerlink" title="值类型和引用类型是啥"></a>值类型和引用类型是啥</h3><p>&emsp;&emsp;最近在用Swift写代码，发现Swift中的值类型和引用类型好像有些奇怪，包括之前了解到的NSArray和Array之间的关系，有些混淆了。现在静下来来学习下，记录一下，防止后面防错。</p><p>&emsp;&emsp;首先来回顾一下基础概念：什么是值类型和引用类型。</p><blockquote><ul><li>值类型：每个实例都拥有数据的一份副本。当被赋值给一个变量或常量，或传递给一个函数时，它都会拷贝一份新的副本。</li><li>引用类型：所有实例共享一个数据副本。当被赋值给一个变量或常量，或传递给一个函数时候，一个引用类型一旦被初始化，会返回一个指向已存在实例的引用。</li></ul></blockquote><p>&emsp;&emsp;类(class)是一个引用类型，复制一个引用，即表示建立一个共享的实例。复制之后，两个变量都使用数据中同一份实例。<br>&emsp;&emsp;类(Class)是一个引用类型，意味着类中的变量不会存储实例，而是一个向内存(堆)中存储该实例位置的引用。</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"张三"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> badStudent = <span class="type">People</span>()</span><br><span class="line"><span class="keyword">var</span> goodStudent = badStudent</span><br><span class="line"></span><br><span class="line">goodStudent.name = <span class="string">"李四"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"badStudent's name:\(badStudent)"</span>) <span class="comment">// 李四</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"goodStudent's name:\(goodStudent)"</span>) <span class="comment">// 李四</span></span><br><span class="line"><span class="comment">// 修改goodStudent中的内容就相当于修改badStudent。它们所代表的是同一个东西。</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但除了Class外，Swift还有一种常用的类型：结构体。而结构体就是一个值类型。而Swift中用Struct的场景变多了。<br>类似<code>Array</code>、<code>Dictonary</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"张三"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> firstStudent = <span class="type">People</span>()</span><br><span class="line"><span class="keyword">var</span> secondStudent = firstStudent</span><br><span class="line"></span><br><span class="line">firstStudent.name = <span class="string">"李四"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"firstStudent's name:\(firstStudent)"</span>) <span class="comment">// 李四</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"secondStudent's name:\(secondStudent)"</span>) <span class="comment">// 张三</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// secondStudent用firstStudent赋值后，就是一个独立的数据实例了。</span></span><br></pre></td></tr></table></figure><p>当然，Swift中值类型和引用类型还有很多：</p><p><img src="http://cc.cocimg.com/api/uploads//20180503/1525333385999865.png" alt="Swift中值类型和引用类型表"></p><blockquote><p>Swift把一个引用类型看成一个类，这和Objective-C中很像。Objective-C中一切继承于NSObject都被按照引用类型存储。</p></blockquote><h3 id="什么时候用值引用和引用类型好"><a href="#什么时候用值引用和引用类型好" class="headerlink" title="什么时候用值引用和引用类型好"></a>什么时候用值引用和引用类型好</h3><ul><li>以下时候使用值类型：</li></ul><p>想要用==比较实例数据。一个双等号(==)用于比较值。</p><p>你想复制来建立独立数据。</p><p>数据要在多线程的代码中使用，那么你就不用担心数据会被其他线程改变。</p><ul><li>以下时候使用引用类型(比如一个类)：</li></ul><p>想要用==比较实例一致性。==会检查两个对象是否完全一致，包括存储数据的内存地址。</p><p>你想要创建用于共享，可改变的数据。</p><hr><h3 id="值类型和引用类型的存储"><a href="#值类型和引用类型的存储" class="headerlink" title="值类型和引用类型的存储"></a>值类型和引用类型的存储</h3><blockquote><p>值类型-在栈内存中存储、而引用类型-在托管堆内存中存储。</p></blockquote><p>像前面说的，引用类型实例存在堆中，值类型实例比如结构存在于一个称为栈的内存区域中。如果值类型实例是一个类的一部分，值会和类一起存在堆中。</p><p>栈被用于静态存储分配，栈用于动态存储分配，它们都存在计算机的RAM中。</p><p>栈被CPU紧密管理并优化，当一个函数创建一个变量，栈会存储这个变量，并在函数退出时候被毁掉。被分配到栈的变量直接存储在内存上，访问这段内存非常快。当一个函数或者方法调用另一个函数，另一个函数再依次调用其他函数等等，直到最后一个函数返回它的值之前，其他所有函数都会保持暂停执行。</p><p>栈总是按照LIFO顺序保留，最新保留的区块总是会下一个释放。这使得跟踪记录栈非常简单，释放一个栈上的区块不过是调整一个指针。因为栈非常组织有序，所以它快捷高效。</p><p>系统使用堆存储被其他对象引用的数据，堆是一大片内存，系统可以从中请求并动态分配内存区块。堆并不会像栈一样自动毁掉它的对象，需要外部工作来处理这些。在苹果设备中ARC就做这个工作。引用数量会被ARC追踪，当它变为0时对象会被释放。因此整个过程(分配，追踪引用，释放)会比栈要慢。所以值类型要快于引用类型。</p><h2 id="二、Swift中的Array"><a href="#二、Swift中的Array" class="headerlink" title="二、Swift中的Array"></a>二、Swift中的Array</h2><p>&emsp;&emsp;在OC中数组可以copy或者mutablecopy，可变数组和不可变数组可以来回拷贝数据。NSArray、NSMutableArray之间是不同点实例，来回处理过后，内部存储的元素其实指针所指向内容都是同一个。</p><p>而在Swift中常用的数组对象<code>Array</code>。跳转到其定义处：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Array</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;发现其实Array是一个结构体，是一个值类型，且不自带copy方法的方法，数组分成:可变数组和不可变数组，分别使用let修饰的数组是不可变数组，使用var修饰的数组是可变数组。如果想要实现拷贝方法，则需要对对象实现拷贝方法。即遵守NSCopying协议和实现copyWithZone方法<br>eg:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现NSCopying协议。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">NSObject</span>, <span class="title">NSCopying</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">copyWithZone</span><span class="params">(zone: NSZone)</span></span> -&gt; <span class="type">AnyObject</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> person = <span class="type">Person</span>()</span><br><span class="line">        person.name = <span class="keyword">self</span>.name</span><br><span class="line">        person.age = <span class="keyword">self</span>.age</span><br><span class="line">        <span class="keyword">return</span> person</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;所以在Swift中，像Array、Dictinary和Set这样的值类型集合，注意和OC中的NSArray、NSDictionary和NSSet有区别了。当被传递后，将会拷贝一份副本，之前那份数据的变更后面并不会同步更新过来，这点需要注意点。刚开始在这儿按照OC的惯性思维遇到了数据不一致的问题。另外提一句，像Array、Dictionary和Set这些是通过一个叫写时复制 (copy-on-write)的技术实现。<br>（简单提一下：就是为了提供高效的写时复制特性，我们需要知道一个对象 (比如这里的 NSMutableData) 是否是唯一的。如果它是唯一引用，那么我们就可以直接原地修改对象。否则，我们需要在修改前创建对象的复制。）。</p><p>—- 完 —-</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、Swift中的值类型和引用类型&quot;&gt;&lt;a href=&quot;#一、Swift中的值类型和引用类型&quot; class=&quot;headerlink&quot; title=&quot;一、Swift中的值类型和引用类型&quot;&gt;&lt;/a&gt;一、Swift中的值类型和引用类型&lt;/h2&gt;&lt;h3 id=&quot;值类型和引用类型是啥&quot;&gt;&lt;a href=&quot;#值类型和引用类型是啥&quot; class=&quot;headerlink&quot; title=&quot;值类型和引用类型是啥&quot;&gt;&lt;/a&gt;值类型和引用类型是啥&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;最近在用Swift写代码，发现Swift中的值类型和引用类型好像有些奇怪，包括之前了解到的NSArray和Array之间的关系，有些混淆了。现在静下来来学习下，记录一下，防止后面防错。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;首先来回顾一下基础概念：什么是值类型和引用类型。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;值类型：每个实例都拥有数据的一份副本。当被赋值给一个变量或常量，或传递给一个函数时，它都会拷贝一份新的副本。&lt;/li&gt;
&lt;li&gt;引用类型：所有实例共享一个数据副本。当被赋值给一个变量或常量，或传递给一个函数时候，一个引用类型一旦被初始化，会返回一个指向已存在实例的引用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;类(class)是一个引用类型，复制一个引用，即表示建立一个共享的实例。复制之后，两个变量都使用数据中同一份实例。&lt;br&gt;&amp;emsp;&amp;emsp;类(Class)是一个引用类型，意味着类中的变量不会存储实例，而是一个向内存(堆)中存储该实例位置的引用。&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="http://www.lydsnm.top/categories/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift中常见的`$0` `$1`有什么用？</title>
    <link href="http://www.lydsnm.top/2017/09/08/Swift%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84$0%E4%BD%9C%E7%94%A8/"/>
    <id>http://www.lydsnm.top/2017/09/08/Swift中常见的$0作用/</id>
    <published>2017-09-07T16:00:00.000Z</published>
    <updated>2018-11-08T15:36:42.606Z</updated>
    
    <content type="html"><![CDATA[<p><code>$0</code>，<code>$1</code>… 是对闭包中参数的简化写法</p><p>&emsp;&emsp;swift自动为 <b><font color="red">闭包</font></b> 提供参数名缩写功能，可以直接通过<code>$0</code>和<code>$1</code>等来表示闭包中的第一个第二个参数，并且对应的参数类型会根据函数类型来进行判断。如下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用`$0` `$1`这些来代替</span></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>]</span><br><span class="line">        sortNumbers = numbers.sorted(by: &#123; (a, b) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> a &lt; b</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"numbers -"</span> + <span class="string">"\(sortNumbers)"</span>)</span><br><span class="line"><span class="comment">// 使用$0,$1</span></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>]</span><br><span class="line"> <span class="keyword">var</span> sortNumbers = numbers.sorted(by: &#123;$<span class="number">0</span> &lt; $<span class="number">1</span>&#125;)</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">"numbers -"</span> + <span class="string">"\(sortNumbers)"</span>)</span><br></pre></td></tr></table></figure> <a id="more"></a><p>&emsp;&emsp;使用<code>$0</code>、<code>$1</code>的话，参数类型可以自动判断，并且<code>in</code>关键字也可以省略，也就是只用写函数体就可以了。来看看另外个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = &#123; (arg1: <span class="type">Int</span>, arg2: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2</span><br><span class="line">&#125;</span><br><span class="line">add = &#123; (arg1, arg2) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2</span><br><span class="line">&#125;</span><br><span class="line">add = &#123; arg1, arg2 <span class="keyword">in</span></span><br><span class="line">    arg1 + arg2</span><br><span class="line">&#125;</span><br><span class="line">add = &#123;</span><br><span class="line">    $<span class="number">0</span> + $<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = add(<span class="number">10</span>, <span class="number">10</span>) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>—– 完 —–</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;$0&lt;/code&gt;，&lt;code&gt;$1&lt;/code&gt;… 是对闭包中参数的简化写法&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;swift自动为 &lt;b&gt;&lt;font color=&quot;red&quot;&gt;闭包&lt;/font&gt;&lt;/b&gt; 提供参数名缩写功能，可以直接通过&lt;code&gt;$0&lt;/code&gt;和&lt;code&gt;$1&lt;/code&gt;等来表示闭包中的第一个第二个参数，并且对应的参数类型会根据函数类型来进行判断。如下代码：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 不使用`$0` `$1`这些来代替&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; numbers = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sortNumbers = numbers.sorted(by: &amp;#123; (a, b) -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a &amp;lt; b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;numbers -&quot;&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&quot;\(sortNumbers)&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用$0,$1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; numbers = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; sortNumbers = numbers.sorted(by: &amp;#123;$&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;lt; $&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;numbers -&quot;&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&quot;\(sortNumbers)&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="swift" scheme="http://www.lydsnm.top/categories/swift/"/>
    
    
  </entry>
  
  <entry>
    <title>关于术业有专攻的小小感悟</title>
    <link href="http://www.lydsnm.top/2017/09/01/%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%B0%8F%E7%9A%84%E7%BB%8F%E9%AA%8C/"/>
    <id>http://www.lydsnm.top/2017/09/01/一个小小的经验/</id>
    <published>2017-08-31T16:00:00.000Z</published>
    <updated>2018-11-14T11:39:09.690Z</updated>
    
    <content type="html"><![CDATA[<p>那就是 <b><font color="a52a2a" size="5">写些小工具如果要发布，还是和其他专业的人合作比较好一些。</font></b></p><a id="more"></a><p>&emsp;&emsp;最近在做一个项目，在APP的菜单结构犯了难，不知道该用这种比较符合。我的目的是尽量精致而简洁，没有一些花里胡哨的设计内容。<br>&emsp;&emsp;今天突然就想记录一下。也贴出来一些，我觉得还可以的设计。就算不在现在在做的sideProject中用，以后也有用的到的。</p><p>&emsp;&emsp;以前只是了解术业有专攻，每个人都不可能每个方面都擅长。跑道上领先的都是很懂的合作的人<del>~</del>~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;那就是 &lt;b&gt;&lt;font color=&quot;a52a2a&quot; size=&quot;5&quot;&gt;写些小工具如果要发布，还是和其他专业的人合作比较好一些。&lt;/font&gt;&lt;/b&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="http://www.lydsnm.top/categories/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>Slice 一个小而简的Mac计时软件.拖延症神器.倒计时小工具</title>
    <link href="http://www.lydsnm.top/2017/05/30/Slice%E4%B8%80%E4%B8%AA%E5%B0%8F%E8%80%8C%E7%B2%BE%E7%AE%80%E7%9A%84Mac%E8%AE%A1%E6%97%B6%E8%BD%AF%E4%BB%B6%EF%BC%8C%E6%8B%96%E5%BB%B6%E7%97%87%E7%A5%9E%E5%99%A8%EF%BC%8C%E5%80%92%E8%AE%A1%E6%97%B6%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <id>http://www.lydsnm.top/2017/05/30/Slice一个小而精简的Mac计时软件，拖延症神器，倒计时小工具/</id>
    <published>2017-05-29T16:00:00.000Z</published>
    <updated>2018-06-25T14:50:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;对于常年和电脑打交道的人群来说，在很多时候, 人往往变得浮躁, 坐在电脑旁不到几分钟就像打开网页看视频啊, 打开游戏, 干些不相关的东西，专注力不够，从而导致工作效率低，工作质量不高的效果，进而影响到我们的生活，心情等。<br>        现在你试试这个小工具：<br><img src="http://ocs32tleq.bkt.clouddn.com/14961482427792.jpg" alt=""></p><p>&emsp;&emsp;有研究表明，合理的运用人的精力，松紧有弛，能够最大限度的发挥人的能力。自然界本身有它的脉动，一种在活动和休息之间周期性的像波浪一样的运动。想想潮涨潮落、季节变化，以及每天的日出日落。同样，所有的机体都遵循一种维持生命的有规则的变化。就像运动员，我们发现那些成绩好的运动员往往更懂得如何放松和规划自己的精力，在高强度，长时间，高压力的比赛中，很难保持长时间的高水准，因此这些人通常会抓紧一切时间储存精力，等到需要的爆发的时候，集中全部的注意力，更能发挥出好的运动水平，对于普通人，这也同样适用。</p><a id="more"></a><p><img src="http://ocs32tleq.bkt.clouddn.com/%E5%92%96%E5%95%A1.jpg" alt="咖啡"></p><p>&emsp;&emsp;现在针对这种情况，您可以使用Slice这个小工具，别看它小，但是简洁简单有效，可以有效指定完成某项工作要花的时间，让您有一种紧迫感来做事，进而提高注意力提高工作效率。也可以用来控制工作时间，毕竟人的精力精神不会连续好几个小时高度保持注意，懂得平衡的奥秘，累了，渴了不如出去走走，喝喝水，看看远方，说不定工作的难题就在这些休息过程中想到的最佳的解决方案la😄。</p><h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><p><img src="http://ocs32tleq.bkt.clouddn.com/14961479652001.jpg" alt=""></p><p>写好要做的事，订好一个时间，就可以开始啦。</p><p>&emsp;&emsp;还可以做一些小的设置：<br><img src="http://ocs32tleq.bkt.clouddn.com/14961482832008.jpg" alt=""></p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>自定义下一件唯一要做的事，让你专注于工作中…</li><li>自定义提示文字信息。</li><li>可简单控制结束的音效播放。</li><li>CPU 占用率超低, 不会影响您的工作。</li></ul><p>&emsp;&emsp;总之，可以通过Slice，可以平复烦躁杂乱的心，专注于单线程，提升效率。</p><p><br></p><font size="6" color="10d3c4">您唯一要做的事就是自己要遵守自己定的要做的事</font><h3 id="可能遇到的问题："><a href="#可能遇到的问题：" class="headerlink" title="可能遇到的问题："></a>可能遇到的问题：</h3><p>&emsp;&emsp;针对某些用户所说，在10.11以后系统可能安装不了的情况。</p><p>可以在“设置”中“安全与隐私”的“通用”选项下， 设置<b>允许从任何来源的应用</b>。然后就可以正常使用Slice了。<br>因为Slice是本人在业余时间开发，并未上架App store，且OS X系统有这么一个保护机制，故有这样现象。</p><p><img src="http://ocs32tleq.bkt.clouddn.com/PastedGraphic-1-systemSettingforMac.png" alt="系统设置"></p><p>&emsp;&emsp;如果在这个地方没有“任何来源”一项的话，就需要打开系统应用“终端”，输入</p><p><code>sudo spctl --master-disable</code><br>然后再输入你的系统密码回车即可（不屏显）。</p><h3 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a>下载地址：</h3><p><a href="http://pan.baidu.com/s/1mium0J2" target="_blank" rel="noopener">Slice 1.0</a></p><p><br></p><h3 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h3><p>&emsp;&emsp;这个小的app希望对你有用。虽然很小，还还算有用，平时提醒喝喝茶或者短暂休息下。<br>如果你希望能更新此软件的功能，或者有什么建议或者意见，可以通过下面的方式联系我：<br><a href="mailto:dongingdao@163.com" target="_blank" rel="noopener">dongingdao@163.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;对于常年和电脑打交道的人群来说，在很多时候, 人往往变得浮躁, 坐在电脑旁不到几分钟就像打开网页看视频啊, 打开游戏, 干些不相关的东西，专注力不够，从而导致工作效率低，工作质量不高的效果，进而影响到我们的生活，心情等。&lt;br&gt;        现在你试试这个小工具：&lt;br&gt;&lt;img src=&quot;http://ocs32tleq.bkt.clouddn.com/14961482427792.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;有研究表明，合理的运用人的精力，松紧有弛，能够最大限度的发挥人的能力。自然界本身有它的脉动，一种在活动和休息之间周期性的像波浪一样的运动。想想潮涨潮落、季节变化，以及每天的日出日落。同样，所有的机体都遵循一种维持生命的有规则的变化。就像运动员，我们发现那些成绩好的运动员往往更懂得如何放松和规划自己的精力，在高强度，长时间，高压力的比赛中，很难保持长时间的高水准，因此这些人通常会抓紧一切时间储存精力，等到需要的爆发的时候，集中全部的注意力，更能发挥出好的运动水平，对于普通人，这也同样适用。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://www.lydsnm.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="tool" scheme="http://www.lydsnm.top/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>iOS实现实时通信或推送的常用策略</title>
    <link href="http://www.lydsnm.top/2017/04/20/iOS%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E9%80%9A%E4%BF%A1%E6%88%96%E6%8E%A8%E9%80%81%E7%9A%84%E5%B8%B8%E7%94%A8%E7%AD%96%E7%95%A5/"/>
    <id>http://www.lydsnm.top/2017/04/20/iOS实现实时通信或推送的常用策略/</id>
    <published>2017-04-19T16:00:00.000Z</published>
    <updated>2018-03-04T15:42:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-iOS静默推送，不含alert，没有声音没有弹框，具体更多可以看这儿"><a href="#1-iOS静默推送，不含alert，没有声音没有弹框，具体更多可以看这儿" class="headerlink" title="1.iOS静默推送，不含alert，没有声音没有弹框，具体更多可以看这儿"></a>1.iOS静默推送，不含alert，没有声音没有弹框，具体更多可以看<a href="http://blog.csdn.net/hherima/article/details/50469519" target="_blank" rel="noopener">这儿</a></h3><p>限制与注意：<br><code>Silent Remote Notifications</code>是在Apple的限制下有一定的频率控制，并不是所有的静默推送都能按预期到达客户端触发函数的。<br>前提：客户端需处于Background或Suspended状态。<br>Apple 官方文档说：<a href="https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html" target="_blank" rel="noopener">Configuring a Silent Notification</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Silent notifications are not meant as a way to keep your app awake in the background, nor are they meant for high priority updates. APNs treats silent notifications as low priority and may throttle their delivery altogether if the total number becomes excessive. The actual limits are dynamic and can change based on conditions, but try not to send more than a few notifications per hour.</span><br></pre></td></tr></table></figure><p>用户如果禁止了推送权限，还能收到静默推送吗？这将是一个问题。</p><a id="more"></a><h3 id="2-轮询"><a href="#2-轮询" class="headerlink" title="2.轮询"></a>2.轮询</h3><p>1.Http polling<br>2.Http Long-polling</p><blockquote><p>Http polling也就是轮询的策略，它唯一的优点就是实现简单，技术门槛低。但是缺点也很明显：不够实时，且效率低下，导致server端负载较高。</p></blockquote><blockquote><p>Http Long-polling（长轮询，也称作comet）技术，是在Http polling基础上优化而来。在长轮询策略下，当server端没有数据推送到client端时，请求不会立即返回，而是被server端hold住，直到有数据发送，或者超时，才发送响应。Client端收到响应之后，立即重新发起http请求。<br>这种策略比简单的轮询优化了许多，但开发和维护成本也提高了许多。并且，效率还不够高，存在资源的浪费。而这主要是因为http协议头本身带来的overhead。</p></blockquote><h3 id="3-长连接"><a href="#3-长连接" class="headerlink" title="3.长连接"></a>3.长连接</h3><blockquote><p>Socket长连接是目前认为优点最多的解决方案。这一方案的原理是client端向server端建立一个TCP长连接，通过心跳的机制维护连接畅通，当有数据需要交互时，双方都可以通过这个长连接进行通信。</p></blockquote><blockquote><p>多年前这种方案无法应用在浏览器端，然而随着html5的兴起和浏览器的发展，目前主流的浏览器都已经支持websocket了，可以很好的实现长连接。</p></blockquote><blockquote><p>Socket长连接是最理想的方案，但开发成本也相应的最高。服务端需要支持大量的连接数，且长连接本身的特性也决定了服务不再是无状态的，这给服务的稳定性和可扩展性带来了一定的挑战。</p></blockquote><h2 id="评估："><a href="#评估：" class="headerlink" title="评估："></a>评估：</h2><p>从成本来说，客户端轮询请求 服务器压力最小，但是不太敏感<br>tcp长连接呢，服务器压力大些，但是消息及时。</p><p>iOS如果要用socket长连接的话，可以用<a href="http://www.cocoachina.com/ios/20160602/16572.html" target="_blank" rel="noopener">这篇文章</a>提到的<a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="noopener">CocoaAsyncSocket</a></p><p>可以用<code>CocoaAsyncSocket</code>先写一个<a href="http://www.cnblogs.com/XYQ-208910/p/5169209.html" target="_blank" rel="noopener">Demo</a></p><p>如果想了解更多CocoaAsyncSocket可以从这篇文章入手：<a href="http://www.cocoachina.com/ios/20170127/18619.html" target="_blank" rel="noopener">iOS即时通讯进阶 - CocoaAsyncSocket源码解析(Connect篇)</a></p><p>备选：<a href="https://github.com/facebook/SocketRocket" target="_blank" rel="noopener">SocketRocket</a></p><hr><p>— 备注区，不算入文章内。</p><ul><li>其他</li></ul><p>&emsp;&emsp;建立tcp连接，定期发keep alive防止socket超时断开。发消息直接发tcp数据包。<br>或者直接用第三方的push notification服务。原理类似，只不过平台统一keep alive省电。需要注册在服务提供方注册。</p><p>&emsp;&emsp;服务端给客户端推送，普遍做法是客户端与服务端维持一个长连接，客户端定时向服务端发送心跳以维持这个长连接。当有新消息过来的时候，服务端查出该消息对应的TCP Channel的ID并找到对应的通道进行消息下发。</p><p>&emsp;&emsp;国内安卓应用，如果没有使用GCM，绝大多数没有使用，那就起后台Service定时唤醒系统查询，一个是为了保持心跳，一个是为了查询消息。这种机制非常浪费运营商的资源，也非常费电。所以，建议把所有的应用设置都看清楚，尽量选择非推送。尤其是天气预报，手工查一下就行了，否则，那个所谓的墨迹天气，5分钟查一次，频率比得上微信了。完全没有必要，太费电了。要是赶上小区拥堵的情况，频繁的PDP激活，建立RRC连接，再释放，电池消耗特别大。而且还会发热，用户体验会很糟糕。</p><p>&emsp;&emsp;连接都是由客户端发起的！（因为客户端通常在子网下，没有公网IP，根本没办法接受连接）所谓『推送』的实现方式无外乎两种：一是基于长连接，客户端发起连接，双方维护这个连接，服务器端有变动随时拿这个连接通知客户端。这就是正常意义上的『推送』。二是基于短连接，客户端轮询发起短连接，询问服务器端变化。这实际上是『拉取』，并不是『推送』。燃鹅，维护连接的成本太大了，除了即时性要求苛刻的场景之外，大家普遍采用了第二种方法。</p><h3 id="iOS中应用内部实现长连接发送接受机制。"><a href="#iOS中应用内部实现长连接发送接受机制。" class="headerlink" title="iOS中应用内部实现长连接发送接受机制。"></a>iOS中应用内部实现长连接发送接受机制。</h3><ol><li>基于Http的长连接。（用的比较少）</li><li>基于Socket的长连接。</li><li>基于xmpp的消息P2P消息机制</li></ol><p>貌似普通的socket连接对服务器的消耗太大了。（是否有其他协议，比较有名的是MQTT协议）</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-iOS静默推送，不含alert，没有声音没有弹框，具体更多可以看这儿&quot;&gt;&lt;a href=&quot;#1-iOS静默推送，不含alert，没有声音没有弹框，具体更多可以看这儿&quot; class=&quot;headerlink&quot; title=&quot;1.iOS静默推送，不含alert，没有声音没有弹框，具体更多可以看这儿&quot;&gt;&lt;/a&gt;1.iOS静默推送，不含alert，没有声音没有弹框，具体更多可以看&lt;a href=&quot;http://blog.csdn.net/hherima/article/details/50469519&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这儿&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;限制与注意：&lt;br&gt;&lt;code&gt;Silent Remote Notifications&lt;/code&gt;是在Apple的限制下有一定的频率控制，并不是所有的静默推送都能按预期到达客户端触发函数的。&lt;br&gt;前提：客户端需处于Background或Suspended状态。&lt;br&gt;Apple 官方文档说：&lt;a href=&quot;https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Configuring a Silent Notification&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Silent notifications are not meant as a way to keep your app awake in the background, nor are they meant for high priority updates. APNs treats silent notifications as low priority and may throttle their delivery altogether if the total number becomes excessive. The actual limits are dynamic and can change based on conditions, but try not to send more than a few notifications per hour.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;用户如果禁止了推送权限，还能收到静默推送吗？这将是一个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.lydsnm.top/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://www.lydsnm.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>对UIMenuController菜单自定义</title>
    <link href="http://www.lydsnm.top/2017/02/06/%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89UIWebView%20%E7%9A%84UIMenuController%E9%80%89%E9%A1%B9/"/>
    <id>http://www.lydsnm.top/2017/02/06/实现自定义UIWebView 的UIMenuController选项/</id>
    <published>2017-02-05T16:00:00.000Z</published>
    <updated>2018-03-04T15:42:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;项目中遇到了需要对UIWebView中弹出菜单的一些定制，所以查找一些资料，整理记录一下。</p><p>首先看看UIMenuController默认支持的方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)cut:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)<span class="keyword">copy</span>:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)paste:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)select:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)selectAll:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)delete:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_2);</span><br><span class="line">- (<span class="keyword">void</span>)makeTextWritingDirectionLeftToRight:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)makeTextWritingDirectionRightToLeft:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)toggleBoldface:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)toggleItalics:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)toggleUnderline:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)increaseSize:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)decreaseSize:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更多带_的私有方法可以看: https://yq.aliyun.com/articles/39475</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>而我们常用的是<code>cut</code>，<code>copyt</code>，<code>past</code>，<code>selct</code>等。因此主要是对这几个方法的处理。</p><h3 id="实现自定义菜单（UITextView、UITextField）"><a href="#实现自定义菜单（UITextView、UITextField）" class="headerlink" title="实现自定义菜单（UITextView、UITextField）"></a>实现自定义菜单（UITextView、UITextField）</h3><p>&emsp;&emsp;要想实现自定义显示的长按文字菜单, subClass UIWebViewController. 然后重写方法:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">BOOL</span>)canPerformAction:(SEL)action withSender:(<span class="keyword">id</span>)sender&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">@selector</span>(selectAll:) || action == <span class="keyword">@selector</span>(cut:)\</span><br><span class="line">        || action == <span class="keyword">@selector</span>(delete:)\</span><br><span class="line">        || action == <span class="keyword">@selector</span>(toggleUnderline:)\</span><br><span class="line">        || action == <span class="keyword">@selector</span>(toggleBoldface:)\</span><br><span class="line">        || action == <span class="keyword">@selector</span>(toggleItalics:)\</span><br><span class="line">        || action == <span class="built_in">NSSelectorFromString</span>(<span class="string">@"_showTextStyleOptions:"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> canPerformAction:action withSender:sender];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可编辑的UIWebView自定义UIMenuController选项"><a href="#可编辑的UIWebView自定义UIMenuController选项" class="headerlink" title="可编辑的UIWebView自定义UIMenuController选项"></a>可编辑的UIWebView自定义UIMenuController选项</h3><p>&emsp;&emsp;前期尝试过创建UIWebView之类, 然后重写<code>canPerformAction:(SEL)action withSender:(id)sender</code>方法来控制显示和隐藏哪些菜单项, 但是发现不行(UITextView等可以)。查看UIWebView的subViews, 可以发现一个类: <font color="a52a2a">UIWebBrowserView</font>which has a text property, from this we know what class we need to subclass.然而这个UIWebBrowserView又是一个私有类,通过正常方式又获取不到.<br>思路有两个: 一个是通过运行时替换这个class的方法成我们自己的方法。二是通过创建<code>UIWebBrowserView</code>的类别，并用我们的方法替换掉原来的方法(私有API,传App Store会被打回)。</p><hr><h4 id="1-通过runtime替换方法"><a href="#1-通过runtime替换方法" class="headerlink" title="1. 通过runtime替换方法"></a>1. 通过runtime替换方法</h4><p>添加方法<code>mightPerformAction:withSender:</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)mightPerformAction:(SEL)action withSender:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"******Action!! %@******"</span>,<span class="built_in">NSStringFromSelector</span>(action));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (action == <span class="keyword">@selector</span>(<span class="keyword">copy</span>:))</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"Copy Selector"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (action == <span class="keyword">@selector</span>(cut:))</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"cut Selector"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (action == <span class="built_in">NSSelectorFromString</span>(<span class="string">@"_define:"</span>))</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"define Selector"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (action == <span class="keyword">@selector</span>(paste:))</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"paste Selector"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">return</span> [<span class="keyword">super</span> canPerformAction:action withSender:sender];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是替换旧的<code>canPerformAction:action withSender:sender</code>方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) replaceUIWebBrowserView: (<span class="built_in">UIView</span> *)view</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Iterate through subviews recursively looking for UIWebBrowserView</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">UIView</span> *sub <span class="keyword">in</span> view.subviews) &#123;</span><br><span class="line">    [<span class="keyword">self</span> replaceUIWebBrowserView:sub];</span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSStringFromClass</span>([sub <span class="keyword">class</span>]) isEqualToString:<span class="string">@"UIWebBrowserView"</span>]) &#123;</span><br><span class="line"></span><br><span class="line">        Class <span class="keyword">class</span> = sub.class;</span><br><span class="line"></span><br><span class="line">        SEL originalSelector = <span class="keyword">@selector</span>(canPerformAction:withSender:);</span><br><span class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(mightPerformAction:withSender:);</span><br><span class="line"></span><br><span class="line">        Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(<span class="keyword">self</span>.class, swizzledSelector);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//add the method mightPerformAction:withSender: to UIWebBrowserView</span></span><br><span class="line">        <span class="built_in">BOOL</span> didAddMethod =</span><br><span class="line">        class_addMethod(<span class="keyword">class</span>,</span><br><span class="line">                        originalSelector,</span><br><span class="line">                        method_getImplementation(swizzledMethod),</span><br><span class="line">                        method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        <span class="comment">//replace canPerformAction:withSender: with mightPerformAction:withSender:</span></span><br><span class="line">        <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">            class_replaceMethod(<span class="keyword">class</span>,</span><br><span class="line">                                swizzledSelector,</span><br><span class="line">                                method_getImplementation(originalMethod),</span><br><span class="line">                                method_getTypeEncoding(originalMethod));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在ViewController的viewDidLoad中调用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> replaceUIWebBrowserView:<span class="keyword">self</span>.webView];</span><br></pre></td></tr></table></figure><blockquote><p>注意1: 在viewController中添加 #import &lt;objc/runtime.h&gt; 避免 error(Method).</p></blockquote><blockquote><p>注意2:  使用<code>NSSelectorFromString</code>方法避免审核过程中被检测到使用到了私有API.</p></blockquote><p>参考: <a href="http://stackoverflow.com/questions/25263687/disable-long-press-menu-in-text-area-input-uiwebview/25263688#25263688" target="_blank" rel="noopener">http://stackoverflow.com/questions/25263687/disable-long-press-menu-in-text-area-input-uiwebview/25263688#25263688</a> </p><h4 id="2-通过扩展类别"><a href="#2-通过扩展类别" class="headerlink" title="2.通过扩展类别"></a>2.通过扩展类别</h4><p>另外在查找资料的过程中还发现种方法(UIWebBrowserView), 但是这种方法使用到了私有api, 会被打回. 切记:<br><a href="http://www.ios-blog.co.uk/tutorials/rich-text-editing-highlighting-and-uimenucontroller-part-3/" target="_blank" rel="noopener">http://www.ios-blog.co.uk/tutorials/rich-text-editing-highlighting-and-uimenucontroller-part-3/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;项目中遇到了需要对UIWebView中弹出菜单的一些定制，所以查找一些资料，整理记录一下。&lt;/p&gt;
&lt;p&gt;首先看看UIMenuController默认支持的方法：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)cut:(&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;:(&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)paste:(&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)select:(&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)selectAll:(&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)delete:(&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;_2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)makeTextWritingDirectionLeftToRight:(&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)makeTextWritingDirectionRightToLeft:(&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)toggleBoldface:(&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)toggleItalics:(&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)toggleUnderline:(&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)increaseSize:(&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)decreaseSize:(&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &lt;span class=&quot;built_in&quot;&gt;NS_AVAILABLE_IOS&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;_0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 更多带_的私有方法可以看: https://yq.aliyun.com/articles/39475&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.lydsnm.top/categories/iOS/"/>
    
    
      <category term="-runtime -运行时" scheme="http://www.lydsnm.top/tags/runtime-%E8%BF%90%E8%A1%8C%E6%97%B6/"/>
    
  </entry>
  
  <entry>
    <title>OC开发相关注意事项</title>
    <link href="http://www.lydsnm.top/2016/10/20/OC%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%9B%9B/"/>
    <id>http://www.lydsnm.top/2016/10/20/OC开发相关注意事项四/</id>
    <published>2016-10-19T16:00:00.000Z</published>
    <updated>2018-08-30T14:36:56.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第7章-熟悉系统框架"><a href="#第7章-熟悉系统框架" class="headerlink" title="第7章 熟悉系统框架"></a>第7章 熟悉系统框架</h2><p>将一系列代码封装为动态库 (dynamic library) , 并在其中放入描述其借口的头文件, 这样做出来的东西就叫 <font color="a52a2a">框架</font> .有时为 iOS 平台构建的第三方框架实用的是静态库 (static libaray), 这是因为 iOS 应用程序不允许在其中包含动态库.</p><p>开发者主要会碰到<code>Foundation</code>, 像是 <code>NSOject</code>, <code>NSArray</code>, <code>NSDictionary</code> 等类都在其中, <code>Foundation</code> 是应用程序的 “基础”.</p><p>还有个与 <code>Foundation</code> 相伴的框架, 叫做 <code>CoreFoundation</code> , 从技术上来将, <code>CoreFoundation</code> 框架不是 <code>Objective-C</code> 框架, 但它是编写 <code>Objective-C</code> 应用程序时所应熟悉的重要框架. <code>Foundation</code> 框架中的很多功能, 都可以在此框架中找到对应的 C 语言 API. 可以用”无缝桥接”(tollfree bridging). 可以吧 <code>CoreFoundation</code> 中的 C 语言数据结构平滑转换为 <code>Foundation</code>中的 Objective-C 对象.</p><p>除了<code>Foundation</code> 还有 <code>CFNetwork</code> , <code>CoreAudio</code>, <code>AVFoundation</code>, <code>CoreData</code>, <code>CoreText</code> ….</p><a id="more"></a><p><br></p><h3 id="1-构建缓存时选用-NSCache-而非-NSDictionary"><a href="#1-构建缓存时选用-NSCache-而非-NSDictionary" class="headerlink" title="1. 构建缓存时选用 NSCache 而非 NSDictionary"></a>1. 构建缓存时选用 <code>NSCache</code> 而非 <code>NSDictionary</code></h3><p>因为 <code>NSCache</code> 可以提供优雅的自动删减功能, 而且是 “线程安全的”. 此外, 它与字典不同, 不会拷贝键.<br>可以给 <code>NSCache</code> 对象设置上限, 用以限制缓存中的对象总个数及”总成本”<br>将 <code>NSPurgeableData</code> 与 <code>NSCache</code> 搭配使用, 可实现自动清除数据的功能.</p><h3 id="2-loadView-amp-initialize"><a href="#2-loadView-amp-initialize" class="headerlink" title="2. loadView &amp; initialize"></a>2. <code>loadView</code> &amp; <code>initialize</code></h3><p><code>loadView</code> &amp; <code>initialize</code> 中的代码要尽量精简.这有助于保持应用程序的响应能力, 也能减少引入 “依赖环” 的几率.</p><p><code>initialize</code>是惰性调用的, 只有当程序用到了相关的类时, 才会调用. 而对于<code>loadView</code>来说, 应用程序必须阻塞并等着所有类的 load 都执行万, 才能继续.</p><p><code>initialize</code>方法 只应该用来设置内部数据.</p><ul><li>在加载阶段, 如果类实现了 load 方法, 那么系统就会调用它. 分类里也可以定义此方法, 类的 load 方法要比分类中的先调用.</li><li>首次实用某个类之前, 系统会向其发送 <code>initialize</code> 消息. 由于此方法遵从普通的覆写规则, 所以通常应该在里面判断当前要初始化的是哪个类.</li><li>无法在编译期设定的全局常量, 可以放在 <code>initialize</code> 方法里初始化.</li></ul><h3 id="3-NSTimer-会保留其目标对象"><a href="#3-NSTimer-会保留其目标对象" class="headerlink" title="3. NSTimer 会保留其目标对象."></a>3. NSTimer 会保留其目标对象.</h3><p>记得 手动调用或 <code>delloc</code> 方法中调用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[_timer invalidate];</span><br><span class="line">_timer = <span class="literal">nil</span>;</span><br></pre></td></tr></table></figure><p>反复执行任务的计时器, 很容易引入保留环.</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>快速遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(for ... in ...)</span><br></pre></td></tr></table></figure></p><hr><p><br></p><p>本篇文章参考摘自 <font color="#B8860B">Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的52个有效方法</font></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第7章-熟悉系统框架&quot;&gt;&lt;a href=&quot;#第7章-熟悉系统框架&quot; class=&quot;headerlink&quot; title=&quot;第7章 熟悉系统框架&quot;&gt;&lt;/a&gt;第7章 熟悉系统框架&lt;/h2&gt;&lt;p&gt;将一系列代码封装为动态库 (dynamic library) , 并在其中放入描述其借口的头文件, 这样做出来的东西就叫 &lt;font color=&quot;a52a2a&quot;&gt;框架&lt;/font&gt; .有时为 iOS 平台构建的第三方框架实用的是静态库 (static libaray), 这是因为 iOS 应用程序不允许在其中包含动态库.&lt;/p&gt;
&lt;p&gt;开发者主要会碰到&lt;code&gt;Foundation&lt;/code&gt;, 像是 &lt;code&gt;NSOject&lt;/code&gt;, &lt;code&gt;NSArray&lt;/code&gt;, &lt;code&gt;NSDictionary&lt;/code&gt; 等类都在其中, &lt;code&gt;Foundation&lt;/code&gt; 是应用程序的 “基础”.&lt;/p&gt;
&lt;p&gt;还有个与 &lt;code&gt;Foundation&lt;/code&gt; 相伴的框架, 叫做 &lt;code&gt;CoreFoundation&lt;/code&gt; , 从技术上来将, &lt;code&gt;CoreFoundation&lt;/code&gt; 框架不是 &lt;code&gt;Objective-C&lt;/code&gt; 框架, 但它是编写 &lt;code&gt;Objective-C&lt;/code&gt; 应用程序时所应熟悉的重要框架. &lt;code&gt;Foundation&lt;/code&gt; 框架中的很多功能, 都可以在此框架中找到对应的 C 语言 API. 可以用”无缝桥接”(tollfree bridging). 可以吧 &lt;code&gt;CoreFoundation&lt;/code&gt; 中的 C 语言数据结构平滑转换为 &lt;code&gt;Foundation&lt;/code&gt;中的 Objective-C 对象.&lt;/p&gt;
&lt;p&gt;除了&lt;code&gt;Foundation&lt;/code&gt; 还有 &lt;code&gt;CFNetwork&lt;/code&gt; , &lt;code&gt;CoreAudio&lt;/code&gt;, &lt;code&gt;AVFoundation&lt;/code&gt;, &lt;code&gt;CoreData&lt;/code&gt;, &lt;code&gt;CoreText&lt;/code&gt; ….&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.lydsnm.top/categories/iOS/"/>
    
    
      <category term="OC" scheme="http://www.lydsnm.top/tags/OC/"/>
    
  </entry>
  
  <entry>
    <title>OC开发相关注意事项</title>
    <link href="http://www.lydsnm.top/2016/10/19/OC%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%89/"/>
    <id>http://www.lydsnm.top/2016/10/19/OC开发相关注意事项三/</id>
    <published>2016-10-18T16:00:00.000Z</published>
    <updated>2018-08-30T14:37:42.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>ARC :<code>Automatic Reference Counting,ARC</code>, ARC 几乎把所有内存管理事宜都交由编译器来决定, 开发者只需专注于业务逻辑.</p><h3 id="1-引用计数"><a href="#1-引用计数" class="headerlink" title="1. 引用计数"></a>1. 引用计数</h3><p>Objective-C 语言实用引用计数来管理内存. 每个对象都有个可以递增和递减的计数器, 用以标识当前有多个事情想令此对象继续存活下去.<br>计数<font color="#A52A2a">>=0</font>表示对象继续存活. 当保留计数降为<font color="#A52A2a"> 0 </font>后, 对象就会被释放了.</p><p>ARC 只负责管理 <code>Objective-C</code> 对象的内存. 注意: <font color="#A52A2a">CoreFoundation</font>对象不归 ARC 管理, 开发者必须适时调用 <font color="#A52A2a">CFRetain/CFRelease</font>.</p><h3 id="2-在-dealloc-方法中只释放引用并解除监听"><a href="#2-在-dealloc-方法中只释放引用并解除监听" class="headerlink" title="2. 在 dealloc 方法中只释放引用并解除监听"></a>2. 在 dealloc 方法中只释放引用并解除监听</h3><p>对象在经历其生命周期后, 最终会为系统所回收, 这时就要执行 <code>dealloc</code> 方法了. 在每个对象的生命周期内, 此方法仅执行以此. 也就是但保留计数降为 0 的时候.</p><p>虽说应该于 <code>dealloc</code> 中释放引用, 但是开销较大或系统内稀缺的资源则不在此列 ,像是文件描述符( file descriptor ), 套接字 (socket), 大块内存等都属于这种资源. 不能指望 <code>dealloc</code> 方法必定会在某个特定的时机调用, 因为有一些无法预料的东西可能也会持有此对象. 在这种情况下, 如果非要等到系统调用 <code>dealloc</code> 方法时才释放, 那么保留这些稀缺资源的时间就太长了, 这么做不合适. 通常的做法时, 实现另外一个方法, 但应用程序用完资源对象后, 就调用此方法 (例如 <font color="#A52A2a">Open</font> 对应 <font color="#A52A2a">Close</font> 方法) . 这样一来, 资源对象的生命期就变得更明确了.</p><a id="more"></a><h3 id="3-以-“自动释放池块”-降低内存峰值"><a href="#3-以-“自动释放池块”-降低内存峰值" class="headerlink" title="3. 以 “自动释放池块” 降低内存峰值"></a>3. 以 “自动释放池块” 降低内存峰值</h3><p>在 Objective-C 的引用计数架构中, 有一项特性叫做 “<font color="#A52A2a">自动释放池</font>“ (autorelease pool). 释放对象有两种方式: 一种时调用 <code>release</code> 方法, 另一种时调用 <code>autorelease</code> 方法, 将其降入 “自动释放池” 中. 自动释放池用于存放那些需要在稍后某个时刻释放的对象. 清空(drain)自动释放池时, 系统会向其中的对象发送 <code>release</code> 消息.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)&#123;</span><br><span class="line">[<span class="keyword">self</span> doSomethingWithInt:i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <font color="#A52A2a">自动释放池</font> 来降低应用程序的 <font color="#A52A2a">峰值内存</font>.</p><p><br></p><hr><h2 id="block与GCD"><a href="#block与GCD" class="headerlink" title="block与GCD"></a>block与GCD</h2><p>GCD 是一种与块有关的计数, 它提供了对线程的抽象, 而这种抽象则机遇 “派发队列”(<code>dispatch queue</code>). 开发者可将块排入队列中, 由 GCD 负责处理所有调度事宜.</p><h3 id="1-block"><a href="#1-block" class="headerlink" title="1. block"></a>1. block</h3><p>每个 Objective-C 对象都占据着某个内存区域. 因为实例变量的个数及对象所包含的关联数据不同, 所以每个对象所占的内存区域也有大有小. 块对象也是对象, 在存放块对象的内存区域中, 首个变量时指向 Class 对象的指针, 该指针叫做 <font color="A52A2A">isa</font> .其余内存里含有块对象正常运转所需的各种信息.</p><p><img src="http://ocs32tleq.bkt.clouddn.com/blockMemory.png" alt="块对象的内存布局"></p><p>在内存布局中, 最重要的时 <font color="a52a2a">invoke</font> 变量, 这是个函数指针, 指向块的实现代码. 块其实就是一种代替函数指针的语法结构.</p><p>定义块的时候, 其所占的内存是分配在 <font color="a52a2a">栈 </font>中的. 块只在定义它的那个范围有效. 编译器有可能把分配给块的内存覆写掉. 给 block 对象发送 copy 消息拷贝, 就拷贝到堆上, 块就成了带引用计数的对象了.后续的复制操作都不会真的执行复制, 只是增加对象的引用计数.</p><h3 id="2-GCD"><a href="#2-GCD" class="headerlink" title="2. GCD"></a>2. GCD</h3><p>少用 <code>performSelector</code> 系列方法, 用 GCD 相关方法来实现.</p><ul><li>通过 <code>Dispatch Group</code> 机制, 根据系统资源状况来执行任务.一系列任务可关于一个 <code>dispatch group</code> 中. 开发者可以再这组任务执行完毕时获得通知.</li></ul><p>使用下面这个函数可以创建 <code>dispatch group</code>:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_tdispatch_group_create();</span><br></pre></td></tr></table></figure><p>另外可选 使用 <code>dispatch_apply</code> 方法, 此函数会将块仿佛执行一定的次数, 每次传给块的参数值都会递增..</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIRITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">dispatch_apply(array.count, queue, ^(size_t i)&#123;</span><br><span class="line"><span class="keyword">id</span> object = array[i];</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而, <code>dispatch_apply</code> 会持续阻塞队列, 直到所有任务都执行完毕为止. 若想到后台执行任务, 则应使用 <code>dispatch group</code></p><p>更多内容请看我的另外一篇 : <a href="http://www.donglyu.com/2016/02/08/GCD处理多个异步处理的同步方法/" target="_blank" rel="noopener">GCD 多任务</a></p><ul><li>使用 <code>dispatch_once</code> 来执行只需运行以此的线程安全代码.<br>单例模式中使用的多.</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)sharedInstance&#123;</span><br><span class="line"><span class="keyword">static</span> EOCClass *sharedInstance = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">shareInstance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li>调试内存管理问题时, 可以将 <font color="#A52A2a">NSZombieEnabled</font> 环境变量设为 YES . 给僵尸对象(应该是是否的对象, 不应再被调用) 发送消息, 控制台会打印消息, 应用程序会终止.</li></ul><hr><p><br></p><p>本篇文章参考摘自 <font color="#B8860B">Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的52个有效方法</font></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理&quot;&gt;&lt;a href=&quot;#内存管理&quot; class=&quot;headerlink&quot; title=&quot;内存管理&quot;&gt;&lt;/a&gt;内存管理&lt;/h2&gt;&lt;p&gt;ARC :&lt;code&gt;Automatic Reference Counting,ARC&lt;/code&gt;, ARC 几乎把所有内存管理事宜都交由编译器来决定, 开发者只需专注于业务逻辑.&lt;/p&gt;
&lt;h3 id=&quot;1-引用计数&quot;&gt;&lt;a href=&quot;#1-引用计数&quot; class=&quot;headerlink&quot; title=&quot;1. 引用计数&quot;&gt;&lt;/a&gt;1. 引用计数&lt;/h3&gt;&lt;p&gt;Objective-C 语言实用引用计数来管理内存. 每个对象都有个可以递增和递减的计数器, 用以标识当前有多个事情想令此对象继续存活下去.&lt;br&gt;计数&lt;font color=&quot;#A52A2a&quot;&gt;&gt;=0&lt;/font&gt;表示对象继续存活. 当保留计数降为&lt;font color=&quot;#A52A2a&quot;&gt; 0 &lt;/font&gt;后, 对象就会被释放了.&lt;/p&gt;
&lt;p&gt;ARC 只负责管理 &lt;code&gt;Objective-C&lt;/code&gt; 对象的内存. 注意: &lt;font color=&quot;#A52A2a&quot;&gt;CoreFoundation&lt;/font&gt;对象不归 ARC 管理, 开发者必须适时调用 &lt;font color=&quot;#A52A2a&quot;&gt;CFRetain/CFRelease&lt;/font&gt;.&lt;/p&gt;
&lt;h3 id=&quot;2-在-dealloc-方法中只释放引用并解除监听&quot;&gt;&lt;a href=&quot;#2-在-dealloc-方法中只释放引用并解除监听&quot; class=&quot;headerlink&quot; title=&quot;2. 在 dealloc 方法中只释放引用并解除监听&quot;&gt;&lt;/a&gt;2. 在 dealloc 方法中只释放引用并解除监听&lt;/h3&gt;&lt;p&gt;对象在经历其生命周期后, 最终会为系统所回收, 这时就要执行 &lt;code&gt;dealloc&lt;/code&gt; 方法了. 在每个对象的生命周期内, 此方法仅执行以此. 也就是但保留计数降为 0 的时候.&lt;/p&gt;
&lt;p&gt;虽说应该于 &lt;code&gt;dealloc&lt;/code&gt; 中释放引用, 但是开销较大或系统内稀缺的资源则不在此列 ,像是文件描述符( file descriptor ), 套接字 (socket), 大块内存等都属于这种资源. 不能指望 &lt;code&gt;dealloc&lt;/code&gt; 方法必定会在某个特定的时机调用, 因为有一些无法预料的东西可能也会持有此对象. 在这种情况下, 如果非要等到系统调用 &lt;code&gt;dealloc&lt;/code&gt; 方法时才释放, 那么保留这些稀缺资源的时间就太长了, 这么做不合适. 通常的做法时, 实现另外一个方法, 但应用程序用完资源对象后, 就调用此方法 (例如 &lt;font color=&quot;#A52A2a&quot;&gt;Open&lt;/font&gt; 对应 &lt;font color=&quot;#A52A2a&quot;&gt;Close&lt;/font&gt; 方法) . 这样一来, 资源对象的生命期就变得更明确了.&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.lydsnm.top/categories/iOS/"/>
    
    
      <category term="OC" scheme="http://www.lydsnm.top/tags/OC/"/>
    
  </entry>
  
  <entry>
    <title>本地推送之定时推送</title>
    <link href="http://www.lydsnm.top/2016/10/18/%E6%9C%AC%E5%9C%B0%E6%8E%A8%E9%80%81%E4%B9%8B%E5%AE%9A%E6%97%B6%E6%8E%A8%E9%80%81/"/>
    <id>http://www.lydsnm.top/2016/10/18/本地推送之定时推送/</id>
    <published>2016-10-17T16:00:00.000Z</published>
    <updated>2018-03-04T05:52:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>项目中使用到了定时提醒推送, 故整理记录下来.</p><h2 id="iOS10-之前-使用旧的本地推送注册方式"><a href="#iOS10-之前-使用旧的本地推送注册方式" class="headerlink" title="iOS10 之前, 使用旧的本地推送注册方式:"></a>iOS10 之前, 使用旧的本地推送注册方式:</h2><h3 id="1-在-AppDelegate中代理注册使用通知-和注册远程通知一致"><a href="#1-在-AppDelegate中代理注册使用通知-和注册远程通知一致" class="headerlink" title="1. 在 AppDelegate中代理注册使用通知, 和注册远程通知一致"></a>1. 在 <code>AppDelegate</code>中代理注册使用通知, 和注册远程通知一致</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIMutableUserNotificationCategory</span> *categorys = [[<span class="built_in">UIMutableUserNotificationCategory</span> alloc] init];</span><br><span class="line"><span class="built_in">UIUserNotificationSettings</span> *userSettings = [<span class="built_in">UIUserNotificationSettings</span> settingsForTypes:<span class="built_in">UIUserNotificationTypeBadge</span>|<span class="built_in">UIUserNotificationTypeSound</span>|<span class="built_in">UIUserNotificationTypeAlert</span></span><br><span class="line">                                                                                    categories:[<span class="built_in">NSSet</span> setWithObject:categorys]];</span><br><span class="line">[[<span class="built_in">UIApplication</span> sharedApplication] registerUserNotificationSettings:userSettings];</span><br><span class="line">[[<span class="built_in">UIApplication</span> sharedApplication] registerForRemoteNotifications];</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-注册本地推送-在固定时间推送通知"><a href="#2-注册本地推送-在固定时间推送通知" class="headerlink" title="2. 注册本地推送,在固定时间推送通知"></a>2. 注册本地推送,在固定时间推送通知</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)RegisterLocalNotificationiOS10Before:(<span class="built_in">NSDate</span> *)time&#123;</span><br><span class="line">    <span class="built_in">UILocalNotification</span> *notification = [[<span class="built_in">UILocalNotification</span> alloc] init];</span><br><span class="line">    <span class="comment">// 设置触发通知的时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    NSDate *fireDate = [NSDate dateWithTimeIntervalSinceNow:10];</span></span><br><span class="line">    notification.fireDate = time; <span class="comment">// fireDate</span></span><br><span class="line">    <span class="comment">// 时区</span></span><br><span class="line">    notification.timeZone = [<span class="built_in">NSTimeZone</span> defaultTimeZone];</span><br><span class="line">    <span class="comment">// 设置重复的间隔</span></span><br><span class="line">    notification.repeatInterval = kCFCalendarUnitDay; <span class="comment">// 每天提醒.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知内容</span></span><br><span class="line">    notification.alertTitle = <span class="string">@"时光匆匆，我只在乎你"</span>;</span><br><span class="line">    notification.alertBody = <span class="string">@"今天有什么想要记录和分享吗？"</span>; </span><br><span class="line">    notification.applicationIconBadgeNumber = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 通知被触发时播放的声音</span></span><br><span class="line">    notification.soundName = <span class="built_in">UILocalNotificationDefaultSoundName</span>;</span><br><span class="line">    <span class="comment">// 通知参数</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *userDict = [<span class="built_in">NSDictionary</span> dictionaryWithObject:LPVMNoticeEveryDayKey forKey:LPVMNoticeEveryDayKey];</span><br><span class="line">    notification.userInfo = userDict;</span><br><span class="line">    </span><br><span class="line">    notification.repeatInterval = <span class="built_in">NSCalendarUnitDay</span>;</span><br><span class="line">    <span class="comment">// 执行通知注册</span></span><br><span class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] scheduleLocalNotification:notification];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-取消本地推送"><a href="#3-取消本地推送" class="headerlink" title="3. 取消本地推送"></a>3. 取消本地推送</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)CancelLocalNotificationWithKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="comment">// 获取所有本地通知数组</span></span><br><span class="line">    <span class="built_in">NSArray</span> *localNotifications = [<span class="built_in">UIApplication</span> sharedApplication].scheduledLocalNotifications;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UILocalNotification</span> *notification <span class="keyword">in</span> localNotifications) &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span> *userInfo = notification.userInfo;        </span><br><span class="line">        <span class="keyword">if</span> (userInfo) &#123;</span><br><span class="line">            <span class="comment">// 根据设置通知参数时指定的key来获取通知参数</span></span><br><span class="line">            <span class="built_in">NSString</span> *info = userInfo[key];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果找到需要取消的通知，则取消</span></span><br><span class="line">            <span class="keyword">if</span> (info != <span class="literal">nil</span>) &#123;</span><br><span class="line">                [[<span class="built_in">UIApplication</span> sharedApplication] cancelLocalNotification:notification];</span><br><span class="line">                DLog(<span class="string">@"移除一条注册了的本地推送"</span>);   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><br></p><h2 id="iOS-10后本地定时推送"><a href="#iOS-10后本地定时推送" class="headerlink" title="iOS 10后本地定时推送"></a>iOS 10后本地定时推送</h2><h3 id="1-注册推送"><a href="#1-注册推送" class="headerlink" title="1. 注册推送"></a>1. 注册推送</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)RegisterLocalNotificationiOS10Later:(<span class="built_in">NSDate</span> *)time&#123;</span><br><span class="line">    <span class="comment">// 使用 UNUserNotificationCenter 来管理通知</span></span><br><span class="line">    UNUserNotificationCenter* center = [UNUserNotificationCenter currentNotificationCenter];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//需创建一个包含待通知内容的 UNMutableNotificationContent 对象，注意不是 UNNotificationContent ,此对象为不可变对象。</span></span><br><span class="line">    UNMutableNotificationContent* content = [[UNMutableNotificationContent alloc] init];</span><br><span class="line">    content.title = [<span class="built_in">NSString</span> localizedUserNotificationStringForKey:<span class="string">@"时光匆匆，我只在乎你"</span> arguments:<span class="literal">nil</span>];</span><br><span class="line">    content.body = [<span class="built_in">NSString</span> localizedUserNotificationStringForKey:<span class="string">@"今天有什么想要记录和分享吗？"</span> arguments:<span class="literal">nil</span>];</span><br><span class="line">    content.sound = [UNNotificationSound defaultSound];</span><br><span class="line">    content.userInfo = [<span class="built_in">NSDictionary</span> dictionaryWithObject:LPVMNoticeEveryDayKey forKey:LPVMNoticeEveryDayKey];</span><br><span class="line">    <span class="comment">// 1.在一段时间后推送本地推送</span></span><br><span class="line"><span class="comment">//UNTimeIntervalNotificationTrigger* trigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:10 repeats:NO];</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSDateComponents</span> *components = [[<span class="built_in">NSDateComponents</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSCalendar</span> *cal = [<span class="built_in">NSCalendar</span> currentCalendar];</span><br><span class="line">    <span class="built_in">NSInteger</span> unitFlags = <span class="built_in">NSCalendarUnitHour</span> | <span class="built_in">NSCalendarUnitMinute</span>;<span class="comment">//NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit;</span></span><br><span class="line">    <span class="built_in">NSDateComponents</span> *dd = [cal components:unitFlags fromDate:time];</span><br><span class="line"></span><br><span class="line">    components.hour = [dd hour];</span><br><span class="line">    components.minute = [dd minute]; <span class="comment">// 例如每日21:00时推送</span></span><br><span class="line">    <span class="comment">// 2. 指定日期触发</span></span><br><span class="line">    UNCalendarNotificationTrigger *trigger = [UNCalendarNotificationTrigger triggerWithDateMatchingComponents:components repeats:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 根据位置触发</span></span><br><span class="line"><span class="comment">//CLLocationCoordinate2D cen = CLLocationCoordinate2DMake(39.990465,116.333386);</span></span><br><span class="line"><span class="comment">//CLRegion *region = [[CLCircularRegion alloc] initWithCenter:cen radius:100 identifier:@"center"];</span></span><br><span class="line"><span class="comment">//region.notifyOnEntry = YES;</span></span><br><span class="line"><span class="comment">//region.notifyOnExit = NO;</span></span><br><span class="line"><span class="comment">//UNLocationNotificationTrigger *trigger = [UNLocationNotificationTrigger triggerWithRegion:region repeats:YES];</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    UNNotificationRequest* request = [UNNotificationRequest requestWithIdentifier:LPVMNoticeEveryDayKey</span><br><span class="line">                                                                          content:content trigger:trigger];</span><br><span class="line">    <span class="comment">//添加推送成功后的处理！</span></span><br><span class="line">    [center addNotificationRequest:request withCompletionHandler:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            DLog(<span class="string">@"iOS10Later addNotification Error: %@"</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明:<br>有4种触发器</p><p><code>UNPushNotificationTrigger</code> 触发APNS服务，系统自动设置（这是区分本地通知和远程通知的标识)</p><p><code>UNTimeIntervalNotificationTrigger</code> 一段时间后触发</p><p><code>UNCalendarNotificationTrigger</code> 指定日期触发</p><p><code>UNLocationNotificationTrigger</code> 根据位置触发，支持进入某地或者离开某地或者都有</p><h3 id="2-iOS10Later取消推送"><a href="#2-iOS10Later取消推送" class="headerlink" title="2. iOS10Later取消推送"></a>2. iOS10Later取消推送</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UNUserNotificationCenter* center = [UNUserNotificationCenter currentNotificationCenter];</span><br><span class="line">       [center removeAllPendingNotificationRequests];  <span class="comment">// remove all at this moment.</span></span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>本地推送的回调, 会调用 <code>AppDeleage</code> 下的<code>application:(UIApplication *)application didReceiveLocalNotification</code>方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveLocalNotification:(<span class="built_in">UILocalNotification</span> *)notification&#123;</span><br><span class="line">  <span class="comment">// TO DO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目中使用到了定时提醒推送, 故整理记录下来.&lt;/p&gt;
&lt;h2 id=&quot;iOS10-之前-使用旧的本地推送注册方式&quot;&gt;&lt;a href=&quot;#iOS10-之前-使用旧的本地推送注册方式&quot; class=&quot;headerlink&quot; title=&quot;iOS10 之前, 使用旧的本地推送注册方式:&quot;&gt;&lt;/a&gt;iOS10 之前, 使用旧的本地推送注册方式:&lt;/h2&gt;&lt;h3 id=&quot;1-在-AppDelegate中代理注册使用通知-和注册远程通知一致&quot;&gt;&lt;a href=&quot;#1-在-AppDelegate中代理注册使用通知-和注册远程通知一致&quot; class=&quot;headerlink&quot; title=&quot;1. 在 AppDelegate中代理注册使用通知, 和注册远程通知一致&quot;&gt;&lt;/a&gt;1. 在 &lt;code&gt;AppDelegate&lt;/code&gt;中代理注册使用通知, 和注册远程通知一致&lt;/h3&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UIMutableUserNotificationCategory&lt;/span&gt; *categorys = [[&lt;span class=&quot;built_in&quot;&gt;UIMutableUserNotificationCategory&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UIUserNotificationSettings&lt;/span&gt; *userSettings = [&lt;span class=&quot;built_in&quot;&gt;UIUserNotificationSettings&lt;/span&gt; settingsForTypes:&lt;span class=&quot;built_in&quot;&gt;UIUserNotificationTypeBadge&lt;/span&gt;|&lt;span class=&quot;built_in&quot;&gt;UIUserNotificationTypeSound&lt;/span&gt;|&lt;span class=&quot;built_in&quot;&gt;UIUserNotificationTypeAlert&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                                                    categories:[&lt;span class=&quot;built_in&quot;&gt;NSSet&lt;/span&gt; setWithObject:categorys]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[&lt;span class=&quot;built_in&quot;&gt;UIApplication&lt;/span&gt; sharedApplication] registerUserNotificationSettings:userSettings];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[&lt;span class=&quot;built_in&quot;&gt;UIApplication&lt;/span&gt; sharedApplication] registerForRemoteNotifications];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.lydsnm.top/categories/iOS/"/>
    
    
      <category term="推送" scheme="http://www.lydsnm.top/tags/%E6%8E%A8%E9%80%81/"/>
    
  </entry>
  
  <entry>
    <title>简单明了搞定 iOS 10推送适配</title>
    <link href="http://www.lydsnm.top/2016/10/08/%E7%AE%80%E5%8D%95%E6%98%8E%E4%BA%86%E6%90%9E%E5%AE%9AiOS10%E6%8E%A8%E9%80%81%E9%80%82%E9%85%8D/"/>
    <id>http://www.lydsnm.top/2016/10/08/简单明了搞定iOS10推送适配/</id>
    <published>2016-10-07T16:00:00.000Z</published>
    <updated>2018-03-04T05:50:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 10 更新了后发现正式环境, 推送粗问题了.查了相关资料后, 整理了一下解决办法。 iOS 10后, 增加了<font color="#1E90FF">UNUserNotificationCenter</font>, 并且推送通知的处理要在代理方法</p><ul><li><p><font color="#A52A2A">userNotificationCenter:didReceiveNotificationResponse</font> 推送时 APP 在后台</p></li><li><p><font color="#A52A2A">userNotificationCenter:willPresentNotification</font> 推送时 APP 在前台</p></li></ul><a id="more"></a><p><br></p><h4 id="1-导入头文件"><a href="#1-导入头文件" class="headerlink" title="1. 导入头文件"></a>1. 导入头文件</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UserNotifications/UserNotifications.h&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="2-遵守协议"><a href="#2-遵守协议" class="headerlink" title="2. 遵守协议"></a>2. 遵守协议</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> ()&lt;<span class="title">UNUserNotificationCenterDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="3-在application-didFinishLaunchingWithOptions方法中注册推送。"><a href="#3-在application-didFinishLaunchingWithOptions方法中注册推送。" class="headerlink" title="3. 在application: didFinishLaunchingWithOptions方法中注册推送。"></a>3. 在<font color="#1E90FF">application: didFinishLaunchingWithOptions</font>方法中注册推送。</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kiOS10Later) &#123;  <span class="comment">//iOS10 之后用UNUserNotificationCenter注册通知</span></span><br><span class="line">        UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];</span><br><span class="line">        center.delegate = <span class="keyword">self</span>;</span><br><span class="line">        [center requestAuthorizationWithOptions:(UNAuthorizationOptionBadge | UNAuthorizationOptionSound | UNAuthorizationOptionAlert) completionHandler:^(<span class="built_in">BOOL</span> granted, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">                [[<span class="built_in">UIApplication</span> sharedApplication] registerForRemoteNotifications];</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"OK!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//iOS10 之前的注册通知</span></span><br><span class="line">        <span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication] respondsToSelector:<span class="keyword">@selector</span>(registerUserNotificationSettings:)]) &#123;</span><br><span class="line">        <span class="built_in">UIUserNotificationSettings</span> *settings = [<span class="built_in">UIUserNotificationSettings</span> settingsForTypes:(<span class="built_in">UIUserNotificationTypeBadge</span> |<span class="built_in">UIUserNotificationTypeSound</span> |<span class="built_in">UIUserNotificationTypeAlert</span>)</span><br><span class="line">                                                                                 categories:<span class="literal">nil</span>];</span><br><span class="line">        [[<span class="built_in">UIApplication</span> sharedApplication] registerUserNotificationSettings:settings];</span><br><span class="line">        [[<span class="built_in">UIApplication</span> sharedApplication] registerForRemoteNotifications];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4-APP-未启动-iOS10中遗弃UIApplicationLaunchOptionsRemoteNotificationKey-采用统一的方式来处理-见下一条"><a href="#4-APP-未启动-iOS10中遗弃UIApplicationLaunchOptionsRemoteNotificationKey-采用统一的方式来处理-见下一条" class="headerlink" title="4. APP 未启动, iOS10中遗弃UIApplicationLaunchOptionsRemoteNotificationKey,采用统一的方式来处理, 见下一条."></a>4. APP 未启动, iOS10中遗弃<font color="#1E90FF">UIApplicationLaunchOptionsRemoteNotificationKey</font>,采用统一的方式来处理, 见下一条.</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// application: didFinishLaunchingWithOptions 中 iOS 9及以下,还是要保留以下代码</span></span><br><span class="line"> <span class="built_in">NSDictionary</span> *remoteUserInfo = launchOptions[<span class="built_in">UIApplicationLaunchOptionsRemoteNotificationKey</span>];  </span><br><span class="line">    <span class="keyword">if</span> (remoteUserInfo) &#123;  </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"remoteUserInfo:%@"</span>,remoteUserInfo);  </span><br><span class="line">        <span class="comment">//APP未启动，点击推送消息，iOS10下还是跟以前一样在此获取  </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="5-实现接收推送消息的回调方法"><a href="#5-实现接收推送消息的回调方法" class="headerlink" title="5. 实现接收推送消息的回调方法"></a>5. 实现接收推送消息的回调方法</h4><p>iOS10之前使用<font color="#1E90FF">application: didReceiveRemoteNotification</font> 来进行回调处理，而在iOS10里则要实现用<font color="1E90FF">UNUserNotificationCenterDelegate</font>的两个代理方法： </p><blockquote><ul><li><font color="#A52A2A">userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification</font></li><li><font color="#A52A2A">userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse</font></li></ul></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iOS10之前 接收推送消息</span></span><br><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveRemoteNotification:(<span class="built_in">NSDictionary</span> *)userInfo fetchCompletionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">UIBackgroundFetchResult</span>))completionHandler &#123;</span><br><span class="line">    Log(<span class="string">@"userInfo: %@"</span>, userInfo);</span><br><span class="line">    <span class="keyword">if</span> ( application.applicationState == <span class="built_in">UIApplicationStateActive</span>) &#123;<span class="comment">// 程序在运行过程中受到推送通知</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//在background状态受到推送通知</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    completionHandler(<span class="built_in">UIBackgroundFetchResultNewData</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iOS 10之后 后台推送消息接收</span></span><br><span class="line">- (<span class="keyword">void</span>)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(<span class="keyword">void</span> (^)())completionHandler&#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *userInfo = response.notification.request.content.userInfo;</span><br><span class="line">    <span class="comment">// TO DO</span></span><br><span class="line">    </span><br><span class="line">    completionHandler(<span class="built_in">UIBackgroundFetchResultNewData</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iOS 10之后 前台推送消息处理.</span></span><br><span class="line">- (<span class="keyword">void</span>)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(<span class="keyword">nonnull</span> UNNotification *)notification withCompletionHandler:(<span class="keyword">nonnull</span> <span class="keyword">void</span> (^)(UNNotificationPresentationOptions))completionHandler&#123;</span><br><span class="line">    DLog(<span class="string">@"iOS 10 Receive Remote Notification in foreground! [willPresentNotification]"</span>);</span><br><span class="line">    <span class="comment">// 可在APP 前台状态下,弹出推送弹窗</span></span><br><span class="line">    completionHandler(UNNotificationPresentationOptionAlert);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-而对于本地推送回调-和以前没有变化"><a href="#6-而对于本地推送回调-和以前没有变化" class="headerlink" title="6. 而对于本地推送回调, 和以前没有变化:"></a>6. 而对于本地推送回调, 和以前没有变化:</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveLocalNotification:(<span class="built_in">UILocalNotification</span> *)notification&#123;</span><br><span class="line">  <span class="comment">// TO DO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="7-其他补充"><a href="#7-其他补充" class="headerlink" title="7. 其他补充"></a>7. 其他补充</h4><ul><li>对于<font color="#1E90FF">Xcode 8</font>, 默认生成的<font color="#1E90FF">XXX.entitlements</font>中的<font color="#1E90FF">APS Enviroment</font> 发布时,可以不用从development 改成 production. Xcode 在发布时会自动帮我们处理改好.</li></ul><ul><li>推送开关记得要打开;capabilities 里面<font color="#1E90FF">Background Modes–&gt;remote notification&amp;push notification</font></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 10 更新了后发现正式环境, 推送粗问题了.查了相关资料后, 整理了一下解决办法。 iOS 10后, 增加了&lt;font color=&quot;#1E90FF&quot;&gt;UNUserNotificationCenter&lt;/font&gt;, 并且推送通知的处理要在代理方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;font color=&quot;#A52A2A&quot;&gt;userNotificationCenter:didReceiveNotificationResponse&lt;/font&gt; 推送时 APP 在后台&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;font color=&quot;#A52A2A&quot;&gt;userNotificationCenter:willPresentNotification&lt;/font&gt; 推送时 APP 在前台&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.lydsnm.top/categories/iOS/"/>
    
    
      <category term="iOS10适配" scheme="http://www.lydsnm.top/tags/iOS10%E9%80%82%E9%85%8D/"/>
    
      <category term="推送" scheme="http://www.lydsnm.top/tags/%E6%8E%A8%E9%80%81/"/>
    
  </entry>
  
  <entry>
    <title>OC开发相关注意事项</title>
    <link href="http://www.lydsnm.top/2016/09/20/OC%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%BA%8C/"/>
    <id>http://www.lydsnm.top/2016/09/20/OC开发相关注意事项二/</id>
    <published>2016-09-19T16:00:00.000Z</published>
    <updated>2018-08-30T14:37:42.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="接口与-API-设计"><a href="#接口与-API-设计" class="headerlink" title="接口与 API 设计"></a>接口与 API 设计</h2><p>我们在构建应用程序编写接口应考虑将其设计成易于复用的形式, 方便后续项目复用或其他模块使用. 这就需要遵守一定的编程范式, 遵守一些约定俗成的”规则”.</p><h3 id="1-用前缀避免命名空间冲突"><a href="#1-用前缀避免命名空间冲突" class="headerlink" title="1. 用前缀避免命名空间冲突"></a>1. 用前缀避免命名空间冲突</h3><p>OC 没有其他语言内置的命名空间机制. 因此在命名时设法避免潜在的命名冲突, 否则容易就重名.否则会出现类似错误:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">duplicate symbol _OBJC_METACLASS_$_EOCTHECLASS <span class="keyword">in</span>:</span><br><span class="line">build/something.o</span><br><span class="line">build/something_else.o</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>苹果宣称其保留使用所有”两字母前缀”(two-letter prefix)的权利,因此我们的命名前缀最好避免使用两个字母当前缀.</p><a id="more"></a><hr><h3 id="2-提供”全能初始方法”"><a href="#2-提供”全能初始方法”" class="headerlink" title="2. 提供”全能初始方法”"></a>2. 提供”全能初始方法”</h3><ul><li>在类中提供一个全能初始化方法, 并于文档中指名. 其他初始化方法均应调用此方法.</li><li>若全能初始化方法与超类不同, 则需要覆写超类中的对应方法.</li><li>如果超类的初始化方法不适用于之类, 那么应该覆写这个超类方法, 并在其中抛出异常.</li></ul><hr><h3 id="3-实现-description-方法"><a href="#3-实现-description-方法" class="headerlink" title="3. 实现 description 方法"></a>3. 实现 description 方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;object = %@&quot;, object);</span><br></pre></td></tr></table></figure><p>实现 object 的 description 方法, 打印 object 中用户关心的信息.</p><ul><li>若想在调试时打印更详尽的对象描述信息, 则应实现 debugDescription 方法.</li></ul><hr><h3 id="4-尽量使用不可变对象"><a href="#4-尽量使用不可变对象" class="headerlink" title="4. 尽量使用不可变对象"></a>4. 尽量使用不可变对象</h3><p>若属性仅可以用于对象内部修改, 则在”class-continuation 分类”中将其由<code>readonly</code>属性扩展为 readwirte.<br>不要把可变的 <code>collection</code>作为属性公开, 而应时提供相关方法, 以此修改对象中的可变 <code>collection</code>.</p><hr><h3 id="5-命名方式"><a href="#5-命名方式" class="headerlink" title="5.命名方式"></a>5.命名方式</h3><p>用<code>p_</code>开头来命名私有方法. 而苹果公司用的是拿一个下划线作为前缀, 而我们最好不要用, 不然可能因为<font color="#A52A2A">动态方法派发系统(dynamic method dispatch system)</font>可能在子类中无意覆盖了方法.</p><h3 id="6-NSCopying协议"><a href="#6-NSCopying协议" class="headerlink" title="6. NSCopying协议"></a>6. NSCopying协议</h3><p>要想让自定义类支持拷贝操作, 就需要实现<font color="#A52A2A"> NSCopying</font>协议, 该协议只有一个方法:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span>*)zone</span><br></pre></td></tr></table></figure><p>为何会出现 <code>NSZone</code> 呢? 因为以前开发程序时, 会据此把内存分成不同的”区”(<code>zone</code>), 而对象会创建在某个区里面, 而现在不用了, 每个程序只有一个<code>default zone</code></p><p>对于不可变的 <code>NSArray</code> 与可变的 <code>NSMutableArray</code> 来说, 下列关系总是成立的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (NSMutableArray copy] =&gt; NSArray</span><br><span class="line">- (NSArray mutableCopy] =&gt; NSMutableArray</span><br></pre></td></tr></table></figure><p>另外, 在可变对象上调用 <code>copy</code> 方法则是会返回另外一个不可变类的实例.</p><p><br></p><hr><h2 id="协议与分类"><a href="#协议与分类" class="headerlink" title="协议与分类"></a>协议与分类</h2><p>OC 不支持多重继承, 因而我们把某个类应该实现的一系列方法定义在协议里面. 协议最为常见的用途时实现委托模式.</p><h3 id="1-委托"><a href="#1-委托" class="headerlink" title="1. 委托"></a>1. 委托</h3><p>对于需要频繁通过数据源协议从数据源中获取多份相互独立的数据, 下面的这种优化方式, 值得使用.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCNetworkFetcher</span>()</span>&#123;</span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> didReceiveData: <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> didFailWithError: <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> didUpdateProgressTo : <span class="number">1</span>;</span><br><span class="line">&#125; _delegateFlags;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set Flag</span></span><br><span class="line">_delegateFlags.didReceiveData = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setDelegate:(<span class="keyword">id</span>&lt;EOCNetworkFetcher&gt;)delegate&#123;</span><br><span class="line">_delegate = delegate;</span><br><span class="line">_delegateFlags.didReceiveData = [delegate respondsToSelector:<span class="keyword">@selector</span>(networkFetcher:didReceiveData:)];</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就不用, 每次都去检测委托对象是否能响应给定的选择子了.</p><hr><h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h3><p>当类的实现文件过于膨胀而无法管理时, 将类分类, 提取到分别的不同的文件中区.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XXX+Friendship(.h/.m)</span><br><span class="line">XXX+Work(.h/.m)</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>另外可以创建名为<code>Private</code>的分类.一般这个类中的方法只在类或框架内部使用.以隐藏实现细节.</p><hr><h3 id="3-通过协议提供匿名对象"><a href="#3-通过协议提供匿名对象" class="headerlink" title="3. 通过协议提供匿名对象"></a>3. 通过协议提供匿名对象</h3><p>委托就使用的了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, weak) id &lt;EOCDelegate&gt; delegate;</span><br></pre></td></tr></table></figure><p>该属性的类型是<code>id&lt;EOCDelegate&gt;</code>, 所以实际上任何类的对象都能充当这一属性, 即便该类不继承自 <code>NSObject</code>, 只要遵循 <font color="#A52A2A">EOCDelegate</font> 就可以了</p><p><br></p><hr><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ol><li><p>OC 中无法将某个类标识为<font color="#A52A2A">抽象类</font>. 要想达成类似效果, 最好的方法时在那些子类必须覆写的超类方法中抛出异常.</p></li><li><p>遵循使用属性的 <code>setter</code> 方法，或通过 <code>key-path</code> 来设置：<br><code>[target setAge:30];</code> <code>[target setValue:[NSNumber numberWithInt:30] forKey:@&quot;age&quot;];</code> <font color="#A52A2A">KVO</font> 键值观察才能正确获得变化.</p></li></ol><hr><p><br></p><p>本篇文章参考摘自 <font color="#B8860B">Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的52个有效方法</font></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;接口与-API-设计&quot;&gt;&lt;a href=&quot;#接口与-API-设计&quot; class=&quot;headerlink&quot; title=&quot;接口与 API 设计&quot;&gt;&lt;/a&gt;接口与 API 设计&lt;/h2&gt;&lt;p&gt;我们在构建应用程序编写接口应考虑将其设计成易于复用的形式, 方便后续项目复用或其他模块使用. 这就需要遵守一定的编程范式, 遵守一些约定俗成的”规则”.&lt;/p&gt;
&lt;h3 id=&quot;1-用前缀避免命名空间冲突&quot;&gt;&lt;a href=&quot;#1-用前缀避免命名空间冲突&quot; class=&quot;headerlink&quot; title=&quot;1. 用前缀避免命名空间冲突&quot;&gt;&lt;/a&gt;1. 用前缀避免命名空间冲突&lt;/h3&gt;&lt;p&gt;OC 没有其他语言内置的命名空间机制. 因此在命名时设法避免潜在的命名冲突, 否则容易就重名.否则会出现类似错误:&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;duplicate symbol _OBJC_METACLASS_$_EOCTHECLASS &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;build/something.o&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;build/something_else.o&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;苹果宣称其保留使用所有”两字母前缀”(two-letter prefix)的权利,因此我们的命名前缀最好避免使用两个字母当前缀.&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.lydsnm.top/categories/iOS/"/>
    
    
      <category term="OC" scheme="http://www.lydsnm.top/tags/OC/"/>
    
  </entry>
  
  <entry>
    <title>OC开发相关注意事项</title>
    <link href="http://www.lydsnm.top/2016/08/24/OC%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://www.lydsnm.top/2016/08/24/OC开发相关注意事项/</id>
    <published>2016-08-23T16:00:00.000Z</published>
    <updated>2018-08-30T14:37:08.422Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些基本信息"><a href="#一些基本信息" class="headerlink" title="一些基本信息"></a>一些基本信息</h2><h3 id="1-内存相关"><a href="#1-内存相关" class="headerlink" title="1. 内存相关"></a>1. 内存相关</h3><p>分配在堆中的内存必须直接管理, 而分配在栈中的用于保存变量的内存则会在其栈弹出时自动清理.<br>    Objective-C将堆内存管理抽象出来了. 不需要用malloc及free来分配或释放对象所占内存. Objective-C运行期环境把这部分工作抽象为一套内存管理框架-“引用计数”</p><p>在OC中, 有时会遇到定义里不含*的变量, 可能会使用<code>栈空间</code>. 这些变量所保存的不是Objective-C对象, 比如CoreGraphics中的CGRect.</p><hr><h3 id="2-在类的头文件中尽量少引入其他头文件"><a href="#2-在类的头文件中尽量少引入其他头文件" class="headerlink" title="2. 在类的头文件中尽量少引入其他头文件"></a>2. 在类的头文件中尽量少引入其他头文件</h3><p>而是采用向前声明(forward declaring)<br>减少类的使用者, 所需引入的头文件数量,减少编译时间.<br>也能解决两个类互相引用的问题</p><a id="more"></a><hr><h3 id="3-多用字面量语法-少用与之等价的方法"><a href="#3-多用字面量语法-少用与之等价的方法" class="headerlink" title="3. 多用字面量语法, 少用与之等价的方法"></a>3. 多用字面量语法, 少用与之等价的方法</h3><p>字面量语法,比如:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *something = <span class="string">@"Effective Objective-C 2.0"</span>;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字面数值</span></span><br><span class="line"><span class="built_in">NSNumber</span> *someNumber = [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1</span>]; -&gt; <span class="built_in">NSNUmber</span> *someNumber = @<span class="number">1</span>;</span><br><span class="line"><span class="comment">//字面量数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *animals = @[<span class="string">@"cat"</span>, <span class="string">@"dog"</span>];<span class="comment">// 数组中若有nil会 抛出异常.</span></span><br><span class="line"><span class="comment">//字面量字典</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *personData = @&#123;</span><br><span class="line"><span class="string">@"firstName"</span> : <span class="string">@"Matt"</span>,</span><br><span class="line"><span class="string">@"lastName"</span> : <span class="string">@"za"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//可变数组</span></span><br><span class="line">mutableArray[<span class="number">1</span>] = <span class="string">@"dog"</span>;<span class="comment">// 尽量通过下标操作来访问数组, 或者字典中的所对应的元素.</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-多用类型常量-少用-define-预处理指令"><a href="#4-多用类型常量-少用-define-预处理指令" class="headerlink" title="4. 多用类型常量, 少用#define 预处理指令"></a>4. 多用类型常量, 少用#define 预处理指令</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> kAnimationDuration = <span class="number">0.3</span>;</span><br></pre></td></tr></table></figure><p>命名, 若常量局限于某”编译单元”(也就是实现文件中, implementation中),则在前面加字母k; 若常量在类之外可见, 则通常以类名为前缀.<br>尽量不要在头文件中声明预处理指令或定义常量 static const.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AnimatedView</span>: <span class="title">UIView</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> kAnimationDuration = <span class="number">0.3</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AnimatedView</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="comment">// static修饰意味着, 该变量仅局限于此变量的编译单元(在OC语境下, 一般通常指每个类的实现文件(.m))中.</span></span><br><span class="line">如不加<span class="keyword">static</span>, 在另一.m文件中也声明了同名变量, 会抛出常见的duplicate_symbol错误</span><br></pre></td></tr></table></figure><p>实际上, 如果一个变量既声明为static, 有声明为const, 那么编译器根本不会创建符号, 而是想#define预处理指令一样, 把所有遇到的变量都替换成常值. 不过这种方式定义的常量是带有类型信息的, 这点也相当关键.</p><ul><li>通知, 发送者和接受者都需要个外界可见的常量变量(即通知的名称).</li></ul><p>这时,此类变量需放在”全局符号表”(global symbol table)中, 以便可以在定义该变量的编译单元之外使用.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In the header file</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> EOCStringConstant;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In the implementation file</span></span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> EOCStringConstant = <span class="string">@"VALUENOTIFICATION"</span>;</span><br></pre></td></tr></table></figure><p>常量定义从右至左解读,这里是”一个常量, 而这个常量是个指针, 指向一个NSString对象”<br>这里面的命名要注意谨慎, 避免名称冲突, 最好用与值相关的类名做前缀.</p><h3 id="5-用枚举表示状态、选项、状态码"><a href="#5-用枚举表示状态、选项、状态码" class="headerlink" title="5. 用枚举表示状态、选项、状态码"></a>5. 用枚举表示状态、选项、状态码</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> EOCConnectionStateConnectionState&#123;</span><br><span class="line">EOCConnectionStateDisconnected = <span class="number">1</span>,</span><br><span class="line">EOCConnectionStateConnecting,</span><br><span class="line">EOCConnectionStateConnected,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义可以彼此组合的枚举. 定义的对后, 各选项之间就可通过”按位或操作符”(bitwise OR operator)来组合.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="built_in">UIViewAutoresizing</span> &#123;</span><br><span class="line"><span class="built_in">UIViewAutoresizingNone</span>= <span class="number">0</span>,</span><br><span class="line"><span class="built_in">UIViewAutoresizingFlexbleLeftMargin</span>= <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line"><span class="built_in">UIViewAutoresizingFlexbleWidth</span>= <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line"><span class="built_in">UIViewAutoresizingFlexbleRighMargin</span> = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在处理枚举类型的switch语句中不要实现default分支. 这样的话, 加入新枚举之后, 编译器就会提示开发者. switch语句并未处理所有枚举.</li></ul><hr><h2 id="对象、消息、运行期"><a href="#对象、消息、运行期" class="headerlink" title="对象、消息、运行期"></a>对象、消息、运行期</h2><h3 id="6-理解属性这一概念"><a href="#6-理解属性这一概念" class="headerlink" title="6.理解属性这一概念"></a>6.理解属性这一概念</h3><p>属性用来通过存取放方法来访问实例变量, 是OC提供的一个简洁方便管理的抽象机制. @property语法. 如果用了这些属性了, 编译器会自动编写访问这些属性所需的方法, 次过程叫”自动合成”(autosynthesis),并添加对应的实例变量. 也可以在类的实现代码里通过<code>@synthesize</code>语法来指定实例变量的名字</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@implementaion EOCPerson</span><br><span class="line"><span class="keyword">@synthesize</span> fireName = _myFirstname;</span><br><span class="line"><span class="keyword">@synthesize</span> lastName = _myLastName;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>可通过<code>@dynamic</code>关键字来告诉编译器不要自动创建实现属性所用的实例变量和存取方法.</p><p>修饰属性的特质关键字</p><ul><li>weak 表明定义了一种”非拥有关系”. 为这种属性设置新值时, 设置方法既不保留新值, 也不释放旧值. 当属性所指的对象遭到销毁时, 属性值也会清空(nil).</li><li>unsafe_unretained 该特质的语义表达一种”非拥有关系”, 当目标对象遭到销毁时, 属性值不会自动清空(unsafe), 这一点和weak不同.</li><li>在iOS程序是, 应用nonatomic属性, 避免影响性能</li></ul><p><br></p><hr><h3 id="7-在对对象内部尽量直接访问实例变量"><a href="#7-在对对象内部尽量直接访问实例变量" class="headerlink" title="7. 在对对象内部尽量直接访问实例变量"></a>7. 在对对象内部尽量直接访问实例变量</h3><p>直接访问实例变量, 速度会快一点, 但是对一个声明的copy的属性, 那么并不会拷贝该属性, 只会保留新值并释放旧值. 也不能触发”键值观察”(KVO), 一般比较折中的方式是写入实例变量时, 通过其”设置方法”来做, 而在读取实例变量是, 则直接访问.<br>注意的地方:<br>在初始化方法中应该如何设置属性值, 这种情况总是应该直接访问实例变量, 因为子类可能overide重写了设置方法.</p><p>对于懒加载或者说惰性初始化(lazy initialization)来说,就必须通过存取方法来访问属性.</p><p><br></p><hr><h3 id="8-理解”对象等同性”"><a href="#8-理解”对象等同性”" class="headerlink" title="8. 理解”对象等同性”"></a>8. 理解”对象等同性”</h3><p>有时,按照==操作符比较出来的结果未必是我们想要的, 该操作比较的是两个指针本身, 而不是所指的对象. 应该使用NSObject协议中声明的<code>isEqual</code><br>NSObject协议中有两个用于判断等同性的关键方法:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)isEqual:(<span class="keyword">id</span>)object;</span><br><span class="line">- (<span class="built_in">NSUInteger</span>)hash;</span><br></pre></td></tr></table></figure><ul><li><p>若想检测对象的等同性, 请提供<code>isEqual:</code>与<code>hash</code>方法.</p></li><li><p>相同的对象必须具有相同的哈希码, 但两个哈希码相同的对象却未必相同.</p></li><li><p>编写hash方法时, 应该使用计算速度快而且哈希码碰撞几率低的算法.</p></li></ul><p><br></p><hr><h3 id="9-以”类族模式”隐藏实现细节"><a href="#9-以”类族模式”隐藏实现细节" class="headerlink" title="9.以”类族模式”隐藏实现细节."></a>9.以”类族模式”隐藏实现细节.</h3><p>类方法(也叫类别方法)<br>类族模式可以把实现细节隐藏在一套简单的公共接口后面.</p><p>系统框架中经常使用类族(NSArray)</p><p><br></p><hr><h3 id="11-理解objc-msgSend的作用"><a href="#11-理解objc-msgSend的作用" class="headerlink" title="11. 理解objc_msgSend的作用"></a>11. 理解objc_msgSend的作用</h3><p>传递消息, C语言使用静态绑定(static binding), 在编译期内就能决定运行时所应调用的函数.函数地址实际上是硬编码在指令之中的.</p><p>so 对应的有动态绑定, 在OC中, 如果向某对象传递消息, 那就会使用动态绑定机制来决定需要调用的方法.</p><ul><li>给某对象”发送消息”(invoke a message)也就相当于在该对象上”调用方法”(call a method)</li><li>发给某对象的全部消息都要由”动态消息派发系统”(dynamic message dispatch system)来处理, 该系统会查处对应的方法, 并执行其代码.</li></ul><p><br></p><hr><h3 id="12-理解消息转发机制"><a href="#12-理解消息转发机制" class="headerlink" title="12. 理解消息转发机制"></a>12. 理解消息转发机制</h3><ul><li>若对象无法响应某个选择子, 则进入消息转发流程.</li><li>通过运行期的动态方法解析功能, 我们可以在需要用到某个方法时再讲其加入类中.</li><li>对象可以把其无法解读的某些选择子转交给其他对象来处理.</li><li>经过上述两步后, 如果还是没有办法处理选择子, 那就启动完整的消息转发机制.</li></ul><p><br></p><hr><h3 id="14-理解”类对象”的用意"><a href="#14-理解”类对象”的用意" class="headerlink" title="14. 理解”类对象”的用意"></a>14. 理解”类对象”的用意</h3><p>OC 有个特殊类型 <font color="#00fffff">id</font> 指代任意的 OC 对象类型. 一般情况下,消息转发给了 此 id 的对象, 但不知其具体类型是否能响应. 我们知道如果向某明确类型发送了无法解读的消息, 那么就会产生警告信息, 而 <font color="#00fffff">id</font>类型让编译器假定其能响应所有消息, 留待后续”在运行期检视对象类型”,看是否能够响应其方法.</p><ul><li>每个实例都有一个指向 Class 对象的指针, 用以表明其类型, 而这些 Class 对象则构成了类的继承体系.</li><li>如果对象类型无法在编译期确定,那么久应该实用类型信息查询方法来判断 <code>isKindOfClass</code>…</li><li>尽量实用类型信息查询方法来确定对象类型, 而不要直接比较类对象, 因为某些对象可能实现了消息转发功能.</li></ul><hr><p><br></p><p>本篇文章参考摘自 <font color="#B8860B">Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的52个有效方法</font></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一些基本信息&quot;&gt;&lt;a href=&quot;#一些基本信息&quot; class=&quot;headerlink&quot; title=&quot;一些基本信息&quot;&gt;&lt;/a&gt;一些基本信息&lt;/h2&gt;&lt;h3 id=&quot;1-内存相关&quot;&gt;&lt;a href=&quot;#1-内存相关&quot; class=&quot;headerlink&quot; title=&quot;1. 内存相关&quot;&gt;&lt;/a&gt;1. 内存相关&lt;/h3&gt;&lt;p&gt;分配在堆中的内存必须直接管理, 而分配在栈中的用于保存变量的内存则会在其栈弹出时自动清理.&lt;br&gt;    Objective-C将堆内存管理抽象出来了. 不需要用malloc及free来分配或释放对象所占内存. Objective-C运行期环境把这部分工作抽象为一套内存管理框架-“引用计数”&lt;/p&gt;
&lt;p&gt;在OC中, 有时会遇到定义里不含*的变量, 可能会使用&lt;code&gt;栈空间&lt;/code&gt;. 这些变量所保存的不是Objective-C对象, 比如CoreGraphics中的CGRect.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;2-在类的头文件中尽量少引入其他头文件&quot;&gt;&lt;a href=&quot;#2-在类的头文件中尽量少引入其他头文件&quot; class=&quot;headerlink&quot; title=&quot;2. 在类的头文件中尽量少引入其他头文件&quot;&gt;&lt;/a&gt;2. 在类的头文件中尽量少引入其他头文件&lt;/h3&gt;&lt;p&gt;而是采用向前声明(forward declaring)&lt;br&gt;减少类的使用者, 所需引入的头文件数量,减少编译时间.&lt;br&gt;也能解决两个类互相引用的问题&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.lydsnm.top/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://www.lydsnm.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>阶段总结</title>
    <link href="http://www.lydsnm.top/2016/08/23/%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/"/>
    <id>http://www.lydsnm.top/2016/08/23/阶段总结/</id>
    <published>2016-08-22T16:00:00.000Z</published>
    <updated>2018-01-02T13:49:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>8月</p><p>Swift还是在学习中,可能会搁置一段时间. 基本语法是了解了, 在了解过程也发现某些语法确实和看到的资料不同, 有人开玩笑说, 每过一段时间就好像是学一门新的语言.😁</p><a id="more"></a><p>但是以目前的Swift语言的状态来说, 确实不太适合作为某些公司的主力开发语言<br>因此之后的比例会减少, 继续OC.</p><p>Swift包括网络库等等, 都要熟悉, 头疼.<br>后续会抽空更新Swift语言的相关知识整理, 也是方便自己之后的查阅~~. </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;8月&lt;/p&gt;
&lt;p&gt;Swift还是在学习中,可能会搁置一段时间. 基本语法是了解了, 在了解过程也发现某些语法确实和看到的资料不同, 有人开玩笑说, 每过一段时间就好像是学一门新的语言.😁&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.lydsnm.top/categories/iOS/"/>
    
    
      <category term="计划" scheme="http://www.lydsnm.top/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
</feed>
