<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[近期换工作了]]></title>
      <url>http://www.lydsnm.top/2018/12/03/%E8%BF%91%E6%9C%9F%E9%9D%A2%E8%AF%95%E4%BD%93%E9%AA%8C/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;近期换工作，面试了很多家。突发发现我的很多表述能力还有“很大的潜力”。上家公司呆久了，没用到的基础性的知识，模糊的很，趁这个时候好好看了下，捡起来不少。</p>
<a id="more"></a>
<p>&emsp;&emsp;还是要保持竞争力才行啊。blog最好不要随心发布，还是经常学习，把笔记里的东西整理下发出来吧，满足一下~。</p>
<p>&emsp;&emsp;近期会更新一下面试的心得还有一些题。</p>
]]></content>
      
        <categories>
            
            <category> 杂想 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Slice 1.0.1 —— Mac提升个人效率的一个小工具]]></title>
      <url>http://www.lydsnm.top/2018/08/30/Slice%E6%9B%B4%E6%96%B01.0.1/</url>
      <content type="html"><![CDATA[<h2 id="一、Slice更新："><a href="#一、Slice更新：" class="headerlink" title="一、Slice更新："></a>一、Slice更新：</h2><p><img src="https://upload-images.jianshu.io/upload_images/1106214-2ef452181b188f6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="SlicePrevie"></p>
<p>&emsp;&emsp;你是否有这样的体验，如果给你一上午的周末时间，可能会想着反正时间也多，打扫个卫生，刷刷微博一上午就过去，但如果是把这些时间划分成15分钟的片段，每个片段做一件事，一上午能做的事绝对超出你的想象。</p>
<p>&emsp;&emsp;在短暂的片刻时间内，指定一个几十分钟内要完成的任务。这几十分钟内只专做这件事，不要被其他打扰。只有倒计时才会给人紧迫感。与其在期望未来虚幻的成就，不如着眼现在，把握即将到来的一小段时间。</p>
<p>&emsp;&emsp;我个人也在用这个软件，使用下来，确实提升了不少效率。</p>
<a id="more"></a>
<h2 id="二、正确使用姿势："><a href="#二、正确使用姿势：" class="headerlink" title="二、正确使用姿势："></a>二、正确使用姿势：</h2><p>&emsp;&emsp;脑中指定一件接下来要做的事，接下来的一段时间内只专注于这一件事（一段时间：就是自己输入的时间）。亲测，效率提升不少，并且有一丝紧迫感。</p>
<p>&emsp;&emsp;建议15分钟一次，太长会集中不了注意力，影响效率。此外，永远也不要做一件事，超过1个小时。利用碎片时间，将整块的时间分成小片段，去做任何琐碎的事，而不会花掉整块时间处理。</p>
<h2 id="三、功能特点："><a href="#三、功能特点：" class="headerlink" title="三、功能特点："></a>三、功能特点：</h2><ul>
<li>占用极小。</li>
<li>始终悬停在所有窗口最前面。</li>
<li>菜单栏点击，可以创建一个新的倒计时窗口（即支持多个计时器）</li>
<li>自定义提醒信息</li>
</ul>
<p>Slice 1.0.1. 在上一个版本的基础上，精简了一些功能。新增了以下一些功能：</p>
<ul>
<li>暂停功能：<br>可能在中途出现突发事情要去处理，可以暂停Slice时间。</li>
<li>更明显的提醒信息</li>
</ul>
<hr>
<h2 id="四、后期功能计划"><a href="#四、后期功能计划" class="headerlink" title="四、后期功能计划"></a>四、后期功能计划</h2><ul>
<li>提醒音效可选择。</li>
<li>后期会加统计功能。</li>
</ul>
<hr>
<h2 id="五、使用"><a href="#五、使用" class="headerlink" title="五、使用"></a>五、使用</h2><p>下载链接:<a href="https://pan.baidu.com/s/1roNYPESUcKJJhXRkOl6uzw" target="_blank" rel="noopener">https://pan.baidu.com/s/1roNYPESUcKJJhXRkOl6uzw</a>  密码:s1vx</p>
<p>解压后将<code>slice.app</code>拖动到系统的应用程序中</p>
<p>另外，针对某些用户所说，在10.11以后系统可能安装不了的情况，可以在“设置”中“安全与隐私”的“通用”选项下， 设置<b>允许从任何来源的应用</b>。然后就可以正常使用Slice了。因为Slice是本人在业余时间开发，并未上架App store，且OS X系统有这么一个保护机制，故有这样现象。</p>
<p><img src="http://ocs32tleq.bkt.clouddn.com/PastedGraphic-1-systemSettingforMac.png" width="500"></p>
<p>如果在这个地方没有“任何来源”一项的话，就需要打开系统应用“终端”，输入</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo spctl --master-disable</span><br></pre></td></tr></table></figure>
<p>然后再输入你的系统密码回车即可（不屏显）。</p>
<h2 id="六、联系我"><a href="#六、联系我" class="headerlink" title="六、联系我"></a>六、联系我</h2><p>如果你有什么建议或意见，请告诉我~<br>[邮箱]：<a href="mailto:dongingdao@163.com" target="_blank" rel="noopener">dongingdao@163.com</a></p>
]]></content>
      
        <categories>
            
            <category> tools </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[应用审核通过，但是内购项目一直处于正在审核中]]></title>
      <url>http://www.lydsnm.top/2018/07/03/2018-07-03%E5%BA%94%E7%94%A8%E5%AE%A1%E6%A0%B8%E9%80%9A%E8%BF%87%EF%BC%8C%E4%BD%86%E6%98%AF%E5%86%85%E8%B4%AD%E9%A1%B9%E7%9B%AE%E4%B8%80%E7%9B%B4%E5%A4%84%E4%BA%8E%E6%AD%A3%E5%9C%A8%E5%AE%A1%E6%A0%B8%E4%B8%AD/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;近期应用上架会员功能，新增了几个内购项目，按部就班，应用测试通过后，提交应用商店审核。自信的勾选上审核通过后自动发布，可是应用通过审核并自动释放了，内购项目没有通过，导致线上用户版本，点击购买会员获取不到商品信息，没有任何反应，特难受。现在记录一下我的解决过程，希望对其他有遇到这个问题的朋友有所帮助。</p>
<a id="more"></a>
<p>&emsp;&emsp;尝试过重新修改下判断没有商店信息给出提醒，按照一些网友的解决方法：重新提交一个新版本审核，并改成了手动发布。然而事实告诉我，这样并没有用。审核员再次遗漏了我的内购项目。无奈之下，尝试了邮件申诉反馈。</p>
<p>附：<a href="https://developer.apple.com/" target="_blank" rel="noopener">https://developer.apple.com/</a> -&gt; Contact Us -&gt; App Review -&gt; Other App Review questions -&gt; I would like to <code>get the status of my app</code>。这是我的选择步骤。</p>
<p>&emsp;&emsp;第二天，早上8点多邮件有通知，内购通过了，线上版本不用更新可以直接用了（PS：服务器同步要时间，等到下午的时候，会员才可以正常购买）。</p>
<h2 id="结语："><a href="#结语：" class="headerlink" title="结语："></a>结语：</h2><p>&emsp;&emsp;如果一个版本有新增的内购项，那么这个版本还是改成<code>手动释放</code>比较好。点击发布前要检查你的内购项是否是处于<code>已批准</code>状态。如果发现应用通过后，内购审核没有红点（也就说没有按要求填写而打回）处于正在审核中，请联系苹果客服，不要重新发包了，至少我这里的经验是这样的。</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[私有API检测系统中是否安装了某款指定的软件]]></title>
      <url>http://www.lydsnm.top/2018/06/25/2018-06-25%E7%A7%81%E6%9C%89API%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E4%BA%86%E6%9F%90%E6%AC%BE%E6%8C%87%E5%AE%9A%E7%9A%84%E8%BD%AF%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;前段时间，在一个积分任务墙的项目，需要跳转到市场去安装App，了需要检测iOS设备已安装应用列表的需求，要能获取到安装情况（包括安装进度啊，完成回调等）。经过一段时间的了解，还算完成了既定任务。</p>
<a id="more"></a>
<h2 id="URL-Scheme"><a href="#URL-Scheme" class="headerlink" title="URL Scheme"></a>URL Scheme</h2><p>&emsp;&emsp;前期考虑过<code>URL Scheme</code>来判断是否安装了某个应用，但是每个app是否设置了URL scheme不知道，而且iOS9上  <code>[[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:url]]</code>的能判断的上限是50个，因此这个实际情况下无法使用。但是我们可能在其他场景下使用到URL Scheme(比如打开系统应用)，可以下面的方法列出所有的URL Scheme，但是哪个scheme是哪个应用就得靠猜了，一个应用也可能有多个URL Scheme。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span>*)privateURLSchemes&#123;</span><br><span class="line">    <span class="keyword">return</span> [_workspace privateURLSchemes];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span>*)publicURLSchemes&#123;</span><br><span class="line">    <span class="keyword">return</span> [_workspace publicURLSchemes];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取系统中安装列表和各应用的bundleId。"><a href="#获取系统中安装列表和各应用的bundleId。" class="headerlink" title="获取系统中安装列表和各应用的bundleId。"></a>获取系统中安装列表和各应用的bundleId。</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class LSApplicationWorkspace_class = objc_getClass(<span class="string">"LSApplicationWorkspace"</span>);  </span><br><span class="line">SEL selector=<span class="built_in">NSSelectorFromString</span>(<span class="string">@"defaultWorkspace"</span>);  </span><br><span class="line"><span class="built_in">NSObject</span>* workspace = [LSApplicationWorkspace_class performSelector:selector];  </span><br><span class="line">_workspace = workspace</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">&lt;objc/runtime.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"> SEL selectorALL = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"allApplications"</span>);  </span><br><span class="line"> <span class="built_in">NSArray</span> *apps = [_workspace performSelector:selectorALL];</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"apps: %@"</span>, );  </span><br><span class="line"> [apps[<span class="number">0</span>] performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"applicationIdentifier"</span>)];<span class="comment">//shortVersionString等。</span></span><br></pre></td></tr></table></figure>
<p>其余一些方法可以去这儿<a href="https://github.com/nst/iOS-Runtime-Headers/blob/master/Frameworks/MobileCoreServices.framework/LSApplicationProxy.h" target="_blank" rel="noopener">查看</a>：</p>
<p>关于LSApplicationWorkspace的使用可以查看<a href="https://www.jianshu.com/p/b8d882069197" target="_blank" rel="noopener">iOS私有方法LSApplicationWorkspace.h的一些使用</a></p>
<h2 id="通过定时器不断的调度-可以用下面的方法得到-所有正在下载的app"><a href="#通过定时器不断的调度-可以用下面的方法得到-所有正在下载的app" class="headerlink" title="通过定时器不断的调度 可以用下面的方法得到 所有正在下载的app"></a>通过定时器不断的调度 可以用下面的方法得到 所有正在下载的app</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 通过定时器不断调用来获取系统中所有正在下载的内容及进度。*/</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)TimerUpdateToGetDownloadProgress:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *lib = dlopen(<span class="string">"/System/Library/Frameworks/MobileCoreServices.framework/MobileCoreServices"</span>, RTLD_LAZY);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (lib)&#123;</span><br><span class="line">        Class LSApplicationWorkspace = <span class="built_in">NSClassFromString</span>(<span class="string">@"LSApplicationWorkspace"</span>);</span><br><span class="line">        <span class="keyword">id</span> AAURLConfiguration1 = [LSApplicationWorkspace performSelector:<span class="keyword">@selector</span>(defaultWorkspace)];</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (AAURLConfiguration1)&#123;</span><br><span class="line">            <span class="keyword">id</span> arrApp = [AAURLConfiguration1 performSelector:<span class="keyword">@selector</span>(allApplications)];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;[arrApp count]; i++) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">id</span> LSApplicationProxy = [arrApp objectAtIndex:i];</span><br><span class="line">                <span class="built_in">NSString</span>* bundleId =[LSApplicationProxy performSelector:<span class="keyword">@selector</span>(applicationIdentifier)];</span><br><span class="line">                <span class="built_in">NSString</span>* name = [LSApplicationProxy localizedName];</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">NSProgress</span> *progress = (<span class="built_in">NSProgress</span> *)[LSApplicationProxy performSelector:<span class="keyword">@selector</span>(installProgress)];</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"current progress:%lf bundleId:%@"</span>, [<span class="built_in">NSProgress</span> currentProgress], bundleId);</span><br><span class="line">                <span class="comment">// 正在安装的模型数据</span></span><br><span class="line"><span class="comment">//                InstallingModel *model = [self getInstallModel:bundleId];</span></span><br><span class="line">                <span class="comment">//如果是正在下载状态</span></span><br><span class="line">                <span class="keyword">if</span> (progress)&#123;</span><br><span class="line">                    <span class="comment">//已经检测到的</span></span><br><span class="line"><span class="comment">//                    if (model) &#123;</span></span><br><span class="line"><span class="comment">//                        model.progress = [progress localizedDescription];</span></span><br><span class="line"><span class="comment">//                        model.status  =  [NSString stringWithFormat:@"%@",[[progress userInfo] valueForKey:@"installState"]];</span></span><br><span class="line">                        <span class="comment">//第一次检测到的</span></span><br><span class="line"><span class="comment">//                    &#125;else&#123;</span></span><br><span class="line"><span class="comment">//                        InstallingModel *model = [[InstallingModel alloc] init];</span></span><br><span class="line"><span class="comment">//                        model.appName = name;</span></span><br><span class="line"><span class="comment">//                        model.bundleID = bundleId;</span></span><br><span class="line"><span class="comment">//                        model.progress = [progress localizedDescription];</span></span><br><span class="line"><span class="comment">//                        model.status  = [NSString stringWithFormat:@"%@",[[progress userInfo] valueForKey:@"installState"]];</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                        [_installedAry addObject:model];</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lib) dlclose(lib);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过bundle-id判断是否安装并打开app"><a href="#通过bundle-id判断是否安装并打开app" class="headerlink" title="通过bundle id判断是否安装并打开app"></a>通过bundle id判断是否安装并打开app</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过applicationIdentifier id。判断是否安装某个APP</span></span><br><span class="line">        <span class="built_in">BOOL</span> isInstall = [workspace performSelector:<span class="keyword">@selector</span>(applicationIsInstalled:) withObject:<span class="string">@"com.tencent.xin"</span>];</span><br><span class="line">        <span class="keyword">if</span> (isInstall) &#123;</span><br><span class="line">            <span class="comment">//通过bundle id打开APP</span></span><br><span class="line">            [workspace performSelector:<span class="keyword">@selector</span>(openApplicationWithBundleID:) withObject:<span class="string">@"com.tencent.xin"</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"您还没安装"</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上一些方法大都使用到了私有API、故切记要上架到app store的应用不要使用。<br>在了解过程中，一并完成了一个测试demo，有需要的可以在此基础上试验。<br><a href="https://github.com/donglyu/CheckInstalledAppEtcIniOS" target="_blank" rel="noopener">Demo地址</a></p>
<p>- EOF -</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[记一则iOS封装SDK的开发过程之WebView和JS交互]]></title>
      <url>http://www.lydsnm.top/2018/05/20/%E8%AE%B0%E4%B8%80%E5%88%99iOS%E5%B0%81%E8%A3%85SDK%E7%9A%84%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B9%8BWebView%E5%92%8CJS%E4%BA%A4%E4%BA%92/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;近来接触了一个封装sdk的项目，过程中遇到了一些问题，现在空了下来，将这个过程记录一下。<br>项目主要由<u>iOS封装一个framework静态库，库里面引入由甲方提供的js方法库（一个js文件），原生调用js中的方法，将方法返回值通过原生方法回调会去</u>。相当于一个中间件的功能。</p>
<p>&emsp;&emsp;我首先想到的是通过 <font color="a52a2a"><b>UIWebView</b></font> 或 <font color="a52a2a"><b>WKWebView</b></font> 来加载js，然后通过javascriptCore和WKWebView自带的方法来处理。这个甲方要求又不要显示html页面，所以使用WebView有点用了牛刀的感觉。查了查资料，没有找到直接能和js文件交互的方法，无奈还是采用了WKWebView。</p>
<a id="more"></a>
<p>&emsp;&emsp;由于wkwebView是iOS8以后推出的新框架，故而一开始就使用使用了wkwebview。当对应的html、js到位后，发现js中的回调很奇怪，原生偶尔可以得到回调，猜测可能js方法库中方法太过繁忙，从而导致消息堵塞进而丢失掉。经过延时的操作，发现并不是这个问题。</p>
<p>&emsp;&emsp;正如之前说的，项目并不需要展示webView，html中的内容也不需要展示。而需求是提供.framework，不可能头文件提供一个webView给开发者，添加到对应的界面上吧。因此做了一个小尝试，快速改换成了UIWebView，相应的js方法，和调用方法，以及回调方法改了下来测试。发现可以正常使用。这下得出结论WkWebView如果没有正常显示的话，内部有种“惰性”的感觉，某些js方法执行和回调很“迟缓”，往往点几次才会响应。</p>
<p>&emsp;&emsp;研究到这，应该是换成UIWebView了。但是抱着不甘心，多查了些资料，和试验了几波，是真的因为那个原因吗？不多说了，总结了下我的两个解决方法：</p>
<h2 id="最终解决"><a href="#最终解决" class="headerlink" title="最终解决"></a>最终解决</h2><h3 id="1-使用UIWebView"><a href="#1-使用UIWebView" class="headerlink" title="1.使用UIWebView"></a>1.使用UIWebView</h3><p>js中使用下面的代码回调原生</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bclMiddlecallback(callbackScheme, callbackPath);</span><br></pre></td></tr></table></figure>
<p>UIWebView可以不加在任何View上，也可以设置<code>.hidden = YES;</code></p>
<h3 id="2-继续使用WKWebView"><a href="#2-继续使用WKWebView" class="headerlink" title="2.继续使用WKWebView"></a>2.继续使用WKWebView</h3><p>js中使用下面的方法回调原生</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.webkit.messageHandlers.bclMiddlecallback.postMessage(callbackScheme + callbackPath);</span><br></pre></td></tr></table></figure>
<p>！！！WKWebView必须加在某个View上，内部一些机制才能正常运转、回调才能正常发生。.hidden设置或者不设置不影响。</p>
<p>所以：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WKWebView</span> *wkWebView = [[<span class="built_in">WKWebView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, [[<span class="built_in">UIScreen</span> mainScreen] bounds].size.height, <span class="number">320</span>, <span class="number">480</span>) configuration:configuration];</span><br><span class="line">_wkWebView = wkWebView;</span><br><span class="line">[[[<span class="built_in">UIApplication</span> sharedApplication] windows].firstObject addSubview:wkWebView];</span><br><span class="line">wkWebView.hidden = <span class="literal">YES</span>;</span><br></pre></td></tr></table></figure>
<p>收工！</p>
<hr>
<p>如果你也遇到此问题，如果你有新的想法请联系我：<a href="mailto:dongigndao@163.com" target="_blank" rel="noopener">dongigndao@163.com</a></p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS WebView修改userAgent的问题与解决]]></title>
      <url>http://www.lydsnm.top/2018/03/22/iOS%20WebView%E4%BF%AE%E6%94%B9userAgent%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;前阵子做一个阅读应用，需要嵌入H5页面，要让网页检测到是App的webView访问。网页有个loading数据过程，这个loading效果比较复杂，于是乎由客户端实现，需要网页告诉客户端什么时候该关掉Loading动画遮罩层（还有一些其他交互效果）。这就涉及到了网页和原生的交互了。客户端使用的是<font color="a52a2a">WKWebView</font>。</p>
<a id="more"></a>
<p>&emsp;&emsp;在UIWebView上修改全局userAgent就使用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIWebView</span> *webView = [[<span class="built_in">UIWebView</span> alloc] initWithFrame:<span class="built_in">CGRectZero</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *userAgent = [webView stringByEvaluatingJavaScriptFromString:<span class="string">@"navigator.userAgent"</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *newUserAgent = [userAgent stringByAppendingString:<span class="string">@" AppFlag"</span>];</span><br><span class="line">        newUserAgent = [newUserAgent stringByAppendingString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@" token/%@"</span>, token]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *dictionary = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:newUserAgent, <span class="string">@"UserAgent"</span>, <span class="literal">nil</span>];</span><br><span class="line">    [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] registerDefaults:dictionary];</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在UIWebView上获取userAgent的方法是同步的(Synchronous)。</p>
<p>&emsp;&emsp;如果实在WKWebView上则使用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WKWebView</span> *wkWebView = [[<span class="built_in">WKWebView</span> alloc] initWithFrame:<span class="built_in">CGRectZero</span>];</span><br><span class="line">    <span class="keyword">self</span>.wkWebView = wkWebView;</span><br><span class="line">    [wkWebView evaluateJavaScript:<span class="string">@"navigator.userAgent"</span> completionHandler:^(<span class="keyword">id</span> result, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *userAgent = result;</span><br><span class="line">        <span class="built_in">NSString</span> *newUserAgent = [userAgent stringByAppendingString:<span class="string">@" AppFlag"</span>];</span><br><span class="line">      </span><br><span class="line">    newUserAgent = [newUserAgent stringByAppendingString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@" token/%@"</span>, token]];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSDictionary</span> *dictionary = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:newUserAgent, <span class="string">@"UserAgent"</span>, <span class="literal">nil</span>];</span><br><span class="line">        [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] registerDefaults:dictionary];</span><br><span class="line">         [<span class="keyword">self</span>.wkWebView setCustomUserAgent:customUserAgent]</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在WKWebView上获取userAgent就是异步的(Asynchronous)。</p>
<p>&emsp;&emsp;如果在webView loadRequest之前使用WKWebView的方式修改了userAgent之后，在Safari中调试发现userAgent实际上可能并没有成功修改。其实是因为异步修改没有修改成功，如果再次load了一个新页面，再在Safari中控制台输入<code>navigator.userAgent</code>就可以查看到修改后的内容，这就是很多其他朋友说遇到的要第二次才能显示自定义的值。<strong><font color="10d3c4">这里建议使用UIWebView的方式修改全局userAgent，然后再使用WKWebView取加载内容，最简单最通用</font></strong>。如果使用WKWebView修改后再用WKWebView加载页面，需要注意获取并修改 userAgent 的 webView 对象，跟加载网页的 webView 不能是同一个对象，也就说在获取到当前的userAgent的回调里需要重新初始化 wKWebView来加载页面。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIWebView</span> *webView = [[<span class="built_in">UIWebView</span> alloc] initWithFrame:<span class="built_in">CGRectZero</span>];</span><br><span class="line"><span class="built_in">NSString</span> *userAgent = [webView stringByEvaluatingJavaScriptFromString:<span class="string">@"navigator.userAgent"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *newUserAgent = [userAgent stringByAppendingString:<span class="string">@" native_iOS"</span>];<span class="comment">//自定义需要拼接的字符串</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *dictionary = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:newUserAgent, <span class="string">@"UserAgent"</span>, <span class="literal">nil</span>];</span><br><span class="line">[[<span class="built_in">NSUserDefaults</span> standardUserDefaults] registerDefaults:dictionary];</span><br><span class="line">[<span class="keyword">self</span>.wkWebView setCustomUserAgent:customUserAgent]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>参考链接：</strong></p>
<p><a href="https://stackoverflow.com/questions/26994491/set-useragent-in-wkwebview" target="_blank" rel="noopener">https://stackoverflow.com/questions/26994491/set-useragent-in-wkwebview</a><br><a href="https://cloud.tencent.com/developer/article/1158832" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1158832</a></p>
]]></content>
      
        <categories>
            
            <category> OC </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[苹果的Marzipan]]></title>
      <url>http://www.lydsnm.top/2017/12/27/%E8%8B%B9%E6%9E%9C%E7%9A%84Marzipan/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;听说有个新的东西：为了增强Mac上的软件产品，苹果正在计划模糊macOS和iOS平台之间的界限，允许iOS App Store上的iPhone和iPad应用程序在Mac上运行：</p>
<p>&emsp;&emsp;<code>Marzipan</code>  <a href="https://baijiahao.baidu.com/s?id=1587358985291753758&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">新闻来源</a>    <em>一个App适配所有设备。</em></p>
<a id="more"></a>
<p>&emsp;&emsp;一方面，熟悉苹果生态的人都比较清楚，iOS上软件质量一向很高，数量也很多，几乎能够找到所有功能的App。而对应的MAC OS平台上相比较iOS，软件上数量上就少很多了（软件质量上我个人认为是不差的。）。<br>如果iOS上的App能够跨在MAC OS上使用就好了。</p>
<p>&emsp;&emsp;另一方面，如果苹果能将这条通道打通的话，那么iPad的用武之地就大许多了，随之而来iPad的销量也将会大幅上升。毕竟现阶段iPad还是处于一个尴尬的处境，处理复杂事物时，还是需要Mac的文件管理系统，能够更加灵活的处理。处理文档、简单任务时，iPad还是有优势的。</p>
<p>&emsp;&emsp;期待一下吧。</p>
]]></content>
      
        <categories>
            
            <category> Apple </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift中的值类型引用类型相关内容]]></title>
      <url>http://www.lydsnm.top/2017/10/14/Swift%E4%B8%AD%E7%9A%84%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/</url>
      <content type="html"><![CDATA[<h2 id="一、Swift中的值类型和引用类型"><a href="#一、Swift中的值类型和引用类型" class="headerlink" title="一、Swift中的值类型和引用类型"></a>一、Swift中的值类型和引用类型</h2><h3 id="值类型和引用类型是啥"><a href="#值类型和引用类型是啥" class="headerlink" title="值类型和引用类型是啥"></a>值类型和引用类型是啥</h3><p>&emsp;&emsp;最近在用Swift写代码，发现Swift中的值类型和引用类型好像有些奇怪，包括之前了解到的NSArray和Array之间的关系，有些混淆了。现在静下来来学习下，记录一下，防止后面防错。</p>
<p>&emsp;&emsp;首先来回顾一下基础概念：什么是值类型和引用类型。</p>
<blockquote>
<ul>
<li>值类型：每个实例都拥有数据的一份副本。当被赋值给一个变量或常量，或传递给一个函数时，它都会拷贝一份新的副本。</li>
<li>引用类型：所有实例共享一个数据副本。当被赋值给一个变量或常量，或传递给一个函数时候，一个引用类型一旦被初始化，会返回一个指向已存在实例的引用。</li>
</ul>
</blockquote>
<p>&emsp;&emsp;类(class)是一个引用类型，复制一个引用，即表示建立一个共享的实例。复制之后，两个变量都使用数据中同一份实例。<br>&emsp;&emsp;类(Class)是一个引用类型，意味着类中的变量不会存储实例，而是一个向内存(堆)中存储该实例位置的引用。</p>
<a id="more"></a>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"张三"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> badStudent = <span class="type">People</span>()</span><br><span class="line"><span class="keyword">var</span> goodStudent = badStudent</span><br><span class="line"></span><br><span class="line">goodStudent.name = <span class="string">"李四"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"badStudent's name:\(badStudent)"</span>) <span class="comment">// 李四</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"goodStudent's name:\(goodStudent)"</span>) <span class="comment">// 李四</span></span><br><span class="line"><span class="comment">// 修改goodStudent中的内容就相当于修改badStudent。它们所代表的是同一个东西。</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;但除了Class外，Swift还有一种常用的类型：结构体。而结构体就是一个值类型。而Swift中用Struct的场景变多了。<br>类似<code>Array</code>、<code>Dictonary</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"张三"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> firstStudent = <span class="type">People</span>()</span><br><span class="line"><span class="keyword">var</span> secondStudent = firstStudent</span><br><span class="line"></span><br><span class="line">firstStudent.name = <span class="string">"李四"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"firstStudent's name:\(firstStudent)"</span>) <span class="comment">// 李四</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"secondStudent's name:\(secondStudent)"</span>) <span class="comment">// 张三</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// secondStudent用firstStudent赋值后，就是一个独立的数据实例了。</span></span><br></pre></td></tr></table></figure>
<p>当然，Swift中值类型和引用类型还有很多：</p>
<p><img src="http://cc.cocimg.com/api/uploads//20180503/1525333385999865.png" alt="Swift中值类型和引用类型表"></p>
<blockquote>
<p>Swift把一个引用类型看成一个类，这和Objective-C中很像。Objective-C中一切继承于NSObject都被按照引用类型存储。</p>
</blockquote>
<h3 id="什么时候用值引用和引用类型好"><a href="#什么时候用值引用和引用类型好" class="headerlink" title="什么时候用值引用和引用类型好"></a>什么时候用值引用和引用类型好</h3><ul>
<li>以下时候使用值类型：</li>
</ul>
<p>想要用==比较实例数据。一个双等号(==)用于比较值。</p>
<p>你想复制来建立独立数据。</p>
<p>数据要在多线程的代码中使用，那么你就不用担心数据会被其他线程改变。</p>
<ul>
<li>以下时候使用引用类型(比如一个类)：</li>
</ul>
<p>想要用==比较实例一致性。==会检查两个对象是否完全一致，包括存储数据的内存地址。</p>
<p>你想要创建用于共享，可改变的数据。</p>
<hr>
<h3 id="值类型和引用类型的存储"><a href="#值类型和引用类型的存储" class="headerlink" title="值类型和引用类型的存储"></a>值类型和引用类型的存储</h3><blockquote>
<p>值类型-在栈内存中存储、而引用类型-在托管堆内存中存储。</p>
</blockquote>
<p>像前面说的，引用类型实例存在堆中，值类型实例比如结构存在于一个称为栈的内存区域中。如果值类型实例是一个类的一部分，值会和类一起存在堆中。</p>
<p>栈被用于静态存储分配，栈用于动态存储分配，它们都存在计算机的RAM中。</p>
<p>栈被CPU紧密管理并优化，当一个函数创建一个变量，栈会存储这个变量，并在函数退出时候被毁掉。被分配到栈的变量直接存储在内存上，访问这段内存非常快。当一个函数或者方法调用另一个函数，另一个函数再依次调用其他函数等等，直到最后一个函数返回它的值之前，其他所有函数都会保持暂停执行。</p>
<p>栈总是按照LIFO顺序保留，最新保留的区块总是会下一个释放。这使得跟踪记录栈非常简单，释放一个栈上的区块不过是调整一个指针。因为栈非常组织有序，所以它快捷高效。</p>
<p>系统使用堆存储被其他对象引用的数据，堆是一大片内存，系统可以从中请求并动态分配内存区块。堆并不会像栈一样自动毁掉它的对象，需要外部工作来处理这些。在苹果设备中ARC就做这个工作。引用数量会被ARC追踪，当它变为0时对象会被释放。因此整个过程(分配，追踪引用，释放)会比栈要慢。所以值类型要快于引用类型。</p>
<h2 id="二、Swift中的Array"><a href="#二、Swift中的Array" class="headerlink" title="二、Swift中的Array"></a>二、Swift中的Array</h2><p>&emsp;&emsp;在OC中数组可以copy或者mutablecopy，可变数组和不可变数组可以来回拷贝数据。NSArray、NSMutableArray之间是不同点实例，来回处理过后，内部存储的元素其实指针所指向内容都是同一个。</p>
<p>而在Swift中常用的数组对象<code>Array</code>。跳转到其定义处：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Array</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;发现其实Array是一个结构体，是一个值类型，且不自带copy方法的方法，数组分成:可变数组和不可变数组，分别使用let修饰的数组是不可变数组，使用var修饰的数组是可变数组。如果想要实现拷贝方法，则需要对对象实现拷贝方法。即遵守NSCopying协议和实现copyWithZone方法<br>eg:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现NSCopying协议。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">NSObject</span>, <span class="title">NSCopying</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">copyWithZone</span><span class="params">(zone: NSZone)</span></span> -&gt; <span class="type">AnyObject</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> person = <span class="type">Person</span>()</span><br><span class="line">        person.name = <span class="keyword">self</span>.name</span><br><span class="line">        person.age = <span class="keyword">self</span>.age</span><br><span class="line">        <span class="keyword">return</span> person</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;所以在Swift中，像Array、Dictinary和Set这样的值类型集合，注意和OC中的NSArray、NSDictionary和NSSet有区别了。当被传递后，将会拷贝一份副本，之前那份数据的变更后面并不会同步更新过来，这点需要注意点。刚开始在这儿按照OC的惯性思维遇到了数据不一致的问题。另外提一句，像Array、Dictionary和Set这些是通过一个叫写时复制 (copy-on-write)的技术实现。<br>（简单提一下：就是为了提供高效的写时复制特性，我们需要知道一个对象 (比如这里的 NSMutableData) 是否是唯一的。如果它是唯一引用，那么我们就可以直接原地修改对象。否则，我们需要在修改前创建对象的复制。）。</p>
<p>—- 完 —-</p>
]]></content>
      
        <categories>
            
            <category> Swift </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift中常见的`$0` `$1`有什么用？]]></title>
      <url>http://www.lydsnm.top/2017/09/08/Swift%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84$0%E4%BD%9C%E7%94%A8/</url>
      <content type="html"><![CDATA[<p><code>$0</code>，<code>$1</code>… 是对闭包中参数的简化写法</p>
<p>&emsp;&emsp;swift自动为 <b><font color="red">闭包</font></b> 提供参数名缩写功能，可以直接通过<code>$0</code>和<code>$1</code>等来表示闭包中的第一个第二个参数，并且对应的参数类型会根据函数类型来进行判断。如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用`$0` `$1`这些来代替</span></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>]</span><br><span class="line">        sortNumbers = numbers.sorted(by: &#123; (a, b) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> a &lt; b</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"numbers -"</span> + <span class="string">"\(sortNumbers)"</span>)</span><br><span class="line"><span class="comment">// 使用$0,$1</span></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>]</span><br><span class="line"> <span class="keyword">var</span> sortNumbers = numbers.sorted(by: &#123;$<span class="number">0</span> &lt; $<span class="number">1</span>&#125;)</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">"numbers -"</span> + <span class="string">"\(sortNumbers)"</span>)</span><br></pre></td></tr></table></figure>
 <a id="more"></a>
<p>&emsp;&emsp;使用<code>$0</code>、<code>$1</code>的话，参数类型可以自动判断，并且<code>in</code>关键字也可以省略，也就是只用写函数体就可以了。来看看另外个例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = &#123; (arg1: <span class="type">Int</span>, arg2: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2</span><br><span class="line">&#125;</span><br><span class="line">add = &#123; (arg1, arg2) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2</span><br><span class="line">&#125;</span><br><span class="line">add = &#123; arg1, arg2 <span class="keyword">in</span></span><br><span class="line">    arg1 + arg2</span><br><span class="line">&#125;</span><br><span class="line">add = &#123;</span><br><span class="line">    $<span class="number">0</span> + $<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = add(<span class="number">10</span>, <span class="number">10</span>) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<p>—– 完 —–</p>
]]></content>
      
        <categories>
            
            <category> swift </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[关于术业有专攻的小小感悟]]></title>
      <url>http://www.lydsnm.top/2017/09/01/%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%B0%8F%E7%9A%84%E7%BB%8F%E9%AA%8C/</url>
      <content type="html"><![CDATA[<p>那就是 <b><font color="a52a2a" size="5">写些小工具如果要发布，还是和其他专业的人合作比较好一些。</font></b></p>
<a id="more"></a>
<p>&emsp;&emsp;最近在做一个项目，在APP的菜单结构犯了难，不知道该用这种比较符合。我的目的是尽量精致而简洁，没有一些花里胡哨的设计内容。<br>&emsp;&emsp;今天突然就想记录一下。也贴出来一些，我觉得还可以的设计。就算不在现在在做的sideProject中用，以后也有用的到的。</p>
<p>&emsp;&emsp;以前只是了解术业有专攻，每个人都不可能每个方面都擅长。跑道上领先的都是很懂的合作的人<del>~</del>~~</p>
]]></content>
      
        <categories>
            
            <category> Swift </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Slice 一个小而简的Mac计时软件.拖延症神器.倒计时小工具]]></title>
      <url>http://www.lydsnm.top/2017/05/30/Slice%E4%B8%80%E4%B8%AA%E5%B0%8F%E8%80%8C%E7%B2%BE%E7%AE%80%E7%9A%84Mac%E8%AE%A1%E6%97%B6%E8%BD%AF%E4%BB%B6%EF%BC%8C%E6%8B%96%E5%BB%B6%E7%97%87%E7%A5%9E%E5%99%A8%EF%BC%8C%E5%80%92%E8%AE%A1%E6%97%B6%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;对于常年和电脑打交道的人群来说，在很多时候, 人往往变得浮躁, 坐在电脑旁不到几分钟就像打开网页看视频啊, 打开游戏, 干些不相关的东西，专注力不够，从而导致工作效率低，工作质量不高的效果，进而影响到我们的生活，心情等。<br>        现在你试试这个小工具：<br><img src="http://ocs32tleq.bkt.clouddn.com/14961482427792.jpg" alt=""></p>
<p>&emsp;&emsp;有研究表明，合理的运用人的精力，松紧有弛，能够最大限度的发挥人的能力。自然界本身有它的脉动，一种在活动和休息之间周期性的像波浪一样的运动。想想潮涨潮落、季节变化，以及每天的日出日落。同样，所有的机体都遵循一种维持生命的有规则的变化。就像运动员，我们发现那些成绩好的运动员往往更懂得如何放松和规划自己的精力，在高强度，长时间，高压力的比赛中，很难保持长时间的高水准，因此这些人通常会抓紧一切时间储存精力，等到需要的爆发的时候，集中全部的注意力，更能发挥出好的运动水平，对于普通人，这也同样适用。</p>
<a id="more"></a>
<p><img src="http://ocs32tleq.bkt.clouddn.com/%E5%92%96%E5%95%A1.jpg" alt="咖啡"></p>
<p>&emsp;&emsp;现在针对这种情况，您可以使用Slice这个小工具，别看它小，但是简洁简单有效，可以有效指定完成某项工作要花的时间，让您有一种紧迫感来做事，进而提高注意力提高工作效率。也可以用来控制工作时间，毕竟人的精力精神不会连续好几个小时高度保持注意，懂得平衡的奥秘，累了，渴了不如出去走走，喝喝水，看看远方，说不定工作的难题就在这些休息过程中想到的最佳的解决方案la😄。</p>
<h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><p><img src="http://ocs32tleq.bkt.clouddn.com/14961479652001.jpg" alt=""></p>
<p>写好要做的事，订好一个时间，就可以开始啦。</p>
<p>&emsp;&emsp;还可以做一些小的设置：<br><img src="http://ocs32tleq.bkt.clouddn.com/14961482832008.jpg" alt=""></p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul>
<li>自定义下一件唯一要做的事，让你专注于工作中…</li>
<li>自定义提示文字信息。</li>
<li>可简单控制结束的音效播放。</li>
<li>CPU 占用率超低, 不会影响您的工作。</li>
</ul>
<p>&emsp;&emsp;总之，可以通过Slice，可以平复烦躁杂乱的心，专注于单线程，提升效率。</p>
<p><br></p>
<font size="6" color="10d3c4">您唯一要做的事就是自己要遵守自己定的要做的事</font>


<h3 id="可能遇到的问题："><a href="#可能遇到的问题：" class="headerlink" title="可能遇到的问题："></a>可能遇到的问题：</h3><p>&emsp;&emsp;针对某些用户所说，在10.11以后系统可能安装不了的情况。</p>
<p>可以在“设置”中“安全与隐私”的“通用”选项下， 设置<b>允许从任何来源的应用</b>。然后就可以正常使用Slice了。<br>因为Slice是本人在业余时间开发，并未上架App store，且OS X系统有这么一个保护机制，故有这样现象。</p>
<p><img src="http://ocs32tleq.bkt.clouddn.com/PastedGraphic-1-systemSettingforMac.png" alt="系统设置"></p>
<p>&emsp;&emsp;如果在这个地方没有“任何来源”一项的话，就需要打开系统应用“终端”，输入</p>
<p><code>sudo spctl --master-disable</code><br>然后再输入你的系统密码回车即可（不屏显）。</p>
<h3 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a>下载地址：</h3><p><a href="http://pan.baidu.com/s/1mium0J2" target="_blank" rel="noopener">Slice 1.0</a></p>
<p><br></p>
<h3 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h3><p>&emsp;&emsp;这个小的app希望对你有用。虽然很小，还还算有用，平时提醒喝喝茶或者短暂休息下。<br>如果你希望能更新此软件的功能，或者有什么建议或者意见，可以通过下面的方式联系我：<br><a href="mailto:dongingdao@163.com" target="_blank" rel="noopener">dongingdao@163.com</a></p>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tool </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS实现实时通信或推送的常用策略]]></title>
      <url>http://www.lydsnm.top/2017/04/20/iOS%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E9%80%9A%E4%BF%A1%E6%88%96%E6%8E%A8%E9%80%81%E7%9A%84%E5%B8%B8%E7%94%A8%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<h3 id="1-iOS静默推送，不含alert，没有声音没有弹框，具体更多可以看这儿"><a href="#1-iOS静默推送，不含alert，没有声音没有弹框，具体更多可以看这儿" class="headerlink" title="1.iOS静默推送，不含alert，没有声音没有弹框，具体更多可以看这儿"></a>1.iOS静默推送，不含alert，没有声音没有弹框，具体更多可以看<a href="http://blog.csdn.net/hherima/article/details/50469519" target="_blank" rel="noopener">这儿</a></h3><p>限制与注意：<br><code>Silent Remote Notifications</code>是在Apple的限制下有一定的频率控制，并不是所有的静默推送都能按预期到达客户端触发函数的。<br>前提：客户端需处于Background或Suspended状态。<br>Apple 官方文档说：<a href="https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html" target="_blank" rel="noopener">Configuring a Silent Notification</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Silent notifications are not meant as a way to keep your app awake in the background, nor are they meant for high priority updates. APNs treats silent notifications as low priority and may throttle their delivery altogether if the total number becomes excessive. The actual limits are dynamic and can change based on conditions, but try not to send more than a few notifications per hour.</span><br></pre></td></tr></table></figure>
<p>用户如果禁止了推送权限，还能收到静默推送吗？这将是一个问题。</p>
<a id="more"></a>
<h3 id="2-轮询"><a href="#2-轮询" class="headerlink" title="2.轮询"></a>2.轮询</h3><p>1.Http polling<br>2.Http Long-polling</p>
<blockquote>
<p>Http polling也就是轮询的策略，它唯一的优点就是实现简单，技术门槛低。但是缺点也很明显：不够实时，且效率低下，导致server端负载较高。</p>
</blockquote>
<blockquote>
<p>Http Long-polling（长轮询，也称作comet）技术，是在Http polling基础上优化而来。在长轮询策略下，当server端没有数据推送到client端时，请求不会立即返回，而是被server端hold住，直到有数据发送，或者超时，才发送响应。Client端收到响应之后，立即重新发起http请求。<br>这种策略比简单的轮询优化了许多，但开发和维护成本也提高了许多。并且，效率还不够高，存在资源的浪费。而这主要是因为http协议头本身带来的overhead。</p>
</blockquote>
<h3 id="3-长连接"><a href="#3-长连接" class="headerlink" title="3.长连接"></a>3.长连接</h3><blockquote>
<p>Socket长连接是目前认为优点最多的解决方案。这一方案的原理是client端向server端建立一个TCP长连接，通过心跳的机制维护连接畅通，当有数据需要交互时，双方都可以通过这个长连接进行通信。</p>
</blockquote>
<blockquote>
<p>多年前这种方案无法应用在浏览器端，然而随着html5的兴起和浏览器的发展，目前主流的浏览器都已经支持websocket了，可以很好的实现长连接。</p>
</blockquote>
<blockquote>
<p>Socket长连接是最理想的方案，但开发成本也相应的最高。服务端需要支持大量的连接数，且长连接本身的特性也决定了服务不再是无状态的，这给服务的稳定性和可扩展性带来了一定的挑战。</p>
</blockquote>
<h2 id="评估："><a href="#评估：" class="headerlink" title="评估："></a>评估：</h2><p>从成本来说，客户端轮询请求 服务器压力最小，但是不太敏感<br>tcp长连接呢，服务器压力大些，但是消息及时。</p>
<p>iOS如果要用socket长连接的话，可以用<a href="http://www.cocoachina.com/ios/20160602/16572.html" target="_blank" rel="noopener">这篇文章</a>提到的<a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="noopener">CocoaAsyncSocket</a></p>
<p>可以用<code>CocoaAsyncSocket</code>先写一个<a href="http://www.cnblogs.com/XYQ-208910/p/5169209.html" target="_blank" rel="noopener">Demo</a></p>
<p>如果想了解更多CocoaAsyncSocket可以从这篇文章入手：<a href="http://www.cocoachina.com/ios/20170127/18619.html" target="_blank" rel="noopener">iOS即时通讯进阶 - CocoaAsyncSocket源码解析(Connect篇)</a></p>
<p>备选：<a href="https://github.com/facebook/SocketRocket" target="_blank" rel="noopener">SocketRocket</a></p>
<hr>
<p>— 备注区，不算入文章内。</p>
<ul>
<li>其他</li>
</ul>
<p>&emsp;&emsp;建立tcp连接，定期发keep alive防止socket超时断开。发消息直接发tcp数据包。<br>或者直接用第三方的push notification服务。原理类似，只不过平台统一keep alive省电。需要注册在服务提供方注册。</p>
<p>&emsp;&emsp;服务端给客户端推送，普遍做法是客户端与服务端维持一个长连接，客户端定时向服务端发送心跳以维持这个长连接。当有新消息过来的时候，服务端查出该消息对应的TCP Channel的ID并找到对应的通道进行消息下发。</p>
<p>&emsp;&emsp;国内安卓应用，如果没有使用GCM，绝大多数没有使用，那就起后台Service定时唤醒系统查询，一个是为了保持心跳，一个是为了查询消息。这种机制非常浪费运营商的资源，也非常费电。所以，建议把所有的应用设置都看清楚，尽量选择非推送。尤其是天气预报，手工查一下就行了，否则，那个所谓的墨迹天气，5分钟查一次，频率比得上微信了。完全没有必要，太费电了。要是赶上小区拥堵的情况，频繁的PDP激活，建立RRC连接，再释放，电池消耗特别大。而且还会发热，用户体验会很糟糕。</p>
<p>&emsp;&emsp;连接都是由客户端发起的！（因为客户端通常在子网下，没有公网IP，根本没办法接受连接）所谓『推送』的实现方式无外乎两种：一是基于长连接，客户端发起连接，双方维护这个连接，服务器端有变动随时拿这个连接通知客户端。这就是正常意义上的『推送』。二是基于短连接，客户端轮询发起短连接，询问服务器端变化。这实际上是『拉取』，并不是『推送』。燃鹅，维护连接的成本太大了，除了即时性要求苛刻的场景之外，大家普遍采用了第二种方法。</p>
<h3 id="iOS中应用内部实现长连接发送接受机制。"><a href="#iOS中应用内部实现长连接发送接受机制。" class="headerlink" title="iOS中应用内部实现长连接发送接受机制。"></a>iOS中应用内部实现长连接发送接受机制。</h3><ol>
<li>基于Http的长连接。（用的比较少）</li>
<li>基于Socket的长连接。</li>
<li>基于xmpp的消息P2P消息机制</li>
</ol>
<p>貌似普通的socket连接对服务器的消耗太大了。（是否有其他协议，比较有名的是MQTT协议）</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[对UIMenuController菜单自定义]]></title>
      <url>http://www.lydsnm.top/2017/02/06/%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89UIWebView%20%E7%9A%84UIMenuController%E9%80%89%E9%A1%B9/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;项目中遇到了需要对UIWebView中弹出菜单的一些定制，所以查找一些资料，整理记录一下。</p>
<p>首先看看UIMenuController默认支持的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)cut:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)<span class="keyword">copy</span>:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)paste:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)select:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)selectAll:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)delete:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_2);</span><br><span class="line">- (<span class="keyword">void</span>)makeTextWritingDirectionLeftToRight:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)makeTextWritingDirectionRightToLeft:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)toggleBoldface:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)toggleItalics:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)toggleUnderline:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)increaseSize:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)decreaseSize:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更多带_的私有方法可以看: https://yq.aliyun.com/articles/39475</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>而我们常用的是<code>cut</code>，<code>copyt</code>，<code>past</code>，<code>selct</code>等。因此主要是对这几个方法的处理。</p>
<h3 id="实现自定义菜单（UITextView、UITextField）"><a href="#实现自定义菜单（UITextView、UITextField）" class="headerlink" title="实现自定义菜单（UITextView、UITextField）"></a>实现自定义菜单（UITextView、UITextField）</h3><p>&emsp;&emsp;要想实现自定义显示的长按文字菜单, subClass UIWebViewController. 然后重写方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">BOOL</span>)canPerformAction:(SEL)action withSender:(<span class="keyword">id</span>)sender&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">@selector</span>(selectAll:) || action == <span class="keyword">@selector</span>(cut:)\</span><br><span class="line">        || action == <span class="keyword">@selector</span>(delete:)\</span><br><span class="line">        || action == <span class="keyword">@selector</span>(toggleUnderline:)\</span><br><span class="line">        || action == <span class="keyword">@selector</span>(toggleBoldface:)\</span><br><span class="line">        || action == <span class="keyword">@selector</span>(toggleItalics:)\</span><br><span class="line">        || action == <span class="built_in">NSSelectorFromString</span>(<span class="string">@"_showTextStyleOptions:"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> canPerformAction:action withSender:sender];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可编辑的UIWebView自定义UIMenuController选项"><a href="#可编辑的UIWebView自定义UIMenuController选项" class="headerlink" title="可编辑的UIWebView自定义UIMenuController选项"></a>可编辑的UIWebView自定义UIMenuController选项</h3><p>&emsp;&emsp;前期尝试过创建UIWebView之类, 然后重写<code>canPerformAction:(SEL)action withSender:(id)sender</code>方法来控制显示和隐藏哪些菜单项, 但是发现不行(UITextView等可以)。查看UIWebView的subViews, 可以发现一个类: <font color="a52a2a">UIWebBrowserView</font>which has a text property, from this we know what class we need to subclass.然而这个UIWebBrowserView又是一个私有类,通过正常方式又获取不到.<br>思路有两个: 一个是通过运行时替换这个class的方法成我们自己的方法。二是通过创建<code>UIWebBrowserView</code>的类别，并用我们的方法替换掉原来的方法(私有API,传App Store会被打回)。</p>
<hr>
<h4 id="1-通过runtime替换方法"><a href="#1-通过runtime替换方法" class="headerlink" title="1. 通过runtime替换方法"></a>1. 通过runtime替换方法</h4><p>添加方法<code>mightPerformAction:withSender:</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)mightPerformAction:(SEL)action withSender:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"******Action!! %@******"</span>,<span class="built_in">NSStringFromSelector</span>(action));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (action == <span class="keyword">@selector</span>(<span class="keyword">copy</span>:))</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"Copy Selector"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (action == <span class="keyword">@selector</span>(cut:))</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"cut Selector"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (action == <span class="built_in">NSSelectorFromString</span>(<span class="string">@"_define:"</span>))</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"define Selector"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (action == <span class="keyword">@selector</span>(paste:))</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"paste Selector"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">return</span> [<span class="keyword">super</span> canPerformAction:action withSender:sender];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是替换旧的<code>canPerformAction:action withSender:sender</code>方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) replaceUIWebBrowserView: (<span class="built_in">UIView</span> *)view</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Iterate through subviews recursively looking for UIWebBrowserView</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">UIView</span> *sub <span class="keyword">in</span> view.subviews) &#123;</span><br><span class="line">    [<span class="keyword">self</span> replaceUIWebBrowserView:sub];</span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSStringFromClass</span>([sub <span class="keyword">class</span>]) isEqualToString:<span class="string">@"UIWebBrowserView"</span>]) &#123;</span><br><span class="line"></span><br><span class="line">        Class <span class="keyword">class</span> = sub.class;</span><br><span class="line"></span><br><span class="line">        SEL originalSelector = <span class="keyword">@selector</span>(canPerformAction:withSender:);</span><br><span class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(mightPerformAction:withSender:);</span><br><span class="line"></span><br><span class="line">        Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(<span class="keyword">self</span>.class, swizzledSelector);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//add the method mightPerformAction:withSender: to UIWebBrowserView</span></span><br><span class="line">        <span class="built_in">BOOL</span> didAddMethod =</span><br><span class="line">        class_addMethod(<span class="keyword">class</span>,</span><br><span class="line">                        originalSelector,</span><br><span class="line">                        method_getImplementation(swizzledMethod),</span><br><span class="line">                        method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        <span class="comment">//replace canPerformAction:withSender: with mightPerformAction:withSender:</span></span><br><span class="line">        <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">            class_replaceMethod(<span class="keyword">class</span>,</span><br><span class="line">                                swizzledSelector,</span><br><span class="line">                                method_getImplementation(originalMethod),</span><br><span class="line">                                method_getTypeEncoding(originalMethod));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在ViewController的viewDidLoad中调用</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> replaceUIWebBrowserView:<span class="keyword">self</span>.webView];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意1: 在viewController中添加 #import &lt;objc/runtime.h&gt; 避免 error(Method).</p>
</blockquote>
<blockquote>
<p>注意2:  使用<code>NSSelectorFromString</code>方法避免审核过程中被检测到使用到了私有API.</p>
</blockquote>
<p>参考: <a href="http://stackoverflow.com/questions/25263687/disable-long-press-menu-in-text-area-input-uiwebview/25263688#25263688" target="_blank" rel="noopener">http://stackoverflow.com/questions/25263687/disable-long-press-menu-in-text-area-input-uiwebview/25263688#25263688</a> </p>
<h4 id="2-通过扩展类别"><a href="#2-通过扩展类别" class="headerlink" title="2.通过扩展类别"></a>2.通过扩展类别</h4><p>另外在查找资料的过程中还发现种方法(UIWebBrowserView), 但是这种方法使用到了私有api, 会被打回. 切记:<br><a href="http://www.ios-blog.co.uk/tutorials/rich-text-editing-highlighting-and-uimenucontroller-part-3/" target="_blank" rel="noopener">http://www.ios-blog.co.uk/tutorials/rich-text-editing-highlighting-and-uimenucontroller-part-3/</a></p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> -runtime -运行时 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OC开发相关注意事项]]></title>
      <url>http://www.lydsnm.top/2016/10/20/OC%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%9B%9B/</url>
      <content type="html"><![CDATA[<h2 id="第7章-熟悉系统框架"><a href="#第7章-熟悉系统框架" class="headerlink" title="第7章 熟悉系统框架"></a>第7章 熟悉系统框架</h2><p>将一系列代码封装为动态库 (dynamic library) , 并在其中放入描述其借口的头文件, 这样做出来的东西就叫 <font color="a52a2a">框架</font> .有时为 iOS 平台构建的第三方框架实用的是静态库 (static libaray), 这是因为 iOS 应用程序不允许在其中包含动态库.</p>
<p>开发者主要会碰到<code>Foundation</code>, 像是 <code>NSOject</code>, <code>NSArray</code>, <code>NSDictionary</code> 等类都在其中, <code>Foundation</code> 是应用程序的 “基础”.</p>
<p>还有个与 <code>Foundation</code> 相伴的框架, 叫做 <code>CoreFoundation</code> , 从技术上来将, <code>CoreFoundation</code> 框架不是 <code>Objective-C</code> 框架, 但它是编写 <code>Objective-C</code> 应用程序时所应熟悉的重要框架. <code>Foundation</code> 框架中的很多功能, 都可以在此框架中找到对应的 C 语言 API. 可以用”无缝桥接”(tollfree bridging). 可以吧 <code>CoreFoundation</code> 中的 C 语言数据结构平滑转换为 <code>Foundation</code>中的 Objective-C 对象.</p>
<p>除了<code>Foundation</code> 还有 <code>CFNetwork</code> , <code>CoreAudio</code>, <code>AVFoundation</code>, <code>CoreData</code>, <code>CoreText</code> ….</p>
<a id="more"></a>
<p><br></p>
<h3 id="1-构建缓存时选用-NSCache-而非-NSDictionary"><a href="#1-构建缓存时选用-NSCache-而非-NSDictionary" class="headerlink" title="1. 构建缓存时选用 NSCache 而非 NSDictionary"></a>1. 构建缓存时选用 <code>NSCache</code> 而非 <code>NSDictionary</code></h3><p>因为 <code>NSCache</code> 可以提供优雅的自动删减功能, 而且是 “线程安全的”. 此外, 它与字典不同, 不会拷贝键.<br>可以给 <code>NSCache</code> 对象设置上限, 用以限制缓存中的对象总个数及”总成本”<br>将 <code>NSPurgeableData</code> 与 <code>NSCache</code> 搭配使用, 可实现自动清除数据的功能.</p>
<h3 id="2-loadView-amp-initialize"><a href="#2-loadView-amp-initialize" class="headerlink" title="2. loadView &amp; initialize"></a>2. <code>loadView</code> &amp; <code>initialize</code></h3><p><code>loadView</code> &amp; <code>initialize</code> 中的代码要尽量精简.这有助于保持应用程序的响应能力, 也能减少引入 “依赖环” 的几率.</p>
<p><code>initialize</code>是惰性调用的, 只有当程序用到了相关的类时, 才会调用. 而对于<code>loadView</code>来说, 应用程序必须阻塞并等着所有类的 load 都执行万, 才能继续.</p>
<p><code>initialize</code>方法 只应该用来设置内部数据.</p>
<ul>
<li>在加载阶段, 如果类实现了 load 方法, 那么系统就会调用它. 分类里也可以定义此方法, 类的 load 方法要比分类中的先调用.</li>
<li>首次实用某个类之前, 系统会向其发送 <code>initialize</code> 消息. 由于此方法遵从普通的覆写规则, 所以通常应该在里面判断当前要初始化的是哪个类.</li>
<li>无法在编译期设定的全局常量, 可以放在 <code>initialize</code> 方法里初始化.</li>
</ul>
<h3 id="3-NSTimer-会保留其目标对象"><a href="#3-NSTimer-会保留其目标对象" class="headerlink" title="3. NSTimer 会保留其目标对象."></a>3. NSTimer 会保留其目标对象.</h3><p>记得 手动调用或 <code>delloc</code> 方法中调用</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[_timer invalidate];</span><br><span class="line">_timer = <span class="literal">nil</span>;</span><br></pre></td></tr></table></figure>
<p>反复执行任务的计时器, 很容易引入保留环.</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>快速遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(for ... in ...)</span><br></pre></td></tr></table></figure></p>
<hr>
<p><br></p>
<p>本篇文章参考摘自 <font color="#B8860B">Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的52个有效方法</font></p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OC开发相关注意事项]]></title>
      <url>http://www.lydsnm.top/2016/10/19/OC%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%89/</url>
      <content type="html"><![CDATA[<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>ARC :<code>Automatic Reference Counting,ARC</code>, ARC 几乎把所有内存管理事宜都交由编译器来决定, 开发者只需专注于业务逻辑.</p>
<h3 id="1-引用计数"><a href="#1-引用计数" class="headerlink" title="1. 引用计数"></a>1. 引用计数</h3><p>Objective-C 语言实用引用计数来管理内存. 每个对象都有个可以递增和递减的计数器, 用以标识当前有多个事情想令此对象继续存活下去.<br>计数<font color="#A52A2a">>=0</font>表示对象继续存活. 当保留计数降为<font color="#A52A2a"> 0 </font>后, 对象就会被释放了.</p>
<p>ARC 只负责管理 <code>Objective-C</code> 对象的内存. 注意: <font color="#A52A2a">CoreFoundation</font>对象不归 ARC 管理, 开发者必须适时调用 <font color="#A52A2a">CFRetain/CFRelease</font>.</p>
<h3 id="2-在-dealloc-方法中只释放引用并解除监听"><a href="#2-在-dealloc-方法中只释放引用并解除监听" class="headerlink" title="2. 在 dealloc 方法中只释放引用并解除监听"></a>2. 在 dealloc 方法中只释放引用并解除监听</h3><p>对象在经历其生命周期后, 最终会为系统所回收, 这时就要执行 <code>dealloc</code> 方法了. 在每个对象的生命周期内, 此方法仅执行以此. 也就是但保留计数降为 0 的时候.</p>
<p>虽说应该于 <code>dealloc</code> 中释放引用, 但是开销较大或系统内稀缺的资源则不在此列 ,像是文件描述符( file descriptor ), 套接字 (socket), 大块内存等都属于这种资源. 不能指望 <code>dealloc</code> 方法必定会在某个特定的时机调用, 因为有一些无法预料的东西可能也会持有此对象. 在这种情况下, 如果非要等到系统调用 <code>dealloc</code> 方法时才释放, 那么保留这些稀缺资源的时间就太长了, 这么做不合适. 通常的做法时, 实现另外一个方法, 但应用程序用完资源对象后, 就调用此方法 (例如 <font color="#A52A2a">Open</font> 对应 <font color="#A52A2a">Close</font> 方法) . 这样一来, 资源对象的生命期就变得更明确了.</p>
<a id="more"></a>
<h3 id="3-以-“自动释放池块”-降低内存峰值"><a href="#3-以-“自动释放池块”-降低内存峰值" class="headerlink" title="3. 以 “自动释放池块” 降低内存峰值"></a>3. 以 “自动释放池块” 降低内存峰值</h3><p>在 Objective-C 的引用计数架构中, 有一项特性叫做 “<font color="#A52A2a">自动释放池</font>“ (autorelease pool). 释放对象有两种方式: 一种时调用 <code>release</code> 方法, 另一种时调用 <code>autorelease</code> 方法, 将其降入 “自动释放池” 中. 自动释放池用于存放那些需要在稍后某个时刻释放的对象. 清空(drain)自动释放池时, 系统会向其中的对象发送 <code>release</code> 消息.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)&#123;</span><br><span class="line">		[<span class="keyword">self</span> doSomethingWithInt:i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <font color="#A52A2a">自动释放池</font> 来降低应用程序的 <font color="#A52A2a">峰值内存</font>.</p>
<p><br></p>
<hr>
<h2 id="block与GCD"><a href="#block与GCD" class="headerlink" title="block与GCD"></a>block与GCD</h2><p>GCD 是一种与块有关的计数, 它提供了对线程的抽象, 而这种抽象则机遇 “派发队列”(<code>dispatch queue</code>). 开发者可将块排入队列中, 由 GCD 负责处理所有调度事宜.</p>
<h3 id="1-block"><a href="#1-block" class="headerlink" title="1. block"></a>1. block</h3><p>每个 Objective-C 对象都占据着某个内存区域. 因为实例变量的个数及对象所包含的关联数据不同, 所以每个对象所占的内存区域也有大有小. 块对象也是对象, 在存放块对象的内存区域中, 首个变量时指向 Class 对象的指针, 该指针叫做 <font color="A52A2A">isa</font> .其余内存里含有块对象正常运转所需的各种信息.</p>
<p><img src="http://ocs32tleq.bkt.clouddn.com/blockMemory.png" alt="块对象的内存布局"></p>
<p>在内存布局中, 最重要的时 <font color="a52a2a">invoke</font> 变量, 这是个函数指针, 指向块的实现代码. 块其实就是一种代替函数指针的语法结构.</p>
<p>定义块的时候, 其所占的内存是分配在 <font color="a52a2a">栈 </font>中的. 块只在定义它的那个范围有效. 编译器有可能把分配给块的内存覆写掉. 给 block 对象发送 copy 消息拷贝, 就拷贝到堆上, 块就成了带引用计数的对象了.后续的复制操作都不会真的执行复制, 只是增加对象的引用计数.</p>
<h3 id="2-GCD"><a href="#2-GCD" class="headerlink" title="2. GCD"></a>2. GCD</h3><p>少用 <code>performSelector</code> 系列方法, 用 GCD 相关方法来实现.</p>
<ul>
<li>通过 <code>Dispatch Group</code> 机制, 根据系统资源状况来执行任务.一系列任务可关于一个 <code>dispatch group</code> 中. 开发者可以再这组任务执行完毕时获得通知.</li>
</ul>
<p>使用下面这个函数可以创建 <code>dispatch group</code>:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_tdispatch_group_create();</span><br></pre></td></tr></table></figure>
<p>另外可选 使用 <code>dispatch_apply</code> 方法, 此函数会将块仿佛执行一定的次数, 每次传给块的参数值都会递增..</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIRITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">dispatch_apply(array.count, queue, ^(size_t i)&#123;</span><br><span class="line">	<span class="keyword">id</span> object = array[i];</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而, <code>dispatch_apply</code> 会持续阻塞队列, 直到所有任务都执行完毕为止. 若想到后台执行任务, 则应使用 <code>dispatch group</code></p>
<p>更多内容请看我的另外一篇 : <a href="http://www.donglyu.com/2016/02/08/GCD处理多个异步处理的同步方法/" target="_blank" rel="noopener">GCD 多任务</a></p>
<ul>
<li>使用 <code>dispatch_once</code> 来执行只需运行以此的线程安全代码.<br>单例模式中使用的多.</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)sharedInstance&#123;</span><br><span class="line">	<span class="keyword">static</span> EOCClass *sharedInstance = <span class="literal">nil</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">	<span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">		shareInstance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul>
<li>调试内存管理问题时, 可以将 <font color="#A52A2a">NSZombieEnabled</font> 环境变量设为 YES . 给僵尸对象(应该是是否的对象, 不应再被调用) 发送消息, 控制台会打印消息, 应用程序会终止.</li>
</ul>
<hr>
<p><br></p>
<p>本篇文章参考摘自 <font color="#B8860B">Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的52个有效方法</font></p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[本地推送之定时推送]]></title>
      <url>http://www.lydsnm.top/2016/10/18/%E6%9C%AC%E5%9C%B0%E6%8E%A8%E9%80%81%E4%B9%8B%E5%AE%9A%E6%97%B6%E6%8E%A8%E9%80%81/</url>
      <content type="html"><![CDATA[<p>项目中使用到了定时提醒推送, 故整理记录下来.</p>
<h2 id="iOS10-之前-使用旧的本地推送注册方式"><a href="#iOS10-之前-使用旧的本地推送注册方式" class="headerlink" title="iOS10 之前, 使用旧的本地推送注册方式:"></a>iOS10 之前, 使用旧的本地推送注册方式:</h2><h3 id="1-在-AppDelegate中代理注册使用通知-和注册远程通知一致"><a href="#1-在-AppDelegate中代理注册使用通知-和注册远程通知一致" class="headerlink" title="1. 在 AppDelegate中代理注册使用通知, 和注册远程通知一致"></a>1. 在 <code>AppDelegate</code>中代理注册使用通知, 和注册远程通知一致</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIMutableUserNotificationCategory</span> *categorys = [[<span class="built_in">UIMutableUserNotificationCategory</span> alloc] init];</span><br><span class="line"><span class="built_in">UIUserNotificationSettings</span> *userSettings = [<span class="built_in">UIUserNotificationSettings</span> settingsForTypes:<span class="built_in">UIUserNotificationTypeBadge</span>|<span class="built_in">UIUserNotificationTypeSound</span>|<span class="built_in">UIUserNotificationTypeAlert</span></span><br><span class="line">                                                                                    categories:[<span class="built_in">NSSet</span> setWithObject:categorys]];</span><br><span class="line">[[<span class="built_in">UIApplication</span> sharedApplication] registerUserNotificationSettings:userSettings];</span><br><span class="line">[[<span class="built_in">UIApplication</span> sharedApplication] registerForRemoteNotifications];</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="2-注册本地推送-在固定时间推送通知"><a href="#2-注册本地推送-在固定时间推送通知" class="headerlink" title="2. 注册本地推送,在固定时间推送通知"></a>2. 注册本地推送,在固定时间推送通知</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)RegisterLocalNotificationiOS10Before:(<span class="built_in">NSDate</span> *)time&#123;</span><br><span class="line">    <span class="built_in">UILocalNotification</span> *notification = [[<span class="built_in">UILocalNotification</span> alloc] init];</span><br><span class="line">    <span class="comment">// 设置触发通知的时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    NSDate *fireDate = [NSDate dateWithTimeIntervalSinceNow:10];</span></span><br><span class="line">    notification.fireDate = time; <span class="comment">// fireDate</span></span><br><span class="line">    <span class="comment">// 时区</span></span><br><span class="line">    notification.timeZone = [<span class="built_in">NSTimeZone</span> defaultTimeZone];</span><br><span class="line">    <span class="comment">// 设置重复的间隔</span></span><br><span class="line">    notification.repeatInterval = kCFCalendarUnitDay; <span class="comment">// 每天提醒.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知内容</span></span><br><span class="line">    notification.alertTitle = <span class="string">@"时光匆匆，我只在乎你"</span>;</span><br><span class="line">    notification.alertBody = <span class="string">@"今天有什么想要记录和分享吗？"</span>; </span><br><span class="line">    notification.applicationIconBadgeNumber = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 通知被触发时播放的声音</span></span><br><span class="line">    notification.soundName = <span class="built_in">UILocalNotificationDefaultSoundName</span>;</span><br><span class="line">    <span class="comment">// 通知参数</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *userDict = [<span class="built_in">NSDictionary</span> dictionaryWithObject:LPVMNoticeEveryDayKey forKey:LPVMNoticeEveryDayKey];</span><br><span class="line">    notification.userInfo = userDict;</span><br><span class="line">    </span><br><span class="line">    notification.repeatInterval = <span class="built_in">NSCalendarUnitDay</span>;</span><br><span class="line">    <span class="comment">// 执行通知注册</span></span><br><span class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] scheduleLocalNotification:notification];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-取消本地推送"><a href="#3-取消本地推送" class="headerlink" title="3. 取消本地推送"></a>3. 取消本地推送</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)CancelLocalNotificationWithKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="comment">// 获取所有本地通知数组</span></span><br><span class="line">    <span class="built_in">NSArray</span> *localNotifications = [<span class="built_in">UIApplication</span> sharedApplication].scheduledLocalNotifications;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UILocalNotification</span> *notification <span class="keyword">in</span> localNotifications) &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span> *userInfo = notification.userInfo;        </span><br><span class="line">        <span class="keyword">if</span> (userInfo) &#123;</span><br><span class="line">            <span class="comment">// 根据设置通知参数时指定的key来获取通知参数</span></span><br><span class="line">            <span class="built_in">NSString</span> *info = userInfo[key];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果找到需要取消的通知，则取消</span></span><br><span class="line">            <span class="keyword">if</span> (info != <span class="literal">nil</span>) &#123;</span><br><span class="line">                [[<span class="built_in">UIApplication</span> sharedApplication] cancelLocalNotification:notification];</span><br><span class="line">                DLog(<span class="string">@"移除一条注册了的本地推送"</span>);   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><br></p>
<h2 id="iOS-10后本地定时推送"><a href="#iOS-10后本地定时推送" class="headerlink" title="iOS 10后本地定时推送"></a>iOS 10后本地定时推送</h2><h3 id="1-注册推送"><a href="#1-注册推送" class="headerlink" title="1. 注册推送"></a>1. 注册推送</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)RegisterLocalNotificationiOS10Later:(<span class="built_in">NSDate</span> *)time&#123;</span><br><span class="line">    <span class="comment">// 使用 UNUserNotificationCenter 来管理通知</span></span><br><span class="line">    UNUserNotificationCenter* center = [UNUserNotificationCenter currentNotificationCenter];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//需创建一个包含待通知内容的 UNMutableNotificationContent 对象，注意不是 UNNotificationContent ,此对象为不可变对象。</span></span><br><span class="line">    UNMutableNotificationContent* content = [[UNMutableNotificationContent alloc] init];</span><br><span class="line">    content.title = [<span class="built_in">NSString</span> localizedUserNotificationStringForKey:<span class="string">@"时光匆匆，我只在乎你"</span> arguments:<span class="literal">nil</span>];</span><br><span class="line">    content.body = [<span class="built_in">NSString</span> localizedUserNotificationStringForKey:<span class="string">@"今天有什么想要记录和分享吗？"</span> arguments:<span class="literal">nil</span>];</span><br><span class="line">    content.sound = [UNNotificationSound defaultSound];</span><br><span class="line">    content.userInfo = [<span class="built_in">NSDictionary</span> dictionaryWithObject:LPVMNoticeEveryDayKey forKey:LPVMNoticeEveryDayKey];</span><br><span class="line">    <span class="comment">// 1.在一段时间后推送本地推送</span></span><br><span class="line">	<span class="comment">//UNTimeIntervalNotificationTrigger* trigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:10 repeats:NO];</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSDateComponents</span> *components = [[<span class="built_in">NSDateComponents</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSCalendar</span> *cal = [<span class="built_in">NSCalendar</span> currentCalendar];</span><br><span class="line">    <span class="built_in">NSInteger</span> unitFlags = <span class="built_in">NSCalendarUnitHour</span> | <span class="built_in">NSCalendarUnitMinute</span>;<span class="comment">//NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit;</span></span><br><span class="line">    <span class="built_in">NSDateComponents</span> *dd = [cal components:unitFlags fromDate:time];</span><br><span class="line"></span><br><span class="line">    components.hour = [dd hour];</span><br><span class="line">    components.minute = [dd minute]; <span class="comment">// 例如每日21:00时推送</span></span><br><span class="line">    <span class="comment">// 2. 指定日期触发</span></span><br><span class="line">    UNCalendarNotificationTrigger *trigger = [UNCalendarNotificationTrigger triggerWithDateMatchingComponents:components repeats:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 根据位置触发</span></span><br><span class="line">	<span class="comment">//CLLocationCoordinate2D cen = CLLocationCoordinate2DMake(39.990465,116.333386);</span></span><br><span class="line">	<span class="comment">//CLRegion *region = [[CLCircularRegion alloc] initWithCenter:cen radius:100 identifier:@"center"];</span></span><br><span class="line">	<span class="comment">//region.notifyOnEntry = YES;</span></span><br><span class="line">	<span class="comment">//region.notifyOnExit = NO;</span></span><br><span class="line">	<span class="comment">//UNLocationNotificationTrigger *trigger = [UNLocationNotificationTrigger triggerWithRegion:region 	repeats:YES];</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    UNNotificationRequest* request = [UNNotificationRequest requestWithIdentifier:LPVMNoticeEveryDayKey</span><br><span class="line">                                                                          content:content trigger:trigger];</span><br><span class="line">    <span class="comment">//添加推送成功后的处理！</span></span><br><span class="line">    [center addNotificationRequest:request withCompletionHandler:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            DLog(<span class="string">@"iOS10Later addNotification Error: %@"</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明:<br>有4种触发器</p>
<p><code>UNPushNotificationTrigger</code> 触发APNS服务，系统自动设置（这是区分本地通知和远程通知的标识)</p>
<p><code>UNTimeIntervalNotificationTrigger</code> 一段时间后触发</p>
<p><code>UNCalendarNotificationTrigger</code> 指定日期触发</p>
<p><code>UNLocationNotificationTrigger</code> 根据位置触发，支持进入某地或者离开某地或者都有</p>
<h3 id="2-iOS10Later取消推送"><a href="#2-iOS10Later取消推送" class="headerlink" title="2. iOS10Later取消推送"></a>2. iOS10Later取消推送</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UNUserNotificationCenter* center = [UNUserNotificationCenter currentNotificationCenter];</span><br><span class="line">       [center removeAllPendingNotificationRequests];  <span class="comment">// remove all at this moment.</span></span><br></pre></td></tr></table></figure>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>本地推送的回调, 会调用 <code>AppDeleage</code> 下的<code>application:(UIApplication *)application didReceiveLocalNotification</code>方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveLocalNotification:(<span class="built_in">UILocalNotification</span> *)notification&#123;</span><br><span class="line">  <span class="comment">// TO DO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 推送 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[简单明了搞定 iOS 10推送适配]]></title>
      <url>http://www.lydsnm.top/2016/10/08/%E7%AE%80%E5%8D%95%E6%98%8E%E4%BA%86%E6%90%9E%E5%AE%9AiOS10%E6%8E%A8%E9%80%81%E9%80%82%E9%85%8D/</url>
      <content type="html"><![CDATA[<p>iOS 10 更新了后发现正式环境, 推送粗问题了.查了相关资料后, 整理了一下解决办法。 iOS 10后, 增加了<font color="#1E90FF">UNUserNotificationCenter</font>, 并且推送通知的处理要在代理方法</p>
<ul>
<li><p><font color="#A52A2A">userNotificationCenter:didReceiveNotificationResponse</font> 推送时 APP 在后台</p>
</li>
<li><p><font color="#A52A2A">userNotificationCenter:willPresentNotification</font> 推送时 APP 在前台</p>
</li>
</ul>
<a id="more"></a>
<p><br></p>
<h4 id="1-导入头文件"><a href="#1-导入头文件" class="headerlink" title="1. 导入头文件"></a>1. 导入头文件</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UserNotifications/UserNotifications.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="2-遵守协议"><a href="#2-遵守协议" class="headerlink" title="2. 遵守协议"></a>2. 遵守协议</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> ()&lt;<span class="title">UNUserNotificationCenterDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="3-在application-didFinishLaunchingWithOptions方法中注册推送。"><a href="#3-在application-didFinishLaunchingWithOptions方法中注册推送。" class="headerlink" title="3. 在application: didFinishLaunchingWithOptions方法中注册推送。"></a>3. 在<font color="#1E90FF">application: didFinishLaunchingWithOptions</font>方法中注册推送。</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kiOS10Later) &#123;  <span class="comment">//iOS10 之后用UNUserNotificationCenter注册通知</span></span><br><span class="line">        UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];</span><br><span class="line">        center.delegate = <span class="keyword">self</span>;</span><br><span class="line">        [center requestAuthorizationWithOptions:(UNAuthorizationOptionBadge | UNAuthorizationOptionSound | UNAuthorizationOptionAlert) completionHandler:^(<span class="built_in">BOOL</span> granted, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">                [[<span class="built_in">UIApplication</span> sharedApplication] registerForRemoteNotifications];</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"OK!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//iOS10 之前的注册通知</span></span><br><span class="line">        <span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication] respondsToSelector:<span class="keyword">@selector</span>(registerUserNotificationSettings:)]) &#123;</span><br><span class="line">        <span class="built_in">UIUserNotificationSettings</span> *settings = [<span class="built_in">UIUserNotificationSettings</span> settingsForTypes:(<span class="built_in">UIUserNotificationTypeBadge</span> |<span class="built_in">UIUserNotificationTypeSound</span> |<span class="built_in">UIUserNotificationTypeAlert</span>)</span><br><span class="line">                                                                                 categories:<span class="literal">nil</span>];</span><br><span class="line">        [[<span class="built_in">UIApplication</span> sharedApplication] registerUserNotificationSettings:settings];</span><br><span class="line">        [[<span class="built_in">UIApplication</span> sharedApplication] registerForRemoteNotifications];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-APP-未启动-iOS10中遗弃UIApplicationLaunchOptionsRemoteNotificationKey-采用统一的方式来处理-见下一条"><a href="#4-APP-未启动-iOS10中遗弃UIApplicationLaunchOptionsRemoteNotificationKey-采用统一的方式来处理-见下一条" class="headerlink" title="4. APP 未启动, iOS10中遗弃UIApplicationLaunchOptionsRemoteNotificationKey,采用统一的方式来处理, 见下一条."></a>4. APP 未启动, iOS10中遗弃<font color="#1E90FF">UIApplicationLaunchOptionsRemoteNotificationKey</font>,采用统一的方式来处理, 见下一条.</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// application: didFinishLaunchingWithOptions 中 iOS 9及以下,还是要保留以下代码</span></span><br><span class="line"> <span class="built_in">NSDictionary</span> *remoteUserInfo = launchOptions[<span class="built_in">UIApplicationLaunchOptionsRemoteNotificationKey</span>];  </span><br><span class="line">    <span class="keyword">if</span> (remoteUserInfo) &#123;  </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"remoteUserInfo:%@"</span>,remoteUserInfo);  </span><br><span class="line">        <span class="comment">//APP未启动，点击推送消息，iOS10下还是跟以前一样在此获取  </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-实现接收推送消息的回调方法"><a href="#5-实现接收推送消息的回调方法" class="headerlink" title="5. 实现接收推送消息的回调方法"></a>5. 实现接收推送消息的回调方法</h4><p>iOS10之前使用<font color="#1E90FF">application: didReceiveRemoteNotification</font> 来进行回调处理，而在iOS10里则要实现用<font color="1E90FF">UNUserNotificationCenterDelegate</font>的两个代理方法： </p>
<blockquote>
<ul>
<li><font color="#A52A2A">userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification</font></li>
<li><font color="#A52A2A">userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse</font>
</li>
</ul>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iOS10之前 接收推送消息</span></span><br><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveRemoteNotification:(<span class="built_in">NSDictionary</span> *)userInfo fetchCompletionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">UIBackgroundFetchResult</span>))completionHandler &#123;</span><br><span class="line">    Log(<span class="string">@"userInfo: %@"</span>, userInfo);</span><br><span class="line">    <span class="keyword">if</span> ( application.applicationState == <span class="built_in">UIApplicationStateActive</span>) &#123;<span class="comment">// 程序在运行过程中受到推送通知</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//在background状态受到推送通知</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    completionHandler(<span class="built_in">UIBackgroundFetchResultNewData</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iOS 10之后 后台推送消息接收</span></span><br><span class="line">- (<span class="keyword">void</span>)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(<span class="keyword">void</span> (^)())completionHandler&#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *userInfo = response.notification.request.content.userInfo;</span><br><span class="line">    <span class="comment">// TO DO</span></span><br><span class="line">    </span><br><span class="line">    completionHandler(<span class="built_in">UIBackgroundFetchResultNewData</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iOS 10之后 前台推送消息处理.</span></span><br><span class="line">- (<span class="keyword">void</span>)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(<span class="keyword">nonnull</span> UNNotification *)notification withCompletionHandler:(<span class="keyword">nonnull</span> <span class="keyword">void</span> (^)(UNNotificationPresentationOptions))completionHandler&#123;</span><br><span class="line">    DLog(<span class="string">@"iOS 10 Receive Remote Notification in foreground! [willPresentNotification]"</span>);</span><br><span class="line">    <span class="comment">// 可在APP 前台状态下,弹出推送弹窗</span></span><br><span class="line">    completionHandler(UNNotificationPresentationOptionAlert);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-而对于本地推送回调-和以前没有变化"><a href="#6-而对于本地推送回调-和以前没有变化" class="headerlink" title="6. 而对于本地推送回调, 和以前没有变化:"></a>6. 而对于本地推送回调, 和以前没有变化:</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveLocalNotification:(<span class="built_in">UILocalNotification</span> *)notification&#123;</span><br><span class="line">  <span class="comment">// TO DO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="7-其他补充"><a href="#7-其他补充" class="headerlink" title="7. 其他补充"></a>7. 其他补充</h4><ul>
<li>对于<font color="#1E90FF">Xcode 8</font>, 默认生成的<font color="#1E90FF">XXX.entitlements</font>中的<font color="#1E90FF">APS Enviroment</font> 发布时,可以不用从development 改成 production. Xcode 在发布时会自动帮我们处理改好.</li>
</ul>
<ul>
<li>推送开关记得要打开;capabilities 里面<font color="#1E90FF">Background Modes–&gt;remote notification&amp;push notification</font></li>
</ul>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS10适配 </tag>
            
            <tag> 推送 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OC开发相关注意事项]]></title>
      <url>http://www.lydsnm.top/2016/09/20/OC%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%BA%8C/</url>
      <content type="html"><![CDATA[<h2 id="接口与-API-设计"><a href="#接口与-API-设计" class="headerlink" title="接口与 API 设计"></a>接口与 API 设计</h2><p>我们在构建应用程序编写接口应考虑将其设计成易于复用的形式, 方便后续项目复用或其他模块使用. 这就需要遵守一定的编程范式, 遵守一些约定俗成的”规则”.</p>
<h3 id="1-用前缀避免命名空间冲突"><a href="#1-用前缀避免命名空间冲突" class="headerlink" title="1. 用前缀避免命名空间冲突"></a>1. 用前缀避免命名空间冲突</h3><p>OC 没有其他语言内置的命名空间机制. 因此在命名时设法避免潜在的命名冲突, 否则容易就重名.否则会出现类似错误:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">duplicate symbol _OBJC_METACLASS_$_EOCTHECLASS <span class="keyword">in</span>:</span><br><span class="line">build/something.o</span><br><span class="line">build/something_else.o</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>苹果宣称其保留使用所有”两字母前缀”(two-letter prefix)的权利,因此我们的命名前缀最好避免使用两个字母当前缀.</p>
<a id="more"></a>
<hr>
<h3 id="2-提供”全能初始方法”"><a href="#2-提供”全能初始方法”" class="headerlink" title="2. 提供”全能初始方法”"></a>2. 提供”全能初始方法”</h3><ul>
<li>在类中提供一个全能初始化方法, 并于文档中指名. 其他初始化方法均应调用此方法.</li>
<li>若全能初始化方法与超类不同, 则需要覆写超类中的对应方法.</li>
<li>如果超类的初始化方法不适用于之类, 那么应该覆写这个超类方法, 并在其中抛出异常.</li>
</ul>
<hr>
<h3 id="3-实现-description-方法"><a href="#3-实现-description-方法" class="headerlink" title="3. 实现 description 方法"></a>3. 实现 description 方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;object = %@&quot;, object);</span><br></pre></td></tr></table></figure>
<p>实现 object 的 description 方法, 打印 object 中用户关心的信息.</p>
<ul>
<li>若想在调试时打印更详尽的对象描述信息, 则应实现 debugDescription 方法.</li>
</ul>
<hr>
<h3 id="4-尽量使用不可变对象"><a href="#4-尽量使用不可变对象" class="headerlink" title="4. 尽量使用不可变对象"></a>4. 尽量使用不可变对象</h3><p>若属性仅可以用于对象内部修改, 则在”class-continuation 分类”中将其由<code>readonly</code>属性扩展为 readwirte.<br>不要把可变的 <code>collection</code>作为属性公开, 而应时提供相关方法, 以此修改对象中的可变 <code>collection</code>.</p>
<hr>
<h3 id="5-命名方式"><a href="#5-命名方式" class="headerlink" title="5.命名方式"></a>5.命名方式</h3><p>用<code>p_</code>开头来命名私有方法. 而苹果公司用的是拿一个下划线作为前缀, 而我们最好不要用, 不然可能因为<font color="#A52A2A">动态方法派发系统(dynamic method dispatch system)</font>可能在子类中无意覆盖了方法.</p>
<h3 id="6-NSCopying协议"><a href="#6-NSCopying协议" class="headerlink" title="6. NSCopying协议"></a>6. NSCopying协议</h3><p>要想让自定义类支持拷贝操作, 就需要实现<font color="#A52A2A"> NSCopying</font>协议, 该协议只有一个方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span>*)zone</span><br></pre></td></tr></table></figure>
<p>为何会出现 <code>NSZone</code> 呢? 因为以前开发程序时, 会据此把内存分成不同的”区”(<code>zone</code>), 而对象会创建在某个区里面, 而现在不用了, 每个程序只有一个<code>default zone</code></p>
<p>对于不可变的 <code>NSArray</code> 与可变的 <code>NSMutableArray</code> 来说, 下列关系总是成立的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (NSMutableArray copy] =&gt; NSArray</span><br><span class="line">- (NSArray mutableCopy] =&gt; NSMutableArray</span><br></pre></td></tr></table></figure>
<p>另外, 在可变对象上调用 <code>copy</code> 方法则是会返回另外一个不可变类的实例.</p>
<p><br></p>
<hr>
<h2 id="协议与分类"><a href="#协议与分类" class="headerlink" title="协议与分类"></a>协议与分类</h2><p>OC 不支持多重继承, 因而我们把某个类应该实现的一系列方法定义在协议里面. 协议最为常见的用途时实现委托模式.</p>
<h3 id="1-委托"><a href="#1-委托" class="headerlink" title="1. 委托"></a>1. 委托</h3><p>对于需要频繁通过数据源协议从数据源中获取多份相互独立的数据, 下面的这种优化方式, 值得使用.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCNetworkFetcher</span>()</span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> didReceiveData	: <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> didFailWithError	: <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> didUpdateProgressTo : <span class="number">1</span>;</span><br><span class="line">		&#125; _delegateFlags;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set Flag</span></span><br><span class="line">_delegateFlags.didReceiveData = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setDelegate:(<span class="keyword">id</span>&lt;EOCNetworkFetcher&gt;)delegate&#123;</span><br><span class="line">	_delegate = delegate;</span><br><span class="line">	_delegateFlags.didReceiveData = [delegate respondsToSelector:<span class="keyword">@selector</span>(networkFetcher:didReceiveData:)]	;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就不用, 每次都去检测委托对象是否能响应给定的选择子了.</p>
<hr>
<h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h3><p>当类的实现文件过于膨胀而无法管理时, 将类分类, 提取到分别的不同的文件中区.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XXX+Friendship(.h/.m)</span><br><span class="line">XXX+Work(.h/.m)</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure>
<p>另外可以创建名为<code>Private</code>的分类.一般这个类中的方法只在类或框架内部使用.以隐藏实现细节.</p>
<hr>
<h3 id="3-通过协议提供匿名对象"><a href="#3-通过协议提供匿名对象" class="headerlink" title="3. 通过协议提供匿名对象"></a>3. 通过协议提供匿名对象</h3><p>委托就使用的了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, weak) id &lt;EOCDelegate&gt; delegate;</span><br></pre></td></tr></table></figure>
<p>该属性的类型是<code>id&lt;EOCDelegate&gt;</code>, 所以实际上任何类的对象都能充当这一属性, 即便该类不继承自 <code>NSObject</code>, 只要遵循 <font color="#A52A2A">EOCDelegate</font> 就可以了</p>
<p><br></p>
<hr>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ol>
<li><p>OC 中无法将某个类标识为<font color="#A52A2A">抽象类</font>. 要想达成类似效果, 最好的方法时在那些子类必须覆写的超类方法中抛出异常.</p>
</li>
<li><p>遵循使用属性的 <code>setter</code> 方法，或通过 <code>key-path</code> 来设置：<br><code>[target setAge:30];</code> <code>[target setValue:[NSNumber numberWithInt:30] forKey:@&quot;age&quot;];</code> <font color="#A52A2A">KVO</font> 键值观察才能正确获得变化.</p>
</li>
</ol>
<hr>
<p><br></p>
<p>本篇文章参考摘自 <font color="#B8860B">Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的52个有效方法</font></p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OC开发相关注意事项]]></title>
      <url>http://www.lydsnm.top/2016/08/24/OC%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      <content type="html"><![CDATA[<h2 id="一些基本信息"><a href="#一些基本信息" class="headerlink" title="一些基本信息"></a>一些基本信息</h2><h3 id="1-内存相关"><a href="#1-内存相关" class="headerlink" title="1. 内存相关"></a>1. 内存相关</h3><p>分配在堆中的内存必须直接管理, 而分配在栈中的用于保存变量的内存则会在其栈弹出时自动清理.<br>    Objective-C将堆内存管理抽象出来了. 不需要用malloc及free来分配或释放对象所占内存. Objective-C运行期环境把这部分工作抽象为一套内存管理框架-“引用计数”</p>
<p>在OC中, 有时会遇到定义里不含*的变量, 可能会使用<code>栈空间</code>. 这些变量所保存的不是Objective-C对象, 比如CoreGraphics中的CGRect.</p>
<hr>
<h3 id="2-在类的头文件中尽量少引入其他头文件"><a href="#2-在类的头文件中尽量少引入其他头文件" class="headerlink" title="2. 在类的头文件中尽量少引入其他头文件"></a>2. 在类的头文件中尽量少引入其他头文件</h3><p>而是采用向前声明(forward declaring)<br>减少类的使用者, 所需引入的头文件数量,减少编译时间.<br>也能解决两个类互相引用的问题</p>
<a id="more"></a>
<hr>
<h3 id="3-多用字面量语法-少用与之等价的方法"><a href="#3-多用字面量语法-少用与之等价的方法" class="headerlink" title="3. 多用字面量语法, 少用与之等价的方法"></a>3. 多用字面量语法, 少用与之等价的方法</h3><p>字面量语法,比如:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *something = <span class="string">@"Effective Objective-C 2.0"</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字面数值</span></span><br><span class="line"><span class="built_in">NSNumber</span> *someNumber = [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1</span>]; -&gt; <span class="built_in">NSNUmber</span> *someNumber = @<span class="number">1</span>;</span><br><span class="line"><span class="comment">//字面量数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *animals = @[<span class="string">@"cat"</span>, <span class="string">@"dog"</span>];<span class="comment">// 数组中若有nil会 抛出异常.</span></span><br><span class="line"><span class="comment">//字面量字典</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *personData = @&#123;</span><br><span class="line"><span class="string">@"firstName"</span> : <span class="string">@"Matt"</span>,</span><br><span class="line"><span class="string">@"lastName"</span> : <span class="string">@"za"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//可变数组</span></span><br><span class="line">mutableArray[<span class="number">1</span>] = <span class="string">@"dog"</span>;<span class="comment">// 尽量通过下标操作来访问数组, 或者字典中的所对应的元素.</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="4-多用类型常量-少用-define-预处理指令"><a href="#4-多用类型常量-少用-define-预处理指令" class="headerlink" title="4. 多用类型常量, 少用#define 预处理指令"></a>4. 多用类型常量, 少用#define 预处理指令</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> kAnimationDuration = <span class="number">0.3</span>;</span><br></pre></td></tr></table></figure>
<p>命名, 若常量局限于某”编译单元”(也就是实现文件中, implementation中),则在前面加字母k; 若常量在类之外可见, 则通常以类名为前缀.<br>尽量不要在头文件中声明预处理指令或定义常量 static const.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AnimatedView</span>: <span class="title">UIView</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> kAnimationDuration = <span class="number">0.3</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AnimatedView</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="comment">// static修饰意味着, 该变量仅局限于此变量的编译单元(在OC语境下, 一般通常指每个类的实现文件(.m))中.</span></span><br><span class="line">如不加<span class="keyword">static</span>, 在另一.m文件中也声明了同名变量, 会抛出常见的duplicate_symbol错误</span><br></pre></td></tr></table></figure>
<p>实际上, 如果一个变量既声明为static, 有声明为const, 那么编译器根本不会创建符号, 而是想#define预处理指令一样, 把所有遇到的变量都替换成常值. 不过这种方式定义的常量是带有类型信息的, 这点也相当关键.</p>
<ul>
<li>通知, 发送者和接受者都需要个外界可见的常量变量(即通知的名称).</li>
</ul>
<p>这时,此类变量需放在”全局符号表”(global symbol table)中, 以便可以在定义该变量的编译单元之外使用.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In the header file</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> EOCStringConstant;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In the implementation file</span></span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> EOCStringConstant = <span class="string">@"VALUENOTIFICATION"</span>;</span><br></pre></td></tr></table></figure>
<p>常量定义从右至左解读,这里是”一个常量, 而这个常量是个指针, 指向一个NSString对象”<br>这里面的命名要注意谨慎, 避免名称冲突, 最好用与值相关的类名做前缀.</p>
<h3 id="5-用枚举表示状态、选项、状态码"><a href="#5-用枚举表示状态、选项、状态码" class="headerlink" title="5. 用枚举表示状态、选项、状态码"></a>5. 用枚举表示状态、选项、状态码</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> EOCConnectionStateConnectionState&#123;</span><br><span class="line">	EOCConnectionStateDisconnected = <span class="number">1</span>,</span><br><span class="line">	EOCConnectionStateConnecting,</span><br><span class="line">	EOCConnectionStateConnected,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义可以彼此组合的枚举. 定义的对后, 各选项之间就可通过”按位或操作符”(bitwise OR operator)来组合.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="built_in">UIViewAutoresizing</span> &#123;</span><br><span class="line">	<span class="built_in">UIViewAutoresizingNone</span>						= <span class="number">0</span>,</span><br><span class="line">	<span class="built_in">UIViewAutoresizingFlexbleLeftMargin</span>		= <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">	<span class="built_in">UIViewAutoresizingFlexbleWidth</span>				= <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">	<span class="built_in">UIViewAutoresizingFlexbleRighMargin</span> 		= <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">	.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在处理枚举类型的switch语句中不要实现default分支. 这样的话, 加入新枚举之后, 编译器就会提示开发者. switch语句并未处理所有枚举.</li>
</ul>
<hr>
<h2 id="对象、消息、运行期"><a href="#对象、消息、运行期" class="headerlink" title="对象、消息、运行期"></a>对象、消息、运行期</h2><h3 id="6-理解属性这一概念"><a href="#6-理解属性这一概念" class="headerlink" title="6.理解属性这一概念"></a>6.理解属性这一概念</h3><p>属性用来通过存取放方法来访问实例变量, 是OC提供的一个简洁方便管理的抽象机制. @property语法. 如果用了这些属性了, 编译器会自动编写访问这些属性所需的方法, 次过程叫”自动合成”(autosynthesis),并添加对应的实例变量. 也可以在类的实现代码里通过<code>@synthesize</code>语法来指定实例变量的名字</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@implementaion EOCPerson</span><br><span class="line"><span class="keyword">@synthesize</span> fireName = _myFirstname;</span><br><span class="line"><span class="keyword">@synthesize</span> lastName = _myLastName;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>可通过<code>@dynamic</code>关键字来告诉编译器不要自动创建实现属性所用的实例变量和存取方法.</p>
<p>修饰属性的特质关键字</p>
<ul>
<li>weak 表明定义了一种”非拥有关系”. 为这种属性设置新值时, 设置方法既不保留新值, 也不释放旧值. 当属性所指的对象遭到销毁时, 属性值也会清空(nil).</li>
<li>unsafe_unretained 该特质的语义表达一种”非拥有关系”, 当目标对象遭到销毁时, 属性值不会自动清空(unsafe), 这一点和weak不同.</li>
<li>在iOS程序是, 应用nonatomic属性, 避免影响性能</li>
</ul>
<p><br></p>
<hr>
<h3 id="7-在对对象内部尽量直接访问实例变量"><a href="#7-在对对象内部尽量直接访问实例变量" class="headerlink" title="7. 在对对象内部尽量直接访问实例变量"></a>7. 在对对象内部尽量直接访问实例变量</h3><p>直接访问实例变量, 速度会快一点, 但是对一个声明的copy的属性, 那么并不会拷贝该属性, 只会保留新值并释放旧值. 也不能触发”键值观察”(KVO), 一般比较折中的方式是写入实例变量时, 通过其”设置方法”来做, 而在读取实例变量是, 则直接访问.<br>注意的地方:<br>在初始化方法中应该如何设置属性值, 这种情况总是应该直接访问实例变量, 因为子类可能overide重写了设置方法.</p>
<p>对于懒加载或者说惰性初始化(lazy initialization)来说,就必须通过存取方法来访问属性.</p>
<p><br></p>
<hr>
<h3 id="8-理解”对象等同性”"><a href="#8-理解”对象等同性”" class="headerlink" title="8. 理解”对象等同性”"></a>8. 理解”对象等同性”</h3><p>有时,按照==操作符比较出来的结果未必是我们想要的, 该操作比较的是两个指针本身, 而不是所指的对象. 应该使用NSObject协议中声明的<code>isEqual</code><br>NSObject协议中有两个用于判断等同性的关键方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)isEqual:(<span class="keyword">id</span>)object;</span><br><span class="line">- (<span class="built_in">NSUInteger</span>)hash;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>若想检测对象的等同性, 请提供<code>isEqual:</code>与<code>hash</code>方法.</p>
</li>
<li><p>相同的对象必须具有相同的哈希码, 但两个哈希码相同的对象却未必相同.</p>
</li>
<li><p>编写hash方法时, 应该使用计算速度快而且哈希码碰撞几率低的算法.</p>
</li>
</ul>
<p><br></p>
<hr>
<h3 id="9-以”类族模式”隐藏实现细节"><a href="#9-以”类族模式”隐藏实现细节" class="headerlink" title="9.以”类族模式”隐藏实现细节."></a>9.以”类族模式”隐藏实现细节.</h3><p>类方法(也叫类别方法)<br>类族模式可以把实现细节隐藏在一套简单的公共接口后面.</p>
<p>系统框架中经常使用类族(NSArray)</p>
<p><br></p>
<hr>
<h3 id="11-理解objc-msgSend的作用"><a href="#11-理解objc-msgSend的作用" class="headerlink" title="11. 理解objc_msgSend的作用"></a>11. 理解objc_msgSend的作用</h3><p>传递消息, C语言使用静态绑定(static binding), 在编译期内就能决定运行时所应调用的函数.函数地址实际上是硬编码在指令之中的.</p>
<p>so 对应的有动态绑定, 在OC中, 如果向某对象传递消息, 那就会使用动态绑定机制来决定需要调用的方法.</p>
<ul>
<li>给某对象”发送消息”(invoke a message)也就相当于在该对象上”调用方法”(call a method)</li>
<li>发给某对象的全部消息都要由”动态消息派发系统”(dynamic message dispatch system)来处理, 该系统会查处对应的方法, 并执行其代码.</li>
</ul>
<p><br></p>
<hr>
<h3 id="12-理解消息转发机制"><a href="#12-理解消息转发机制" class="headerlink" title="12. 理解消息转发机制"></a>12. 理解消息转发机制</h3><ul>
<li>若对象无法响应某个选择子, 则进入消息转发流程.</li>
<li>通过运行期的动态方法解析功能, 我们可以在需要用到某个方法时再讲其加入类中.</li>
<li>对象可以把其无法解读的某些选择子转交给其他对象来处理.</li>
<li>经过上述两步后, 如果还是没有办法处理选择子, 那就启动完整的消息转发机制.</li>
</ul>
<p><br></p>
<hr>
<h3 id="14-理解”类对象”的用意"><a href="#14-理解”类对象”的用意" class="headerlink" title="14. 理解”类对象”的用意"></a>14. 理解”类对象”的用意</h3><p>OC 有个特殊类型 <font color="#00fffff">id</font> 指代任意的 OC 对象类型. 一般情况下,消息转发给了 此 id 的对象, 但不知其具体类型是否能响应. 我们知道如果向某明确类型发送了无法解读的消息, 那么就会产生警告信息, 而 <font color="#00fffff">id</font>类型让编译器假定其能响应所有消息, 留待后续”在运行期检视对象类型”,看是否能够响应其方法.</p>
<ul>
<li>每个实例都有一个指向 Class 对象的指针, 用以表明其类型, 而这些 Class 对象则构成了类的继承体系.</li>
<li>如果对象类型无法在编译期确定,那么久应该实用类型信息查询方法来判断 <code>isKindOfClass</code>…</li>
<li>尽量实用类型信息查询方法来确定对象类型, 而不要直接比较类对象, 因为某些对象可能实现了消息转发功能.</li>
</ul>
<hr>
<p><br></p>
<p>本篇文章参考摘自 <font color="#B8860B">Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的52个有效方法</font></p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[阶段总结]]></title>
      <url>http://www.lydsnm.top/2016/08/23/%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>8月</p>
<p>Swift还是在学习中,可能会搁置一段时间. 基本语法是了解了, 在了解过程也发现某些语法确实和看到的资料不同, 有人开玩笑说, 每过一段时间就好像是学一门新的语言.😁</p>
<a id="more"></a>
<p>但是以目前的Swift语言的状态来说, 确实不太适合作为某些公司的主力开发语言<br>因此之后的比例会减少, 继续OC.</p>
<p>Swift包括网络库等等, 都要熟悉, 头疼.<br>后续会抽空更新Swift语言的相关知识整理, 也是方便自己之后的查阅~~. </p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 计划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[整理下Swift与Objective-C的一些不同]]></title>
      <url>http://www.lydsnm.top/2016/08/23/%E7%AE%80%E5%8D%95%E6%95%B4%E7%90%86Swift%E4%B8%8EObjective-C%E7%9A%84%E4%B8%8D%E5%90%8C/</url>
      <content type="html"><![CDATA[<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li>在OC中对代码进行逻辑组织用的是#pragma mark - , 生成分割线<br>而在swift中有了一些新的语法<br>如: <code>//MARK:</code> <code>//FIXME</code> <code>TODO:</code></li>
</ul>
<a id="more"></a>
<p><code>//MARK: -</code> 生成分割线</p>
<p><code>//MARK:</code> 说明</p>
<ul>
<li>Swift中对类进行扩展<br>OC中采用的是分类, 而Swift中没有分类, 相对应的只有扩展(<code>Extensions</code>)<br>以UIView为例 , 新建UIView+Ext.swift</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import Foundation</span><br><span class="line">import <span class="built_in">UIKit</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extension <span class="built_in">UIView</span> &#123;</span><br><span class="line">    public var x: <span class="built_in">CGFloat</span>&#123;</span><br><span class="line">        get&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.frame.origin.x</span><br><span class="line">        &#125;</span><br><span class="line">        set&#123;</span><br><span class="line">            var r = <span class="keyword">self</span>.frame</span><br><span class="line">            r.origin.x = newValue</span><br><span class="line">            <span class="keyword">self</span>.frame = r</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="ChangeLog"><a href="#ChangeLog" class="headerlink" title="ChangeLog"></a>ChangeLog</h2><p>2016-12-3 区别太多，放弃，当新学一门语言吧，感觉还快些，😄。</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Photos Framework记录]]></title>
      <url>http://www.lydsnm.top/2016/08/22/Photos%20Framework%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>几个概念是接触Photos需要了解的.</p>
<h2 id="1-PHAsset-、PHAssetCollection、PHCollectionList"><a href="#1-PHAsset-、PHAssetCollection、PHCollectionList" class="headerlink" title="1. PHAsset 、PHAssetCollection、PHCollectionList"></a>1. PHAsset 、PHAssetCollection、PHCollectionList</h2><p><strong>PHAsset</strong> 、<strong>PHAssetCollection</strong>、<strong>PHCollectionList</strong> 是Photos框架中的模型类，PHAsset类是数据模型，描述图片或者视频文件数据；PHAssetCollection描述了包括相册、moments、智能相册以及共享照片流等一系列图片或者视频文件的集合的元数据；PHCollectionList是一组资源集合，可能是一组Assets，也可能是一组collection<br><br></p>
<h3 id="1-1-PHAsset-存储获取图片和视频文件的元数据"><a href="#1-1-PHAsset-存储获取图片和视频文件的元数据" class="headerlink" title="1.1 PHAsset: 存储获取图片和视频文件的元数据."></a>1.1 PHAsset: <strong>存储获取图片和视频文件的元数据.</strong></h3><p>这些图片和视频文件可能在手机内, 或者只存在iCloud(当开启了iCloud照片图片功能上传到iCloud了)中,<br>相比以前的ALAsset,提供了更多的资源信息.</p>
<p>有几个要点</p>
<blockquote>
<ul>
<li>需要使用[PHAsset fetchAsset…]系列类方法获取.</li>
<li>PHAsset对象只包含原数据, 不包含图片或视频的数据. 要图片和视频数据, 需要使用PHImageManager加载<a id="more"></a>
</li>
</ul>
</blockquote>
<p>重要的属性:</p>
<blockquote>
<ul>
<li><code>mediaType</code> : 资源类型  图片/音频/视频</li>
<li><code>mediaSubtypes</code> : 全景图、HDR图片、屏幕截图、live Photo</li>
<li><code>Favorite</code> : 标记资源是否被用户标为”收藏”</li>
<li><code>hidden</code> : 是否被用户设置为隐藏</li>
<li><code>representsBurst</code> 和 <code>burstSelectionTypes</code>: 对于一个资源，如果其 PHAsset 的 representsBurst 属性为 true，则表示这个资源是一系列连拍照片中的代表照片 (多张照片是在用户按住快门时拍摄的)。它还有一个属性是 burstIdentifier，如果想要获取连拍照片中的剩余的其他照片，可以通过将这个值传入 fetchAssetsWithBurstIdentifier(…) 方法来获取。用户可以在连拍的照片中做标记；此外，系统也会自动用各种试探来标记用户可能会选择的潜在代表照片。这个元数据是可以通过 PHAsset 的 burstSelectionTypes 属性来访问。这个属性是用三个常量组成的位掩码：.UserPick 表示用户手动标记的资源，.AutoPick 表示用户可能标记的潜在资源，.None 表示没有标记的资源。</li>
</ul>
</blockquote>
<p><br></p>
<ul>
<li><code>sourceType</code> : 资源可以来源于用户相册、iCloud、iTunes同步</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PHAssetSourceTypeNone, </span><br><span class="line">PHAssetSourceTypeUserLibrary,</span><br><span class="line">PHAssetSOurceTypeCloudShared,</span><br><span class="line">PHAssetSourceTypeiTunesSynced</span><br></pre></td></tr></table></figure>
<ul>
<li>localIdentifier</li>
</ul>
<p>Photos框架中的根类PHObject只有一个公开接口localIdentifier, 是对象的<em>唯一标识符</em>.PHObject实现了<code>-isEqual</code>和<code>-hash</code>方法. 可以直接使用localIdentifier属性对PHObject及其子类迭代进行对比</p>
<h3 id="1-2-PHAssetCollection"><a href="#1-2-PHAssetCollection" class="headerlink" title="1.2 PHAssetCollection"></a>1.2 PHAssetCollection</h3><p>PHAssetColletion是一组有序的资源集合, 包含相册,智能相册,照片流等等.<br><br><br><br></p>
<h3 id="1-3-PHCollectionList"><a href="#1-3-PHCollectionList" class="headerlink" title="1.3 PHCollectionList"></a>1.3 PHCollectionList</h3><p>一组有序的资源集合的集合</p>
<h2 id="2-获取数据"><a href="#2-获取数据" class="headerlink" title="2. 获取数据"></a>2. 获取数据</h2><p>PHAsset 、PHAssetCollection、PHCollectionList</p>
<h3 id="2-1-PHAsset获取PHAsset的类方法"><a href="#2-1-PHAsset获取PHAsset的类方法" class="headerlink" title="2.1 PHAsset获取PHAsset的类方法"></a>2.1 PHAsset获取PHAsset的类方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ fetchAssetsInAssetCollection:options:</span><br><span class="line">+ fetchAssetsWithMediaType:options:</span><br><span class="line">+ fetchAssetsWithLocalIdentifiers:options:</span><br><span class="line">+ fetchKeyAssetsInAssetCollection:options:</span><br><span class="line">+ fetchAssetsWithOptions:</span><br><span class="line">+ fetchAssetsWithBurstIdentifier:options:</span><br><span class="line">+ fetchAssetsWithALAssetURLs:options:</span><br></pre></td></tr></table></figure>
<ul>
<li>PHFetchOptions</li>
</ul>
<p>1-predicate: 选择的约束条件</p>
<p>2-sortDescriptors 对结果进行排序</p>
<p>3-includeHiddenAssets 获取结果是否包含被隐藏的资源</p>
<p>4-includeAllBurstAssets 获取结果是否包含联排资源</p>
<p>属性: </p>
<blockquote>
<ol>
<li>predicate: 选择的约束条件</li>
<li>sortDescriptors 对结果进行排序</li>
<li>includeHiddenAssets 获取结果是否包含被隐藏的资源</li>
<li>includeAllBurstAssets 获取结果是否包含连拍资源</li>
</ol>
</blockquote>
<p>示例:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PHFetchOptions *options = [[PHFetchOptions alloc] init];</span><br><span class="line">options.wantsIncrementalChangeDetails = <span class="literal">YES</span>;</span><br><span class="line">options.includeAllBurstAssets = <span class="literal">YES</span>;</span><br><span class="line">options.includeHiddenAssets = <span class="literal">YES</span>;</span><br><span class="line"><span class="comment">// 只取图片</span></span><br><span class="line">options.predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"mediaType == %d"</span>,PHAssetMediaTypeImage];</span><br><span class="line"><span class="comment">// 按时间排序</span></span><br><span class="line">options.sortDescriptors = @[[<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@"creationDate"</span> ascending:<span class="literal">YES</span>]];</span><br><span class="line"></span><br><span class="line">PHFetchResult *albums = [PHAssetCollection fetchAssetCollectionsWithType:PHAssetCollectionTypeSmartAlbum subtype:PHAssetCollectionSubtypeSmartAlbumAllHidden options:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>PHFetchResult</li>
</ul>
<p>类似数组, 存储获取到的asset对象集合.<br>操作方式也和NSArray数组类似</p>
<h2 id="3-修改数据-写入相册"><a href="#3-修改数据-写入相册" class="headerlink" title="3. 修改数据, 写入相册"></a>3. 修改数据, 写入相册</h2><p>// …. 待写</p>
<h3 id="3-1-PHPhotoLibrary"><a href="#3-1-PHPhotoLibrary" class="headerlink" title="3.1 PHPhotoLibrary"></a>3.1 PHPhotoLibrary</h3><p>系统中PHPhotoLibrary单例对象 是用来维护用户照片库。当我们需要编辑资源对象元数据、资源内容、或者插入新的资源对象等，都可以借助通过PHPhotoLibrary单例对象执行block，block中创建我们指定的请求对象(比如PHAssetChangeRequest,PHAssetCollectionChangeRequest, PHCollectionListChangeRequest的对象)。photoLibraryDidChange(changeInfo: PHChange!)中进行.</p>
<p><br></p>
<h2 id="4-请求图片数据"><a href="#4-请求图片数据" class="headerlink" title="4 请求图片数据"></a>4 请求图片数据</h2><h3 id="4-1-PHImageManager"><a href="#4-1-PHImageManager" class="headerlink" title="4.1 PHImageManager"></a>4.1 PHImageManager</h3><p>请求图片主要用了<code>PHImageManager</code>, <code>[PHImageManager defaultManager]</code>其提供了加载图片和视频的方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求图片</span></span><br><span class="line">- requestImageForAsset:targetSize:contentMode:options:resultHandler:</span><br><span class="line">- requestImageDataForAsset:options:resultHandler:</span><br><span class="line"><span class="comment">// 请求视频</span></span><br><span class="line">- requestPlayerItemForVideo:options:resultHandler:</span><br><span class="line">- requestExportSessionForVideo:options:exportPreset:resultHandler:</span><br><span class="line">- requestAVAssetForVideo:options:resultHandler:</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="4-2-请求图片"><a href="#4-2-请求图片" class="headerlink" title="4.2 请求图片"></a>4.2 请求图片</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PHImageRequestID requestID = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> scale = [<span class="built_in">UIScreen</span> mainScreen].scale;</span><br><span class="line">    <span class="built_in">CGFloat</span> width = MIN([<span class="built_in">UIScreen</span> mainScreen].bounds.size.width, <span class="number">500</span>);</span><br><span class="line">    <span class="keyword">if</span> (requestID &gt;= <span class="number">1</span> &amp;&amp; size.width / width == scale) &#123;</span><br><span class="line">        [[PHCachingImageManager defaultManager] cancelImageRequest:requestID];</span><br><span class="line">    &#125;</span><br><span class="line">    PHImageRequestOptions *option = [[PHImageRequestOptions alloc] init];</span><br><span class="line">    option.deliveryMode = PHImageRequestOptionsDeliveryModeOpportunistic;</span><br><span class="line">    <span class="comment">//    option.resizeMode = PHImageRequestOptionsResizeModeFast;</span></span><br><span class="line">    option.resizeMode = resizeMode;</span><br><span class="line">    </span><br><span class="line">    requestID = [[PHCachingImageManager defaultManager] requestImageForAsset:asset targetSize:size contentMode:PHImageContentModeAspectFill options:option resultHandler:^(<span class="built_in">UIImage</span> * _Nullable result, <span class="built_in">NSDictionary</span> * _Nullable info) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![[info objectForKey:PHImageResultIsDegradedKey] boolValue]) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completion(result,info);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其中需要注意的是：该方法在默认情况下是异步执行的，而且 Photos 库可能会多次执行 resultHandler 块，因为这种情况就是图像需要从 iCloud 中下载的情况。在 requestImageForAsset 返回的内容中，一开始的那一次请求中会返回一个小尺寸的图像版本，当高清图像还在下载时，开发者可以首先给用户展示这个低清的图像版本，然后 block 在多次调用后，最终会返回高清的原图。至于当前返回的图像是哪个版本的图像，可以通过 block 返回的 NSDictionary info 中获知，PHImageResultIsDegradedKey 表示当前返回的 UIImage 是低清图。所以需要判断一下是否是已获取到我们需要的图片。</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Photos </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的mvp,mvvm理解]]></title>
      <url>http://www.lydsnm.top/2016/03/25/%E6%88%91%E7%9A%84mvp_mvvm%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>控制器Controller是app的“胶水代码”：协调模型和视图之间的所有交互, 过于臃肿。而作为对比的 Model过于轻量级. 等等原因, 原本的mvc缺陷体现</p>
<h5 id="mvvm"><a href="#mvvm" class="headerlink" title="mvvm"></a>mvvm</h5><p>Model-View-ViewModel<br>在mvvm中, view和view controller正式联系在一起, 可以视为一个组件,<br>视图view仍然不能直接引用模型model, controller也不能.但能引用视图模型view Model<br>view Model适合放置用户输入验证逻辑,视图显示逻辑, 发起网络请求和其他各种各种的代码.<br>刚开始使用mvvm的最好方式, 可以可将一小部分逻辑放入视图模型, 然后当你逐渐习惯于使用这个范式的时候再迁移.</p>
<h5 id="mvp"><a href="#mvp" class="headerlink" title="mvp"></a>mvp</h5><p>M: 逻辑Model层<br>V: 视图层<br>P: protocol协议层</p>
<p>Model层类似  MVVM的viewModel, 主要负责存储抽象逻辑数据, 另外Model还有部分工作实现对应的协议层协议. 提供协议对应的各种属性以及服务.</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mvp mvvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CocoaPods安装和使用]]></title>
      <url>http://www.lydsnm.top/2016/03/08/CocoaPods%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;CocoaPods应该是iOS和Mac开发中最常用最有名的类库管理工具了，这篇就来整理下CocoaPods的安装和使用。<br>如果pod update pod Setup慢 请直接跳到 <font color="10d3c4"><b>标题2.4</b></font></p>
<h2 id="一-CocoaPods安装"><a href="#一-CocoaPods安装" class="headerlink" title="一. CocoaPods安装:"></a>一. CocoaPods安装:</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>&emsp;&emsp;cocoaPods是用 Ruby 实现的, 要想使用它就需要有 Ruby 环境, 幸运的是OS X 系统默认支持 Ruby, 打开终端输入命令安装 cocoaPods</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gem install -n /usr/local/bin cocoapods</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;CocoaPods是以Ruby gem包的形式被安装的。在安装执行的过程中，可能会问我们是不是更新rake，输入y即可。这是因为rake gem包会在安装的过程中检查更细，如果有可用的新版本就会出现刚才的选项。<br>在安装进程结束的时候，执行命令：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod setup</span><br></pre></td></tr></table></figure>
<p>如果没有报错，就说明一切安装就成功了！<br><br></p>
<a id="more"></a>
<h3 id="2-安装中可能遇到的问题"><a href="#2-安装中可能遇到的问题" class="headerlink" title="2. 安装中可能遇到的问题:"></a>2. 安装中可能遇到的问题:</h3><h4 id="2-1-gem-install-cocoapods-命令半天后没反应"><a href="#2-1-gem-install-cocoapods-命令半天后没反应" class="headerlink" title="2.1 gem install cocoapods 命令半天后没反应"></a>2.1 gem install cocoapods 命令半天后没反应</h4><ol>
<li><p>首先可使用代理, 继续安装</p>
<p><del>2. 用淘宝的RubyGems镜像来代替官方版</del> (已经不维护了，文章更新于2016-11-24)</p>
<p>执行以下代码:</p>
</li>
</ol>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gem sources --remove <span class="symbol">https:</span>/<span class="regexp">/rubygems.org/</span></span><br><span class="line"><span class="comment"># gem sources -a http://ruby.taobao.org/</span></span><br><span class="line">gem sources --add <span class="symbol">https:</span>/<span class="regexp">/gems.ruby-china.org/</span></span><br><span class="line">gem sources -l</span><br></pre></td></tr></table></figure>
<h4 id="2-2-gem版本过老"><a href="#2-2-gem版本过老" class="headerlink" title="2.2 gem版本过老"></a>2.2 gem版本过老</h4><p>&emsp;&emsp;gem是管理Ruby库和程序的标准包，如果它的版本过低也可能导致安装失败，解决方案自然是升级gem，执行下述命令即可：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gem update --system</span><br></pre></td></tr></table></figure>
<h4 id="2-3-pod-setup-后卡住半天不反应"><a href="#2-3-pod-setup-后卡住半天不反应" class="headerlink" title="2.3 pod setup 后卡住半天不反应"></a>2.3 pod setup 后卡住半天不反应</h4><p>&emsp;&emsp;实际上, 这时也并非真的卡住了, 只是pod 在安装第三方库的索引目录(200MB+++, 较大容易下载出错).因此有如下方法解决</p>
<p>1 ) 手动下载索引</p>
<ol>
<li>前往<a href="https://github.com/CocoaPods/Specs" target="_blank" rel="noopener">https://github.com/CocoaPods/Specs</a> 下载该索引. (可通过 GitHub Desktop 下载)</li>
<li>Specs 文件夹更名<code>master</code>然后拷进repos文件夹下[目录在<code>/Users/用户名/.cocoapods/repos</code>]</li>
<li>完全退出终端，重启终端，pod功能即可正常使用。</li>
</ol>
<p>解释：pod setup的本质就是将<code>https://github.com/CocoaPods/Specs上的Specs</code>项目clone到<code>/Users/用户名/.cocoapods/repos</code>目录下。若此目录下已有Specs项目，则会将项目更新到最新的状态。由于Specs很大，容易导致pod setup失败。这时就需要我们手动安装Specs。若直接从github上下载zip文件，由于缺少git文件，会导致cocoa pods不使用。若用git clone，由于文件过大，容易导致失败。但是使用GitHub Desktop软件，则会提高clone的成功率，并且会给出clone的进度, 也可以手动切换到目标目录下, 查看具体下载的文件大小。</p>
<p>2 ) Pod install 或 pod update 很慢时, 可以使用下面两句来更新. 表示忽略升级 specs 库 [此条适合在已有库, 但未更新的情况]</p>
<p>实际上这两条命令是取消了repo的更新，从而变快了pod的速度。但是，假如开发者本地的repo真的已经过时了（就是第三方的地址list有点旧旧的），则无法逃避repo的更新，所以使用还是要pod repo update，依然是慢的不能忍。</p>
<p>所以，此处需要对pod的source换源<br>有大神提供了几个镜像，使用如下方法换掉repo的源</p>
<p>3 ) pod repo 换源</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod repo</span><br></pre></td></tr></table></figure>
<p>会出现以下的字眼:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">master</span><br><span class="line">- <span class="symbol">Type:</span> git (master)</span><br><span class="line">- <span class="symbol">URL:</span>  <span class="symbol">https:</span>/<span class="regexp">/github.com/</span>CocoaPods/Specs.git</span><br><span class="line">- <span class="symbol">Path:</span> /Users/donglyu/.cocoapods/repos/master</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个repo记录着许许多多第三方库的地址，默认选择了github作为源，假如开发者需要升级repo，实际上就是从github上面把一个庞大无比的地址list克隆到本地一个叫什么 .CocoaPods之类的隐藏文件夹里面。<br>通过下面的方法替换掉源</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pod repo remove master</span><br><span class="line">$ pod repo add master <span class="symbol">https:</span>/<span class="regexp">/git.coding.net/hging</span><span class="regexp">/Specs.git </span></span><br><span class="line"><span class="regexp">$ pod repo update</span></span><br></pre></td></tr></table></figure>
<p>目前可选源举例:<br><code>source &#39;https://git.coding.net/hging/Specs.git &#39;</code><br>此条不可用的话,可以再找找其他常见的Git托管站.<br>完成了上述两处地方更改之后，就可以直接使用了.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pod install</span><br><span class="line">$ pod update</span><br></pre></td></tr></table></figure>
<p>如果换源方法不成功或者setup 不成功<br>出现 <code>[!] To setup the master specs repo, please run pod setup.</code>, 请采用以下方法.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone <span class="symbol">https:</span>/<span class="regexp">/git.coding.net/</span>CocoaPods/Specs.git ~<span class="regexp">/.cocoapods/repos</span><span class="regexp">/master</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">pod setup  /</span><span class="regexp">/务必在手动下载代码后执行一次,执行后 Setup completed</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/再执行</span></span><br><span class="line"><span class="regexp">pod install --verbose --no-repo-update /</span><span class="regexp">/避免去更新了</span></span><br></pre></td></tr></table></figure>
<p><font color="#A52A2A">注意:</font><br>每次编写的<code>Podfile</code> 中文件中都要以你换的源开头</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source &apos;https://git.coding.net/hging/Specs.git&apos;</span><br><span class="line">platform :ios, &apos;8.0&apos;</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="2-4-附"><a href="#2-4-附" class="headerlink" title="2.4 附:"></a>2.4 附:</h2><p>&emsp;&emsp;用了这么久, 个人觉得最好的方式, 也是目前使用的方式:<br>解决pod setup pod update 时, 下载速度很慢. 且又没有vpn或ss代理的情况: </p>
<p>其实主要慢的原因是因为会去官方github源更新将近200M+++的repo , 不然无法<code>pod setup</code></p>
<p>好消息是国内由github的repo的镜像源 (<a href="http://git.coding.net/hging/Specs.git" target="_blank" rel="noopener">coding.net</a>). 只不过做一步移花接木<br>打开终端: 输入</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /Users/[你的用户名]/.cocoapods/repos</span><br><span class="line"></span><br><span class="line">git clone <span class="symbol">git:</span>/<span class="regexp">/git.coding.net/hging</span><span class="regexp">/Specs.git master</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">pod setup</span></span><br><span class="line"><span class="regexp"># 然后 cd 到工程中, pod update</span></span><br></pre></td></tr></table></figure>
<p>如此 每次更新repo 这样操作.<br>配合</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod install --verbose --no-repo-update</span><br></pre></td></tr></table></figure>
<p>使用.</p>
<hr>
<p><br></p>
<h2 id="二-使用-CocoaPods"><a href="#二-使用-CocoaPods" class="headerlink" title="二. 使用 CocoaPods"></a>二. 使用 CocoaPods</h2><p>命令行中输入:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pod search JSONKit</span><br><span class="line">touch Podfile</span><br><span class="line">open -e Podfile</span><br><span class="line">platform <span class="symbol">:ios</span></span><br><span class="line"> </span><br><span class="line">pod <span class="string">'JSONKit'</span>, <span class="string">'~&gt; 1.5pre'</span></span><br><span class="line">pod install</span><br></pre></td></tr></table></figure>
<ul>
<li>Podfile中具体内容 :</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">platform <span class="symbol">:ios</span></span><br><span class="line"><span class="symbol">platform:</span>ios, <span class="string">'8.0'</span></span><br><span class="line"></span><br><span class="line">target <span class="string">'XXXTarget'</span> <span class="keyword">do</span></span><br><span class="line">    pod <span class="string">'AFNetworking'</span></span><br><span class="line">    pod <span class="string">'Masonry'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>一些说明: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pod ‘AFNetworking’      //不显式指定依赖库版本，表示每次都获取最新版本</span><br><span class="line">pod ‘AFNetworking’,  ‘2.0’     //只使用2.0版本</span><br><span class="line">pod ‘AFNetworking’, ‘&gt;2.0′     //使用高于2.0的版本</span><br><span class="line">pod ‘AFNetworking’, ‘&gt;=2.0′     //使用大于或等于2.0的版本</span><br><span class="line">pod ‘AFNetworking’, ‘&lt;2.0′     //使用小于2.0的版本</span><br><span class="line">pod ‘AFNetworking’, ‘&lt;=2.0′     //使用小于或等于2.0的版本</span><br><span class="line">pod ‘AFNetworking’, ‘~&gt;0.1.2′     //使用大于等于0.1.2但小于0.2的版本，相当于&gt;=0.1.2并且&lt;0.2.0</span><br><span class="line">pod ‘AFNetworking’, ‘~&gt;0.1′     //使用大于等于0.1但小于1.0的版本</span><br><span class="line">pod ‘AFNetworking’, ‘~&gt;0′ //高于0的版本，写这个限制和什么都不写是一个效果，都表示使用最新版本</span><br></pre></td></tr></table></figure>
<p>当发现无法引入库时, 尝试下面这个方法<br>可以在target-Build Settings下修改“User Header Search Paths”项，新增<code>${SRCROOT}</code>并选择<code>rcursive</code></p>
<p><br></p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> cocoaPods </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GCD处理多个异步处理的同步方法]]></title>
      <url>http://www.lydsnm.top/2016/02/08/GCD%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h4 id="1-并行队列中执行任务-并在并行队列中加入多个串行队列"><a href="#1-并行队列中执行任务-并在并行队列中加入多个串行队列" class="headerlink" title="1.并行队列中执行任务, 并在并行队列中加入多个串行队列"></a>1.并行队列中执行任务, 并在并行队列中加入多个串行队列</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the first service</span></span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">[<span class="keyword">self</span>.configService startWithCompletion:^(ConfigResponse *results, <span class="built_in">NSError</span>* error)&#123;</span><br><span class="line">    <span class="comment">// Do something with the results</span></span><br><span class="line">    configError = error;</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the second service</span></span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line"><span class="comment">//异步操作(网络请求等)</span></span><br><span class="line">[<span class="keyword">self</span>.preferenceService startWithCompletion:^(PreferenceResponse *results, <span class="built_in">NSError</span>* error)&#123;</span><br><span class="line">    <span class="comment">// Do something with the results</span></span><br><span class="line">    preferenceError = error;</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监视队列中的任务都结束后, 汇总结果</span></span><br><span class="line">dispatch_group_notify(group,dispatch_get_main_queue(),^&#123;</span><br><span class="line">    <span class="comment">// Assess any errors</span></span><br><span class="line">    <span class="built_in">NSError</span> *overallError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (configError || preferenceError)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Either make a new error or assign one of them to the overall error</span></span><br><span class="line">        overallError = configError ?: preferenceError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Now call the final completion block</span></span><br><span class="line">    completion(overallError);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="2-信号量"><a href="#2-信号量" class="headerlink" title="2. 信号量"></a>2. 信号量</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在创建信号量后, block中方法执行完后才会接着执行</span></span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"MJPhotoBrowserForAsset"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line"></span><br><span class="line">            [assetsLibrary assetForURL:mediaItem.assetURL resultBlock:^(ALAsset *asset) &#123;</span><br><span class="line"></span><br><span class="line">                mediaItem.curAsset = asset;</span><br><span class="line"></span><br><span class="line">                photo.image = [<span class="built_in">UIImage</span> imageWithCGImage:asset.defaultRepresentation.fullScreenImage];</span><br><span class="line"></span><br><span class="line">                dispatch_semaphore_signal(semaphore);</span><br><span class="line"></span><br><span class="line">            &#125; failureBlock:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"></span><br><span class="line">                mediaItem.curAsset = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">                photo.url = [<span class="built_in">NSURL</span> URLWithString:mediaItem.urlStr]; <span class="comment">// 图片路径</span></span><br><span class="line"></span><br><span class="line">                dispatch_semaphore_signal(semaphore);</span><br><span class="line"></span><br><span class="line">            &#125;];</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> GCD 同步异步 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[UITextView,UITextField记录]]></title>
      <url>http://www.lydsnm.top/2016/02/01/UITextView,UITextField%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h4 id="一-UITextView"><a href="#一-UITextView" class="headerlink" title="一.UITextView"></a>一.UITextView</h4><p>1.点击return,隐藏键盘</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现UITextViewDelegate shouldChangeTextInRange方法</span></span><br><span class="line">-(<span class="built_in">BOOL</span>)textView:(<span class="built_in">UITextView</span> *)textView shouldChangeTextInRange:(<span class="built_in">NSRange</span>)range replacementText:(<span class="built_in">NSString</span>*)text </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> ([text isEqualToString:<span class="string">@"\n"</span>]) &#123; </span><br><span class="line">        [textView resignFirstResponder];  </span><br><span class="line">       <span class="keyword">return</span> <span class="literal">NO</span>; </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">YES</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二-UITextField"><a href="#二-UITextField" class="headerlink" title="二. UITextField"></a>二. UITextField</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">当你想要收回弹出的键盘时却发现平时用的resignFirstResponder和endEditing都失去作用时，应该考虑一下当前的TextField是否为第一响应者，如果不是第一响应者的话，自然下面的几个方法都没有效果，解决办法有二：<span class="number">1</span>、找出当前第一响应者，然后resignFirstResponder。<span class="number">2</span>、先对TextField becomeFirstResponder 然后再 resignFirstResponder 。</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.view endEditing:<span class="literal">YES</span>];  </span><br><span class="line">[<span class="keyword">self</span>.field resignFirstResponder];  </span><br><span class="line">[[<span class="built_in">UIApplication</span> sharedApplication].keyWindow endEditing:<span class="literal">YES</span>];  </span><br><span class="line">﻿</span><br><span class="line"></span><br><span class="line">当上面的方法都无效的时候，可以考虑用下面的方法：</span><br><span class="line"></span><br><span class="line"><span class="comment">// Presentation modes may keep the keyboard visible when not required. Default implementation affects UIModalPresentationFormSheet visibility.</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)disablesAutomaticKeyboardDismissal <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">4</span>_3);</span><br><span class="line"></span><br><span class="line">直接<span class="keyword">return</span> <span class="literal">NO</span> 就好了。</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> UITextView UITextField </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[给项目添加一个合适的开源许可证]]></title>
      <url>http://www.lydsnm.top/2016/01/08/%E7%BB%99%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%90%88%E9%80%82%E7%9A%84%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81/</url>
      <content type="html"><![CDATA[<p>将项目与代码开源，可以让更多的人与你共享代码，协同合作，让产品质量更高，更加适应社会的需求。然而，这并不代表该项目是可以被随意甚至是滥用的，想要成为真正的开源项目，不是单单把源代码开放在网上即可，必须在释出的项目当中说明，其代码是以某个开源许可证 (Open Source License) 来进行许可，将特定权利赋予给用户的同时，也规范公众的利用行为，让人们正确的享受开源所带来的好处与乐趣。</p>
<h3 id="开源许可证是什么"><a href="#开源许可证是什么" class="headerlink" title="开源许可证是什么"></a><strong>开源许可证是什么</strong></h3><p>为了维护作者和贡献者的合法权利，保证这些软件不被一些商业机构或个人窃取，影响软件的发展，开源社区开发出了各种的开源许可协议。许可证是具有法律效应的协议，目前已有超过 70 种被开放源代码促进会 (Open Source Initiative, OSI) 通过，其中 GPL、LGPL、Apache、BSD、MIT 等是最常见的。</p>
<h3 id="如何选择开源许可证"><a href="#如何选择开源许可证" class="headerlink" title="如何选择开源许可证"></a><strong>如何选择开源许可证</strong></h3><p>如何在这么多的许可证中选取一个适合自己项目的呢？我们可以通过下面这张图清晰地了解：</p>
<p><a href="http://blog.gitcafe.com/wp-content/uploads/2015/07/bg2011050101.png" target="_blank" rel="noopener"><img src="http://blog.gitcafe.com/wp-content/uploads/2015/07/bg2011050101.png" alt="bg201105010\"></a></p>
<p>图片来源于阮一峰的博客。</p>
<p>具体而言，这几种开源许可证的特点为：</p>
<h4 id="GNU-Lesser-General-Public-License-LGPL"><a href="#GNU-Lesser-General-Public-License-LGPL" class="headerlink" title="GNU Lesser General Public License (LGPL)"></a><strong>GNU Lesser General Public License (LGPL)</strong></h4><p>允许商业软件通过类库引用 (link) 方式使用 LGPL 类库而不需要开源商业软件的代码，但是如果修改 LGPL 协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用 LGPL 协议。。</p>
<h4 id="Mozilla-Public-License-MPL"><a href="#Mozilla-Public-License-MPL" class="headerlink" title="Mozilla Public License (MPL)"></a><strong>Mozilla Public License (MPL)</strong></h4><p>除了接口程序的源代码以 MPL 许可证的形式对外许可外，源代码库中的源代码就可以不用 MPL 许可证的方式强制对外许可。</p>
<h4 id="GNU-General-Public-License-GPL"><a href="#GNU-General-Public-License-GPL" class="headerlink" title="GNU General Public License (GPL)"></a><strong>GNU General Public License (GPL)</strong></h4><p>可以开源或者免费地使用代码与引用、修改衍生代码，但强制修改后和衍生的代码必须在发布和销售时也必须开放源代码给用户，因此经常与闭源商业软件的商业模式有所冲突。</p>
<h4 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a><strong>BSD</strong></h4><p>可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布，要包含许可协议的声明，但是不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。</p>
<h4 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a><strong>MIT</strong></h4><p>你必须在你的发行版里包含原许可协议的声明，无论你是以二进制发布的还是以源代码发布的。</p>
<h4 id="Apache-Licence"><a href="#Apache-Licence" class="headerlink" title="Apache Licence"></a><strong>Apache Licence</strong></h4><p>著名的非盈利开源组织 Apache 基金会采用的协议。该协议鼓励代码共享和尊重原作者的著作权，同样允许代码修改，作为开源或者商业软件再发布。</p>
<p>如果要在GitHub &amp; GitCafe等平台上发布开源代码就需要添加开源许可.</p>
]]></content>
      
        <categories>
            
            <category> 开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 许可证, 开源 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2015, 停滞, 行进, 停滞, 行进, 快步行进的一年]]></title>
      <url>http://www.lydsnm.top/2015/12/31/2015%E5%81%9C%E6%BB%9E,%20%E8%A1%8C%E8%BF%9B,%20%E5%81%9C%E6%BB%9E,%20%E8%A1%8C%E8%BF%9B,%E5%BF%AB%E6%AD%A5%E8%A1%8C%E8%BF%9B%E7%9A%84%E4%B8%80%E5%B9%B4/</url>
      <content type="html"><![CDATA[<p>日历又要到翻到2016年了. 不同于上半年的玩玩耍耍过去了, 下半年更加的充实, 学的更多了, 更重要的有了明确的目标和方向了.  </p>
<p>越来越意识到自己的不足之处,  生活上2016希望能处理的更好, 待人处事, 沟通交流, 衣着, 形体, 感觉好多好多, 人丑多读书, 希望慢慢做到, 一步步改善, 在忘了的事, 看看希望的样子, 提醒和鞭策一下</p>
<p>少些时间去耍和去做无意义的事</p>
<p>工作上, 兴趣是最好的老师, 做iOS还是很有乐趣的. 看了很多的iOS前辈的经验, 总是有很多感触, 有冲动做一件事, 就要持续去做, done</p>
<p> 总是比不做, 做一半好. 有很多期望, 近几几个月的经验:拆分大的长的任务为一个个小任务, 来分别完成,真的很好使….</p>
<p>用好工具, 吸收和学习别人优秀的成果, 提升影响力. 工作上体现出差异性</p>
<p>用好github, 自己搭的blog, 这在以后是个绝好的工作敲门砖. 简书,博客园还是太小了…墙外的东西很多, 加以利用是绝好的.</p>
<p>思维导图要用好, 在某些时候对自身理解帮助很大.</p>
<p>尝试做出一些有帮助意义的具有”高感知价值的物品”</p>
<p>要想获得更多,得付出更多</p>
<p>学习一些公司愿意付钱的技术.~~~</p>
<p>另外, 英语!!!!!. 一方面更多的看国外开发文档, 确实很多英文资料更全, 讲的更透彻.</p>
<p>心里不太平静时, 听听歌,调解下.</p>
<p>2016, 快节奏工作学习的一年!!!! 期待</p>
<p><img src="http://ww3.sinaimg.cn/large/923848a3gw1ezj988mqizj20hs0hsq47.jpg" alt="http://ww3.sinaimg.cn/large/923848a3gw1ezj988mqizj20hs0hsq47.jpg"></p>
]]></content>
      
        <categories>
            
            <category> 生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> up </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS GCD记录]]></title>
      <url>http://www.lydsnm.top/2015/12/07/iOS-GCD%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h4 id="GCD异步"><a href="#GCD异步" class="headerlink" title="GCD异步"></a>GCD异步</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123; </span><br><span class="line">   <span class="comment">// 处理耗时操作的代码块...</span></span><br><span class="line">   <span class="comment">// do something.</span></span><br><span class="line"><span class="comment">//通知主线程刷新 </span></span><br><span class="line">	<span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123; </span><br><span class="line">	<span class="comment">//回调或者说是通知主线程刷新，  </span></span><br><span class="line">	&#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>dispatch_async开启一个异步操作，第一个参数是指定一个gcd队列，第二个参数是分配一个处理事物的程序块到该队列。 </p>
<p>dispatch_get_global_queue(0, 0)，指用了全局队列。 </p>
<p>一般来说系统本身会有3个队列。 </p>
<p>global_queue，current_queue,以及main_queue. </p>
<p>获取一个全局队列是接受两个参数，第一个是我分配的事物处理程序块队列优先级。分高低和默认，0为默认2为高，-2为低 </p>
<p>======</p>
<h4 id="GCD之并发概念"><a href="#GCD之并发概念" class="headerlink" title="GCD之并发概念:"></a>GCD之并发概念:</h4><p>异步的核心概念就是一个新线程，一个消息回调通知。 </p>
<p>异步解决了线程堵塞，而并发则是在异步的基础上，提高了符合特性事件的处理时间效率</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURL</span> * url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://avatar.csdn.net/2/C/D/1_totogo2010.jpg"</span>];  </span><br><span class="line"></span><br><span class="line"><span class="built_in">NSData</span> * data = [[<span class="built_in">NSData</span> alloc]initWithContentsOfURL:url];  </span><br><span class="line"></span><br><span class="line"><span class="built_in">UIImage</span> *image = [[<span class="built_in">UIImage</span> alloc]initWithData:data];  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (data != <span class="literal">nil</span>) &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.imageView.image = image;  </span><br><span class="line"></span><br><span class="line">     &#125;);  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="iOS下使用block-GCD实现异步处理"><a href="#iOS下使用block-GCD实现异步处理" class="headerlink" title="iOS下使用block+GCD实现异步处理."></a>iOS下使用block+GCD实现异步处理.</h4><p>文章原地址: <a href="http://my.oschina.net/fvmitnick/blog/185089?fromerr=xpS0DGVX" target="_blank" rel="noopener">http://my.oschina.net/fvmitnick/blog/185089?fromerr=xpS0DGVX</a></p>
<ul>
<li>因为任何对UI的操作，在iOS中实际上并不是立刻执行，只是做了个<em>标记</em>，在当前事件循环(runloop)完成后，在下一个事件循环开始前，系统根据做的标记来决定屏幕哪一块需要更新，并进行重绘.</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不论哪种异步方式，最后一定要有一个办法通知主线程任务已完成。具体到iOS，有若干方法可以使用，比如：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// delegate, KVO, NSNotification, performSelectorOnMainThread:等。</span></span><br><span class="line"><span class="comment">//使用KVO方式观察后台任务的结束</span></span><br><span class="line"></span><br><span class="line">[calcOperation addObserver:<span class="keyword">self</span> keyPath:<span class="string">@"isFinished"</span>...];</span><br><span class="line">- (<span class="keyword">void</span>) observeValueForKey:keyPath ofObject:object . &#123;</span><br><span class="line">  <span class="keyword">if</span>([<span class="string">@"isFinished"</span> isEqualToString:keyPath] &amp;&amp; [object isKindOfClass:[MyPICalcOperation <span class="keyword">class</span>]]) &#123;</span><br><span class="line">  	<span class="comment">// 观察到了我们想要的状态变化，即运算结束。这里我们调用回调处理结果。确保回调在主线程上进行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#####注意事项:</p>
<ol>
<li>UI操作必须在主线程上完成。</li>
<li>耗时的同步网络、同步IO、运算等操作不要在主线程上跑，以避免阻塞</li>
<li>一个好的程序，对任何耗时操作都要给用户提供半路取消的选择。要做到这一点，还是需要增加一些代码 </li>
<li>block就象一个object，也有自己的生存周期问题，也会出现类似野指针和内存泄漏的情况。如果你自己做一个基于block的异步库供别人使用，非 常容易产生循环引用的错误（对方的app class retain了你的异步库，你的异步库retain了app提供的回调block，而block中一般又通过self引用了app class本身），需要特别小心。 </li>
<li>假如在运算完成前用户就退出这个页面（比如回退到上一页），运算还是会进行，view controller的销毁被延后到运算结束的时候。假如不想要这个效果的话，一是要实现1中的取消机制，二是要在块中避免引用self（否则会被自动 retain）。具体看文档。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> GCD </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CoreData使用记录]]></title>
      <url>http://www.lydsnm.top/2015/12/06/CoreData%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>Core Data是苹果针对Mac和iOS平台开发的一个框架, 通过CoreData可以在本地生成数据库sqlite,提供了ORM的功能，将对象和数据模型相互转换 . 通过Core Data管理和操作. 能够快速达到项目的存储数据的需求.<br>      CoreData优点：能够合理管理内存，避免使用sql的麻烦，高效, 由于是苹果提供的解决方案, 所以不用太过担心会有其他问题.  我的观念就是先使用上了后再考虑其他, 问题有一个就解决一个.<br>Core Data 默认使用Sqlite. 因此在沙盒Document文件夹中找到.sqlite的数据库文件. </p>
<p> 这里顺便提一个一个比较好用的快速打开模拟器沙盒路径的工具: <a href="https://github.com/opensim/opensim" target="_blank" rel="noopener">https://github.com/opensim/opensim</a></p>
<h3 id="1-使用CoreData"><a href="#1-使用CoreData" class="headerlink" title="1.使用CoreData"></a>1.使用CoreData</h3><ol>
<li>创建工程时, 勾选Use Core Data</li>
<li>手动添加, (如何要想向创建时没有选择Use Core Data<br>如果不知道该添加什么, 一个比较便捷的方法, 是直接新建一个空白工程, 勾选Use Core Data后, 对比AppDelegate.h中的代码, 然后再将多的内容添加到工程中.)</li>
</ol>
<a id="more"></a>
<p>添加Core Data后, 在AppDelegate.h中就有帮我们生成用于管理、存储这些模型的对象，我们可以通过添加AppDelegate头文件来使用.<br>添加Core Data后, 就是建立数据模型,说到模型, 就要提一下Core Data常用的6个对象：</p>
<blockquote>
<p>1、NSManagedObjectContext<br>管理对象，上下文，持久性存储模型对象<br>2、NSManagedObjectModel<br>被管理的数据模型，数据结构<br>3、NSPersistentStoreCoordinator<br>连接数据库的<br>4、NSManagedObject<br>被管理的数据记录<br>5、NSFetchRequest<br>数据请求<br>6、NSEntityDescription<br>表格实体结构<br>此外还需要知道.xcdatamodel文件编译后为.momd或者.mom文件  </p>
</blockquote>
<p>一.开始  </p>
<blockquote>
<p>右键添加一个Core data -&gt; Data Model(如果创建工程时, 直接勾选use core data, 会直接默认生成.xcdatamodeld).<br>选中.xcdatamodeld主要使用到了下列一些东西:<br>Entity: 实体(我们要生成的模型对象的实体, User, Car, Person等等)<br>Attributes:实体对象属性<br>ReaationShips:关系<br>Fetched Properties:</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1106214-2fa5fda1a8bff45e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="&gt;_&lt;"></p>
<p>另外多表关联内容可以看看: <a href="http://www.jianshu.com/p/e9f3b5e0cd19" target="_blank" rel="noopener">http://www.jianshu.com/p/e9f3b5e0cd19</a></p>
<p>二.创建实体管理 </p>
<p>右键添加一个Core data -&gt; NSManagedObject subclass, 一直选择,  选中Car, Wheel.  到最后会实现<br><img src="http://upload-images.jianshu.io/upload_images/1106214-265946bce916ef5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20151206-1"></p>
<p>三.导入AppDelegate.h头文件, 开始管理数据库  </p>
<p>主要操作:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先取出coredata上下文管理者</span></span><br><span class="line">AppDelegate *appDelegate = [[<span class="built_in">UIApplication</span> sharedApplication] delegate];</span><br><span class="line"><span class="built_in">NSManagedObjectContext</span> *context = appDelegate.managedObjectContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.保存新数据</span></span><br><span class="line">Car *car = [<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName: <span class="string">@"Car"</span> inManagedObjectContext: context];</span><br><span class="line">car.carName = label1.text;</span><br><span class="line">car.carType = label2.text;</span><br><span class="line">[appDelegate saveContext];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.查询数据</span></span><br><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="built_in">NSFetchRequest</span> *request = [<span class="built_in">NSFetchRequest</span> new];</span><br><span class="line"><span class="built_in">NSEntityDescription</span> *entity = [<span class="built_in">NSEntityDescription</span> entityForName: <span class="string">@"Car"</span> inManagedObjectContext: context];</span><br><span class="line">[request setEntity: entity];</span><br><span class="line"><span class="built_in">NSPredicate</span> *predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"carName=%@"</span>, carName];</span><br><span class="line">[request setPredicate:predicate];</span><br><span class="line"><span class="built_in">NSArray</span> *results = [[context executeFetchRequest: request error: &amp;error] <span class="keyword">copy</span>];</span><br><span class="line"><span class="keyword">for</span> (Car *car <span class="keyword">in</span> results) &#123;</span><br><span class="line">　	<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, car.carName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.更新数据</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">NSFetchRequest</span>** request=[[<span class="built_in">NSFetchRequest</span> alloc] init];</span><br><span class="line"><span class="built_in">NSEntityDescription</span> *car=<span class="built_in">NSEntityDescription</span> entityForName:<span class="string">@"car"</span> inManagedObjectContext:_myAppDelegate.managedObjectContext];  </span><br><span class="line">[request setEntity:car];</span><br><span class="line"><span class="comment">///查询条件</span></span><br><span class="line"><span class="built_in">NSPredicate</span>* predicate=[<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"carName==%@"</span>,<span class="string">@"name"</span>];</span><br><span class="line"> [request setPredicate:predicate];</span><br><span class="line"><span class="built_in">NSError</span>* error=<span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSMutableArray</span>* mutableFetchResult=[[_myAppDelegate.managedObjectContext executeFetchRequest:request error:&amp;error] mutableCopy]; </span><br><span class="line"><span class="keyword">if</span> (mutableFetchResult==<span class="literal">nil</span>) &#123;</span><br><span class="line">　<span class="built_in">NSLog</span>(<span class="string">@"Error:%@"</span>,error); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"The count of entry: %i"</span>,[mutableFetchResult count]);  </span><br><span class="line"> <span class="keyword">for</span> (Car* car <span class="keyword">in</span> mutableFetchResult) &#123;  </span><br><span class="line">　car.carName = <span class="string">@"name1"</span>  ;</span><br><span class="line">    ...    </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//更新后要进行保存，否则没更新  </span></span><br><span class="line">[_myAppDelegate.managedObjectContext save:&amp;error];</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//4.删除数据  </span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">NSFetchRequest</span>* request=[[<span class="built_in">NSFetchRequest</span> alloc] init];  </span><br><span class="line">      <span class="built_in">NSEntityDescription</span>* car=[<span class="built_in">NSEntityDescription</span> entityForName:<span class="string">@"Car"</span> inManagedObjectContext:_myAppDelegate.managedObjectContext];  </span><br><span class="line">      [request setEntity:car];  </span><br><span class="line">      <span class="built_in">NSPredicate</span>* predicate=[<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"carName==%@"</span>,<span class="string">@"name"</span>];  </span><br><span class="line">      [request setPredicate:predicate];  </span><br><span class="line">      <span class="built_in">NSError</span>* error=<span class="literal">nil</span>;  </span><br><span class="line">      <span class="built_in">NSMutableArray</span>* mutableFetchResult=[[_myAppDelegate.managedObjectContext executeFetchRequest:request error:&amp;error] mutableCopy];  </span><br><span class="line">      <span class="keyword">if</span> (mutableFetchResult==<span class="literal">nil</span>) &#123;  </span><br><span class="line">  　 <span class="built_in">NSLog</span>(<span class="string">@"Error:%@"</span>,error);  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"The count of entry: %i"</span>,[mutableFetchResult count]);  </span><br><span class="line">      <span class="keyword">for</span> (Car *car <span class="keyword">in</span> mutableFetchResult) &#123;  </span><br><span class="line">  　　 [_myAppDelegate.managedObjectContext deleteObject:car];  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">if</span> ([_myAppDelegate.managedObjectContext save:&amp;error]) &#123;  </span><br><span class="line">  　<span class="built_in">NSLog</span>(<span class="string">@"Error:%@,%@"</span>,error,[error userInfo]);  </span><br><span class="line">  　&#125;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>条件查询的更多内容, 可以查看官方文档:<br><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Predicates/Articles/pCreating.html" target="_blank" rel="noopener">https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Predicates/Articles/pCreating.html</a></li>
</ul>
<h3 id="2-NSFetchRequest-常用方法-setEntity"><a href="#2-NSFetchRequest-常用方法-setEntity" class="headerlink" title="2.NSFetchRequest 常用方法 -setEntity:"></a>2.NSFetchRequest 常用方法 -setEntity:</h3><p>设置你要查询的数据对象的类型（Entity）</p>
<ul>
<li>-setPredicate:<br>设置查询条件</li>
<li>-setFetchLimit:<br>设置最大查询对象数目</li>
<li>-setSortDescriptors:<br>设置查询结果的排序方法  </li>
</ul>
<ul>
<li>-setAffectedStores:<br>设置可以在哪些数据存储中查询<br>[request setFetchBatchSize:500];//从数据库里每次加载500条数据来筛选数据<br>[request setFetchOffset:sizeCount];//读取数据库的游标偏移量，从游标开始读取数据<br>sizeCount = 10;<br>[request setFetchLimit:10];//每次要取多少条数据，10就是每次从数据库读取10条数据<br>NSPredicate用于查询和过滤<br>在SQL中作为查询条件通常用WHERE，但在COREDATA中作为查询条件就可以用到NSPredicate.<br>NSPredicate 不单可以和COREDATA中的FetchRequest 配合使用。也可以与NSArray配合使用<br>一个线程用一个NSManagedObjectContext对象.<br>使用coredata 在项目中建立表，它会自己来生成数据库，而在每个表中都有它自己生成的Z_PK,Z_ENT,Z_OPT 这三个字段，<br>Z_PK     表的主键，从1开始递增， 具有唯一性<br>可以通过主键访问和获取对象的途径:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSFetchRequest</span>* request = [[<span class="built_in">NSFetchRequest</span> alloc] init];</span><br><span class="line">request setEntity:entity];</span><br><span class="line">[request setResultType:<span class="built_in">NSManagedObjectIDResultType</span>];</span><br><span class="line">[request setFetchBatchSize:<span class="number">20</span>];</span><br><span class="line"><span class="built_in">NSError</span>* error = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSArray</span>* items = [context executeFetchRequest:request error:&amp;error];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSManagedObjectID</span>* objectID <span class="keyword">in</span> items) &#123;</span><br><span class="line">　<span class="built_in">NSManagedObject</span>* object = [context objectWithID:objectID];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Z_ENT  表在xcdatamodel 中的索引值，如果有6个表那么它的值的区间就是[1,6 ]<br>Z_OPT  表示的是每条数据被操作的次数，初始化值为1，只要是增删改查都会加1</p>
<h3 id="3-其他记录"><a href="#3-其他记录" class="headerlink" title="3.其他记录"></a>3.其他记录</h3><blockquote>
<p>方便查阅<br>1.通过core data存储任意类型的数据:<a href="http://blog.csdn.net/likendsl/article/details/8549333" target="_blank" rel="noopener">http://blog.csdn.net/likendsl/article/details/8549333</a><br>2.多表关联时, 动态设置删除关系.:<a href="http://blog.csdn.net/fengsh998/article/details/8090111" target="_blank" rel="noopener">http://blog.csdn.net/fengsh998/article/details/8090111</a><br>3.批量操作、聚合操作、WWDC 2015新特性: <a href="http://www.cocoachina.com/ios/20150730/12785.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20150730/12785.html</a>  </p>
</blockquote>
<h3 id="4-问题记录"><a href="#4-问题记录" class="headerlink" title="4.问题记录"></a>4.问题记录</h3><blockquote>
<p>当查询返回数据是fault时,  可以加上这句试试:<br>[request setReturnsObjectsAsFaults:NO];</p>
</blockquote>
<p>学习记录, 难免可能会有不准确的, 多多包涵~~</p>
<p>End!</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> coredata </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS动画整理]]></title>
      <url>http://www.lydsnm.top/2015/11/07/iOS%E5%8A%A8%E7%94%BB%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="一-Core-Animation"><a href="#一-Core-Animation" class="headerlink" title="一. Core Animation"></a>一. Core Animation</h3><p>Core Animation (核心动画), 一组跨平台动画API, 可以再Mac OS X和iOS平台使用.<br>Core Animation 的动画执行不会阻塞主线程.<br>Core Animation 是直接作用在CALayer上的, 并非UIView.</p>
<h4 id="基本动画"><a href="#基本动画" class="headerlink" title="基本动画"></a>基本动画</h4><ol>
<li>引入头文件&lt;QuartzCore/QuartzCore.h&gt;</li>
<li>初始化一个CAAnimation对象.</li>
<li>通过给UIView的CALayer方法添加CAAnimation到CALayer中.</li>
</ol>
<p>CAAnimation是所有动画类的父类, 但不能直接实用, 应该使用它的之类.<br>常用的属性有: </p>
<blockquote>
<p>duration: 动画持续时间<br>repeatCount: 动画的重复次数<br>timingFunction: 控制动画运行的节奏</p>
</blockquote>
<p>补充: <code>CABasicAnimation</code>, <code>CAKeyframeAnimation</code>, <code>CATransition</code> , <code>CAAnimationGroup</code> 4 个子动画类<br><code>CAPropertyAnimation</code> 是 <code>CAAnimation</code> 的子类, 但是不能直接使用, 要想创建动画对象, 应该用它的两个子类: <font color="10d3c4">CABasicAnimation</font> 和 <font color="10d3c4">CAKeyframeAnimation</font>.</p>
<p>它由个 <font color="10d3c4">keyPath</font>属性. 可以指定CALayer的某个属性名为 keyPath, 并且对CALayer的这个属性进行修改, 达到相应的动画效果. 比如: 指定 <font color="10d3c4">@”position”</font>为keyPath, 就会修改CALayer的position属性的值, 以达到平移的动画效果.</p>
<a id="more"></a>
<p>eg:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CABasicAnimation</span> *anima=[<span class="built_in">CABasicAnimation</span> animation];</span><br><span class="line"><span class="comment">//平移</span></span><br><span class="line">anima.keyPath=<span class="string">@"position"</span>;</span><br><span class="line"><span class="comment">//设置执行的动画</span></span><br><span class="line">anima.toValue=[<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(<span class="number">200</span>, <span class="number">300</span>)];</span><br><span class="line"><span class="comment">//设置执行动画的时间</span></span><br><span class="line">anima.duration=<span class="number">2.0</span>;</span><br><span class="line"><span class="comment">//设置动画执行完毕之后不删除动画</span></span><br><span class="line">anima.removedOnCompletion=<span class="literal">NO</span>;</span><br><span class="line"><span class="comment">//设置保存动画的最新状态</span></span><br><span class="line">anima.fillMode=kCAFillModeForwards;</span><br><span class="line"><span class="comment">//anima.fillMode=kCAFillModeBackwards;</span></span><br><span class="line"><span class="comment">//设置动画的代理</span></span><br><span class="line">anima.delegate=<span class="keyword">self</span>;</span><br><span class="line"><span class="comment">//2.添加核心动画</span></span><br><span class="line">[<span class="keyword">self</span>.customView.layer addAnimation:anima forKey:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<h3 id="二-UIView封装动画"><a href="#二-UIView封装动画" class="headerlink" title="二. UIView封装动画"></a>二. UIView封装动画</h3><p>UIKit 直接将动画集成到UIView类中, 当内部的一些属性发生改变时, UIView将为这些改变提供动画支持. 但是执行动画所需要的工作由 UIView 类自动完成, 但仍要在洗碗执行动画时通知视图, So 需要将改变属性的代码放在 <font color="10d3c4">[UIView beginAnimations:nil context:nil]</font> 和 <font color="10d3c4"> [UIView commitAnimations]</font> 之间.</p>
<p>常见方法: </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)setAnimationDelegate:(<span class="keyword">id</span>)delegate     <span class="comment">//设置动画代理对象，当动画开始或者结束时会发消息给代理对象</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)setAnimationWillStartSelector:(SEL)selector   <span class="comment">//当动画即将开始时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)setAnimationDidStopSelector:(SEL)selector  <span class="comment">//当动画结束时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)setAnimationDuration:(<span class="built_in">NSTimeInterval</span>)duration   <span class="comment">//动画的持续时间，秒为单位</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)setAnimationDelay:(<span class="built_in">NSTimeInterval</span>)delay  <span class="comment">//动画延迟delay秒后再开始</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)setAnimationStartDate:(<span class="built_in">NSDate</span> *)startDate   <span class="comment">//动画的开始时间，默认为now</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)setAnimationCurve:(<span class="built_in">UIViewAnimationCurve</span>)curve  <span class="comment">//动画的节奏控制</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)setAnimationRepeatCount:(<span class="keyword">float</span>)repeatCount  <span class="comment">//动画的重复次数</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)setAnimationRepeatAutoreverses:(<span class="built_in">BOOL</span>)repeatAutoreverses  <span class="comment">//如果设置为YES,代表动画每次重复执行的效果会跟上一次相反</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)setAnimationTransition:(<span class="built_in">UIViewAnimationTransition</span>)transition forView:(<span class="built_in">UIView</span> *)view cache:(<span class="built_in">BOOL</span>)cache  <span class="comment">//设置视图view的过渡效果, transition指定过渡类型, cache设置YES代表使用视图缓存，性能较好</span></span><br></pre></td></tr></table></figure>
<p>eg:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首尾式动画</span></span><br><span class="line">[<span class="built_in">UIView</span> beginAnimations:<span class="literal">nil</span> context:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//执行动画</span></span><br><span class="line"><span class="comment">//设置动画执行时间</span></span><br><span class="line">[<span class="built_in">UIView</span> setAnimationDuration:<span class="number">2.0</span>];</span><br><span class="line"><span class="comment">//设置代理</span></span><br><span class="line">[<span class="built_in">UIView</span> setAnimationDelegate:<span class="keyword">self</span>];</span><br><span class="line"><span class="comment">//设置动画执行完毕调用的事件</span></span><br><span class="line">[<span class="built_in">UIView</span> setAnimationDidStopSelector:<span class="keyword">@selector</span>(didStopAnimation)];</span><br><span class="line"><span class="keyword">self</span>.customView.center = <span class="built_in">CGPointMake</span>(<span class="number">200</span>, <span class="number">300</span>); <span class="comment">// 更改位置</span></span><br><span class="line">[<span class="built_in">UIView</span> commitAnimations];</span><br></pre></td></tr></table></figure>
<ul>
<li>UIView封装动画与CALayer 动画对比<br>使用 UIView和CALayer都能实现动画效果, 一般来说, 开发中用UIView封装的动画情况较多.<br>区别: <font color="a52a2a">UIView封装的动画执行完毕之后不会反弹。即如果是通过CALayer核心动画改变layer的位置状态，表面上看虽然已经改变了，但是实际上它的位置是没有改变的。</font></li>
</ul>
<h3 id="三-block-动画"><a href="#三-block-动画" class="headerlink" title="三. block 动画"></a>三. block 动画</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)animateWithDuration:(<span class="built_in">NSTimeInterval</span>)duration delay:(<span class="built_in">NSTimeInterval</span>)delay options:(<span class="built_in">UIViewAnimationOptions</span>)options animations:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))animations completion:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span> finished))completion</span><br></pre></td></tr></table></figure>
<p>参数解析:</p>
<blockquote>
<p>duration：动画的持续时间<br>delay：动画延迟delay秒后开始<br>options：动画的节奏控制<br>animations：将改变视图属性的代码放在这个block中<br>completion：动画结束后，会自动调用这个block</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">4.0</span> <span class="comment">// 动画时长</span></span><br><span class="line">                 animations:^&#123;</span><br><span class="line">                     <span class="comment">// code</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>转场动画</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)transitionWithView:(<span class="built_in">UIView</span> *)view duration:(<span class="built_in">NSTimeInterval</span>)duration options:(<span class="built_in">UIViewAnimationOptions</span>)options animations:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))animations completion:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span> finished))completion</span><br></pre></td></tr></table></figure>
<p>参数解析:</p>
<blockquote>
<p>duration：动画的持续时间<br>view：需要进行转场动画的视图<br>options：转场动画的类型<br>animations：将改变视图属性的代码放在这个block中<br>completion：动画结束后，会自动调用这个block</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)transitionFromView:(<span class="built_in">UIView</span> *)fromView toView:(<span class="built_in">UIView</span> *)toView duration:(<span class="built_in">NSTimeInterval</span>)duration options:(<span class="built_in">UIViewAnimationOptions</span>)options completion:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span> finished))completion</span><br></pre></td></tr></table></figure>
<p>方法调用完毕后，相当于执行了下面两句代码：</p>
<p>// 添加toView到父视图</p>
<p><code>[fromView.superview addSubview:toView];</code></p>
<p>// 把fromView从父视图中移除</p>
<p><code>[fromView removeFromSuperview];</code></p>
<p>参数解析:</p>
<blockquote>
<p>duration：动画的持续时间<br>options：转场动画的类型<br>animations：将改变视图属性的代码放在这个block中<br>completion：动画结束后，会自动调用这个block</p>
</blockquote>
<h3 id="四-关键帧动画"><a href="#四-关键帧动画" class="headerlink" title="四. 关键帧动画"></a>四. 关键帧动画</h3><p><font color="10d3c4">UIView动画</font> 已经具备高级的方法来创建动画, 而且可以更好地理解和构建动画. iOS 7后有了一个新的方法 <font color="10d3c4">animateKeyframeWithDuration</font> 的方法, 可以用它来创建更多更复杂的动画效果. 而不需要区实用核心动画(Core Animation).</p>
<ul>
<li>创建关键帧方法:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  添加关键帧方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param duration   动画时长</span></span><br><span class="line"><span class="comment"> *  @param delay      动画延迟</span></span><br><span class="line"><span class="comment"> *  @param options    动画效果选项</span></span><br><span class="line"><span class="comment"> *  @param animations 动画执行代码</span></span><br><span class="line"><span class="comment"> *  @param completion 动画结束执行代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)animateKeyframesWithDuration:(<span class="built_in">NSTimeInterval</span>)duration</span><br><span class="line">                               delay:(<span class="built_in">NSTimeInterval</span>)delay</span><br><span class="line">                             options:(<span class="built_in">UIViewKeyframeAnimationOptions</span>)options</span><br><span class="line">                          animations:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))animations</span><br><span class="line">                          completion:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span> finished))completion;</span><br></pre></td></tr></table></figure>
<ul>
<li>添加关键帧方法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  添加关键帧</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param frameStartTime 动画相对开始时间</span></span><br><span class="line"><span class="comment"> *  @param frameDuration  动画相对持续时间</span></span><br><span class="line"><span class="comment"> *  @param animations     动画执行代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)addKeyframeWithRelativeStartTime:(<span class="keyword">double</span>)frameStartTime</span><br><span class="line">                        relativeDuration:(<span class="keyword">double</span>)frameDuration</span><br><span class="line">                              animations:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))animations;</span><br></pre></td></tr></table></figure>
<p>以上说的相对时间，也就是说：“它们自身会根据动画总持续时长自动匹配其运行时长”。</p>
<p>eg:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^keyFrameBlock)() = ^()&#123;</span><br><span class="line">    <span class="comment">// 创建颜色数组</span></span><br><span class="line">    <span class="built_in">NSArray</span> *arrayColors = @[[<span class="built_in">UIColor</span> orangeColor],</span><br><span class="line">                             [<span class="built_in">UIColor</span> yellowColor],</span><br><span class="line">                             [<span class="built_in">UIColor</span> greenColor],</span><br><span class="line">                             [<span class="built_in">UIColor</span> blueColor],</span><br><span class="line">                             [<span class="built_in">UIColor</span> purpleColor],</span><br><span class="line">                             [<span class="built_in">UIColor</span> redColor]];</span><br><span class="line">    <span class="built_in">NSUInteger</span> colorCount = [arrayColors count];</span><br><span class="line">    <span class="comment">// 循环添加关键帧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; colorCount; i++) &#123;</span><br><span class="line">        [<span class="built_in">UIView</span> addKeyframeWithRelativeStartTime:i / (<span class="built_in">CGFloat</span>)colorCount</span><br><span class="line">                                relativeDuration:<span class="number">1</span> / (<span class="built_in">CGFloat</span>)colorCount</span><br><span class="line">                                      animations:^&#123;</span><br><span class="line">                                          [_graduallyView setBackgroundColor:arrayColors[i]];</span><br><span class="line">                                      &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">[<span class="built_in">UIView</span> animateKeyframesWithDuration:<span class="number">4.0</span></span><br><span class="line">                               delay:<span class="number">0.0</span></span><br><span class="line">                             options:<span class="built_in">UIViewKeyframeAnimationOptionCalculationModeCubic</span> | <span class="built_in">UIViewAnimationOptionCurveLinear</span></span><br><span class="line">                          animations:keyFrameBlock</span><br><span class="line">                          completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">                              <span class="comment">// 动画完成后执行</span></span><br><span class="line">                              <span class="comment">// code...</span></span><br><span class="line">                          &#125;];</span><br></pre></td></tr></table></figure>
<h3 id="五-UIImageView的帧动画"><a href="#五-UIImageView的帧动画" class="headerlink" title="五. UIImageView的帧动画"></a>五. UIImageView的帧动画</h3><p>UIImageView可以让一系列的图片在特定的时间内按顺序显示<br>相关属性解析:</p>
<blockquote>
<p>animationImages：要显示的图片(一个装着UIImage的NSArray)<br>animationDuration：完整地显示一次animationImages中的所有图片所需的时间<br>animationRepeatCount：动画的执行次数(默认为0，代表无限循环)</p>
</blockquote>
<p>相关方法解析:</p>
<blockquote>
<ul>
<li>(void)startAnimating; 开始动画</li>
<li>(void)stopAnimating;  停止动画</li>
<li>(BOOL)isAnimating;  是否正在运行动画</li>
</ul>
</blockquote>
<hr>
<p>动画的一些应用 (不定时更新):<br>…</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 动画 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git简易指南]]></title>
      <url>http://www.lydsnm.top/2015/11/06/Git%E7%AE%80%E6%98%93%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;Git(读音为/gɪt/)是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。[1]  Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。<br>Git算是开发人员必须掌握的一个工具了。很多命令对于初学者来说，比较难记，也容易搅混，所以整理了一下，待以后使用到的时候查阅一下。</p>
<h2 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h2><h3 id="创建新仓库"><a href="#创建新仓库" class="headerlink" title="创建新仓库"></a>创建新仓库</h3><p>创建新文件夹, 打开, 然后执行 <code>git init</code> 以创建新的 <font color="a52a2a">git</font> 仓库</p>
<h3 id="检出仓库"><a href="#检出仓库" class="headerlink" title="检出仓库"></a>检出仓库</h3><p>执行下面的命令以创建一个本地仓库的克隆版本: </p>
<p><code>git clone /path/to/repository</code></p>
<p>如果是远端服务器上的仓库, 你的命令会是这个样子:</p>
<p><code>git clone username@host:/path/to/repository</code></p>
<h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h3><p>你的本地仓库由 git 维护的三棵”树”组成. </p>
<p>第一个是你的 <font color="a52a2a">工作目录</font>, 它持有实际文件;</p>
<p>第二个是 <font color="a52a2a">缓存区(Index)</font> , 它像个缓存区域, 临时保存你的改动; </p>
<p>最后是 <font color="a52a2a">HEAD</font>, 指向你最近一次提交后的结果.</p>
<a id="more"></a>
<h3 id="添加与提交"><a href="#添加与提交" class="headerlink" title="添加与提交"></a>添加与提交</h3><p>你可以计划改动 (把它们添加到缓存区), 使用如下命令:</p>
<p><code>git add &lt;filename&gt;</code></p>
<p><code>git add *</code></p>
<p>这时 git 基本工作流程的第一步; 使用如下命令以实际提交改动:</p>
<p><code>git commit -m &quot;代码提交信息&quot;</code></p>
<p>现在这些代码就提交到了 <font color="a52a2a">HEAD</font> 但没提交到远端仓库.</p>
<h3 id="推送改动"><a href="#推送改动" class="headerlink" title="推送改动"></a>推送改动</h3><p>当改动已经在本地仓库后, 执行下面的命令将改动 push 到远程仓库: </p>
<p><code>git push origin master</code></p>
<p>可以把 <font color="a52a2a">master</font> 换成你想要 push 的任何分支.</p>
<p>如果还没有克隆现有仓库, 并想要将你的仓库连接到某个远程服务器, 使用下面的命令: </p>
<p><code>git remote add origin &lt;server&gt;</code></p>
<p>这样就能将改动推送到所添加的服务器上去了.</p>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>分支是用来隔绝不同模块开发避免相互影响的. 在创建仓库时, <font color="a52a2a">master</font> 是默认的. 可以再其他分支上进心开发, 完成后再将它们合并到住分支上.</p>
<p>创建一个叫做 <font color="a52a2a">feature_a</font> 的分支, 并切换过去:</p>
<p><code>git checkout -b feature_a</code></p>
<p>切换会回主分支:</p>
<p><code>git checkout master</code></p>
<p>再把新建的分支删除: </p>
<p><code>git branch -d feature_a</code></p>
<p>除非将分支推送到远程仓库, 不然该分支就是 <font color="a52a2a"> 别人看不到的 </font> :</p>
<p><code>git push origin &lt;branch&gt;</code></p>
<p>查看远程分支：</p>
<p><code>$ git branch -a</code></p>
<p>查看本地分支：</p>
<p><code>$ git branch</code></p>
<h3 id="更新与合并"><a href="#更新与合并" class="headerlink" title="更新与合并"></a>更新与合并</h3><p>要更新你的本地仓库至最新改动, 执行: </p>
<p><code>git pull</code></p>
<p>以在你的工作目录中 <font color="a52a2a">fetch</font> 并 <font color="a52a2a">merge</font> 远程的改动.</p>
<p>要合并其他分支到你的当前分支 (例如 <font color="a52a2a">master</font> ), 执行:</p>
<p><code>git marge &lt;brance&gt;</code></p>
<p>两种情况下, git 都会尝试区自动合并改动. 然而可能有 冲突. 将这些冲突解决更改后, 需要执行如下命令将它们标记成合并成功:</p>
<p><code>git add &lt;filename&gt;</code></p>
<p>在合并改动之前, 也可以使用如下命令查看: </p>
<p><code>git diff &lt;source_branch&gt; &lt;target_branch&gt;</code></p>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>可以通过以下命令创建一个叫做 <font color="a52a2a">1.0.0</font> 的标签:</p>
<p><code>git tag 1.0.0 1b231d63ff</code></p>
<p><font color="a52a2a"> 1b231d63ff </font> 是你想要标记的提交 ID 的前10位支付. 使用如下命令获取提交 ID:</p>
<p><code>git log</code></p>
<p>也可以少于10位, 只要能保证它是唯一的.</p>
<h3 id="替换本地改动"><a href="#替换本地改动" class="headerlink" title="替换本地改动"></a>替换本地改动</h3><p>如果需要恢复代码到本地. 可以实用如下命令替换掉本地改动:</p>
<p><code>git checkout -- &lt;filename&gt;</code></p>
<p>此命令会实用 <font color="a52a2a">HEAD</font> 中的最新内容替换掉你的工作目录中的文件. 已添加到缓存区的改动, 以及新文件, 都不受影响.</p>
<p>如果想要丢弃本地所有的改动和提交, 可以到服务器上获取最新的版本并将你本地主分支指向它:</p>
<p><code>git fetch origin</code></p>
<p><code>git reset --hard origin/master</code></p>
<h3 id="解决合并冲突："><a href="#解决合并冲突：" class="headerlink" title="解决合并冲突："></a>解决合并冲突：</h3><p><a href="https://www.cnblogs.com/baby123/p/6588378.html" target="_blank" rel="noopener">https://www.cnblogs.com/baby123/p/6588378.html</a></p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>内建的图形化 git:</p>
<p><code>gitk</code></p>
<p>彩色的 git 输出</p>
<p><code>git config color.ui true</code></p>
<p>显示历史记录时, 只显示一行注释信息: </p>
<p><code>git config format.pretty oneline</code></p>
<p>交互地添加文件至缓存区</p>
<p><code>git add -i</code></p>
<hr>
<h2 id="遇到的一些问题"><a href="#遇到的一些问题" class="headerlink" title="遇到的一些问题"></a>遇到的一些问题</h2><h3 id="解决在通过git命令-git-pull-的时候出现Threre-is-no-tracking-information-for-the-current-branch-Please-specify-which-branch-you-want-to-merge-with。"><a href="#解决在通过git命令-git-pull-的时候出现Threre-is-no-tracking-information-for-the-current-branch-Please-specify-which-branch-you-want-to-merge-with。" class="headerlink" title="解决在通过git命令 git pull 的时候出现Threre is no tracking information for the current branch . Please specify which branch you want to merge with。"></a>解决在通过git命令 git pull 的时候出现Threre is no tracking information for the current branch . Please specify which branch you want to merge with。</h3><p> 就是需要指定本地projet分支，跟远程仓库项目分支之间的关系，比如，我们需要本地master对应远程的master<br>是因为本地分支和远程分支没有建立联系 (使用git branch -vv 可以查看本地分支和远程分支的关联关系) .根据命令行提示只需要执行以下命令即可:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git branch --set-upstream-to=origin/远程分支的名字 本地分支的名字</span></span><br><span class="line"></span><br><span class="line">git branch --<span class="built_in">set</span>-upstream-to master origin/master</span><br></pre></td></tr></table></figure>
<p>解决方法来自:<a href="http://blog.csdn.net/tterminator/article/details/78108550" target="_blank" rel="noopener">http://blog.csdn.net/tterminator/article/details/78108550</a></p>
<h3 id="刚刚创建git仓库，遇到问题git-错误-fatal-Not-a-valid-object-name-39-master-39"><a href="#刚刚创建git仓库，遇到问题git-错误-fatal-Not-a-valid-object-name-39-master-39" class="headerlink" title="刚刚创建git仓库，遇到问题git 错误 fatal: Not a valid object name: &#39;master&#39;"></a>刚刚创建git仓库，遇到问题git 错误 <code>fatal: Not a valid object name: &#39;master&#39;</code></h3><p>&emsp;&emsp;刚创建的git仓库默认的master分支要在第一次commit之后才会真正建立，否则就像你声明了个对象但没初始化一样<br>解决办法：先<code>git add</code>。添加所有项目文件到本地仓库缓存，再<code>git commit -m &quot;init commit&quot;</code>提交到本地仓库，之后就可以随心所欲地创建或切换分支了。（这里给出的是可以直接操作成功的，add和commit可以按自己需要写）。</p>
<p>&emsp;&emsp;而当git pull 遇到fatal: refusing to merge unrelated histories</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Objective 4种延时方法简单记录]]></title>
      <url>http://www.lydsnm.top/2015/10/09/%E5%9B%9B%E7%A7%8D%E5%BB%B6%E6%97%B6%E6%89%A7%E8%A1%8C%E6%9F%90%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%8A%E5%85%B6%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>&emsp;OC开发相关注意事项四作为备忘列举了四种延时执行某函数的方法及其一些区别。<br>假如延时1秒时间执行下面的方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)delayMethod &#123; <span class="built_in">NSLog</span>(<span class="string">@"execute"</span>); &#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-performSelector方法"><a href="#1-performSelector方法" class="headerlink" title="1.performSelector方法"></a>1.<code>performSelector</code>方法</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(delayMethod) withObject:<span class="literal">nil</span> afterDelay:<span class="number">1.0</span>f];</span><br></pre></td></tr></table></figure>
<p>此方式要求必须在主线程中执行，否则无效。</p>
<p>是一种非阻塞的执行方式，</p>
<h5 id="2-定时器-NSTimer"><a href="#2-定时器-NSTimer" class="headerlink" title="2.定时器:NSTimer"></a>2.定时器:<code>NSTimer</code></h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span>f target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(delayMethod) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</span><br></pre></td></tr></table></figure>
<p>此方式要求必须在主线程中执行，否则无效。</p>
<p>是一种非阻塞的执行方式，</p>
<p>可以通过NSTimer类的- (void)invalidate;取消执行。</p>
<h5 id="3-sleep方式"><a href="#3-sleep方式" class="headerlink" title="3.sleep方式"></a>3.<code>sleep</code>方式</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1.0</span>f]; </span><br><span class="line">[<span class="keyword">self</span> delayMethod];</span><br></pre></td></tr></table></figure>
<p>此方式在主线程和子线程中均可执行。</p>
<p>是一种阻塞的执行方式，建方放到子线程中，以免卡住界面</p>
<p>没有找到取消执行的方法。</p>
<h5 id="4-GCD方式"><a href="#4-GCD方式" class="headerlink" title="4.GCD方式"></a>4.GCD方式</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> delayInSeconds = <span class="number">1.0</span>; </span><br><span class="line"> __block ViewController* bself = <span class="keyword">self</span>; </span><br><span class="line"> dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line">dispatch_after(popTime, dispatch_get_main_queue(), ^(<span class="keyword">void</span>)&#123; </span><br><span class="line"> [bself delayMethod]; &#125;);</span><br></pre></td></tr></table></figure>
<p>此方式在可以在参数中选择执行的线程。</p>
<p>是一种非阻塞的执行方式，</p>
<p>没有找到取消执行的方法。</p>
]]></content>
      
        <categories>
            
            <category> iOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
