<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>EDI许可证和ICP许可证</title>
      <link href="/2022/03/13/2022-03-13-EDI%E8%AE%B8%E5%8F%AF%E8%AF%81%E5%92%8CICP%E8%AE%B8%E5%8F%AF%E8%AF%81/"/>
      <url>/2022/03/13/2022-03-13-EDI%E8%AE%B8%E5%8F%AF%E8%AF%81%E5%92%8CICP%E8%AE%B8%E5%8F%AF%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h2 id="①-EDI许可证"><a href="#①-EDI许可证" class="headerlink" title="① EDI许可证"></a>① EDI许可证</h2><p>在线数据处理与交易业务，是利用各种与公用通信网相连的数据与交易事务处理应用平台，通过公用通信互联网为用户提供在线数据处理和交易/事物处理的业务牌照，简称EDI证或EDI资质。</p><h3 id="哪些业务需要办理EDI许可证？"><a href="#哪些业务需要办理EDI许可证？" class="headerlink" title="哪些业务需要办理EDI许可证？"></a>哪些业务需要办理EDI许可证？</h3><p>从事网上商城、物联网交易、平台交易、P2P交易的企业需办理<u>在线数据处理</u>与<u>交易处理业务</u>牌照。如淘宝，京东，天猫等。</p><h3 id="EDI许可证办理条件"><a href="#EDI许可证办理条件" class="headerlink" title="EDI许可证办理条件"></a>EDI许可证办理条件</h3><blockquote><p>1.公司注册资金100w以上（EDI外资占比可100%）<br>2.公司名下3名人员近期1个月社保证明<br>3.有可行性研究报告和相关技术方案<br>4.网站域名备案必须在公司名下<br>5.服务器托管要求在本省<br>6.网站搭建必须符合办理EDI许可证</p></blockquote><h2 id="②-ICP经营许可证"><a href="#②-ICP经营许可证" class="headerlink" title="② ICP经营许可证"></a>② ICP经营许可证</h2><p>ICP经营许可证全称—-“增值电信业务经营许可证-信息服务业务（仅限互联网信息服务）”<br>根据中华人民共和国国务院令第291号《中华人民共和国电信条例》、第292号《互联网信息服务管理办法》，国家对提供互联网信息服务的ICP实行许可证制度。从而，ICP证成为网络经营的许可证， <strong>经营性网站必须办理ICP证，否则就属于非法经营</strong>。轻者没收财产并罚款，重者将面临刑事责任。因此，办理ICP证是企业网站合法经营需要。ICP许可证可由各地通信管理部门核发，办理需要根据每个地方相关政策决定。</p><h3 id="哪些企业需要ICP经营许可证"><a href="#哪些企业需要ICP经营许可证" class="headerlink" title="哪些企业需要ICP经营许可证"></a>哪些企业需要ICP经营许可证</h3><p>互联网有偿信息服务，包括在线销售、游戏会员、网站广告、付费新闻、网页制作、在线支付、广告招商、会员收费、企业合作、项目投标等需要办理ICP许可证。</p><p><strong>特别提醒：目前企业涉及小程序上线、微信平台上线、投标、上市等，都必须办理ICP许可证！</strong></p><h2 id="③-EDI证和ICP证区别"><a href="#③-EDI证和ICP证区别" class="headerlink" title="③ EDI证和ICP证区别"></a>③ EDI证和ICP证区别</h2><p>首先，它们都是<u>第二类增值电信业务经营许可证</u>。ICP许可证针对的主要是有偿信息类网站，如<strong>企查查</strong>，<strong>58同城</strong>等。<strong>EDI许可证</strong>主要针对的是<strong>电商类网站</strong>，<strong>有商家入驻的</strong>，如天猫,淘宝，京东等。</p>]]></content>
      
      
      <categories>
          
          <category> 国家政策 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EDI许可证 - ICP许可证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS磁力传感器的应用极简介绍</title>
      <link href="/2020/04/18/2018-10-25-iOS%E7%A3%81%E5%8A%9B%E4%BC%A0%E6%84%9F%E5%99%A8%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8/"/>
      <url>/2020/04/18/2018-10-25-iOS%E7%A3%81%E5%8A%9B%E4%BC%A0%E6%84%9F%E5%99%A8%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<figure><br><img src="http://woolni.oss-cn-chengdu.aliyuncs.com/Blog/ios-ci-li-chuan-gan-qi.png"><br><br></figure><p>有三种获取磁力计数据的方法，如上图所示</p><ol><li><p>Core Motion框架 <code>CMMotionManagers</code>的<code>CMMagnetometer</code>类</p></li><li><p>Core Motion框架 <code>CMDeviceMotion</code>的<code>CMCalibratedMagneticField</code>属性</p></li><li><p>Core Location框架 <code>CLLocationManager</code>的<code>CLHeading</code></p></li></ol><a id="more"></a><h2 id="1-CMMagnetometer"><a href="#1-CMMagnetometer" class="headerlink" title="1.CMMagnetometer"></a>1.CMMagnetometer</h2><p>来自磁力计的原始读数</p><pre><code class="objc"> *  magneticField *   *  Discussion: *    Returns the magnetic field measured by the magnetometer. Note *        that this is the total magnetic field observed by the device which *        is equal to the Earth's geomagnetic field plus bias introduced *        from the device itself and its surroundings. */@property(readonly, nonatomic) CMMagneticField magneticField; </code></pre><h2 id="2-CMDeviceMotion（CMCalibratedMagneticField-）"><a href="#2-CMDeviceMotion（CMCalibratedMagneticField-）" class="headerlink" title="2.CMDeviceMotion（CMCalibratedMagneticField *）"></a>2.CMDeviceMotion（<code>CMCalibratedMagneticField</code> *）</h2><p>磁场磁场 计读数针对器件偏差（板载磁场）进行了校正，没有器件偏差。</p><pre><code class="objc">/* *  magneticField *   *  Discussion: *          Returns the magnetic field vector with respect to the device for devices with a magnetometer. *          Note that this is the total magnetic field in the device's vicinity without device *          bias (Earth's magnetic field plus surrounding fields, without device bias), *          unlike CMMagnetometerData magneticField. */@property(readonly, nonatomic) CMCalibratedMagneticField magneticField NS_AVAILABLE(NA,5_0);</code></pre><p>CMCalibratedMagneticField包括两个字段:field(XYZ轴上的磁场强度)和accuracy(磁场长度的精度)。</p><h2 id="3-CLHeading-x-y-z"><a href="#3-CLHeading-x-y-z" class="headerlink" title="3.CLHeading [x | y | z]"></a>3.CLHeading [x | y | z]</h2><p>针对器件偏置校正磁性计读数并过滤以消除局部外部磁场（通过器件移动检测 - 如果器件随器件移动，忽略它;否则测量）</p><pre><code class="objc">/* *  CLHeading *   *  Discussion: *    Represents a vector pointing to magnetic North constructed from  *    axis component values x, y, and z. An accuracy of the heading  *    calculation is also provided along with timestamp information. *   *  x|y|z *  Discussion: *    Returns a raw value for the geomagnetism measured in the [x|y|z]-axis.</code></pre><p>CLHeading是“ 偏离设备跟踪的磁场线”，而magnetometerData.magneticField是设备观察到的总磁场，等于地球的地磁场加上设备本身及其周围的偏置“ 。</p><p>因此，CLHeading会提供经过滤的值，其中“参照系”是现有的地球磁场。而磁力计数据提供未经过滤的值，参考帧是设备。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code class="objc">#import &lt;CoreMotion/CoreMotion.h&gt;@property (nonatomic, strong) CMMotionManager * motionManager;- (void)viewDidLoad {    [super viewDidLoad];    _motionManager = [[CMMotionManager alloc] init];    // 判断设备是否支持磁强计    if (_motionManager.magnetometerAvailable){        [_motionManager startMagnetometerUpdates];        NSLog(@"该设备支持磁强计");    }else{        NSLog(@"该设备不支持磁强计");    }    // 磁强计 开启    [_motionManager startMagnetometerUpdates];    [self useMagnetometerPush];}// 使用第二种CMDeviceMotion的CMCalibratedMagneticField属性- (void)useMagnetometerPush{    // 设定获取间隔时间    _motionManager.magnetometerUpdateInterval = 0.5;//0.1f;    // 添加线程    NSOperationQueue * queue = [[NSOperationQueue alloc]init];    [_motionManager startDeviceMotionUpdatesUsingReferenceFrame:CMAttitudeReferenceFrameXArbitraryCorrectedZVertical toQueue:queue withHandler:^(CMDeviceMotion * _Nullable motion, NSError * _Nullable error) {        NSLog(@"磁强计X = %.04f 磁强计Y = %.04f 磁强计Z = %.04f   精度:%d",motion.magneticField.field.x,motion.magneticField.field.y,motion.magneticField.field.z, motion.magneticField.accuracy);    }];}// 通过第一种CMMotionManagers的CMMagnetometer类获取原始数据- (void)useMagnetometerPushOriginal{    _motionManager.magnetometerUpdateInterval = 0.5;//0.1f;    NSOperationQueue * queue = [[NSOperationQueue alloc]init];    [_motionManager startMagnetometerUpdatesToQueue:queue withHandler:^(CMMagnetometerData * _Nullable magnetometerData, NSError * _Nullable error) {        NSLog(@"磁强计X = %.04f 磁强计Y = %.04f 磁强计Z = %.04f",magnetometerData.magneticField.x,magnetometerData.magneticField.y,magnetometerData.magneticField.z);    }];}// 第一种的主动获取磁强计数据- (void)useMagnetometerPull{    CMMagnetometerData* magnetometerData = _motionManager.magnetometerData;    NSLog(@"磁强计X = %.04f",magnetometerData.magneticField.x);    NSLog(@"磁强计Y = %.04f",magnetometerData.magneticField.y);    NSLog(@"磁强计Z = %.04f",magnetometerData.magneticField.z);}</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>如果你想知道哪里是磁性或真正北方的位置，推荐使用<code>CLHeading</code>，可以做指南针的一类应用。如果想要创建一个响应紧邻设备磁场的应用，或者想要执行某种特定的传感器融合，可以尝试创建一个AHRS，然后使用<code>CMMagneticField</code>即第二种方式。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 磁力传感器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作中收集的有用工具（持续更新）</title>
      <link href="/2020/04/18/2019-05-22-%E6%94%B6%E9%9B%86%E7%9A%84%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/"/>
      <url>/2020/04/18/2019-05-22-%E6%94%B6%E9%9B%86%E7%9A%84%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>工作中遇到了很多的工具，很多都一股脑门的保存在浏览器书签里了，没事儿翻翻很多还是很有用的。翻出来贴在这儿，说不一定就对你有用了呢。</p><h2 id="网页"><a href="#网页" class="headerlink" title="网页"></a>网页</h2><ul><li><p><a href="https://cssfx.dev/" target="_blank" rel="noopener">Beautifully simple click-to-copy CSS effects</a><br>它提供了一些优雅、酷炫的 CSS 动画效果，让你轻点鼠标便能直接复制样式，非常方便。做 Web 开发的同学可以收藏备用一下。 ​​​​</p></li><li><p><a href="https://chrome.google.com/webstore/detail/沙拉查词-聚合词典划词翻译/cdonnmffkdaoajfknoeeecmchibpmkmg?hl=en" target="_blank" rel="noopener">谷歌浏览器插件——沙拉查词</a><br>很好用的一款浏览器上用的查词插件，因为有了这个，我把有道词典都卸载了。查看英文文档很方便，支持英英翻译、划词等等很多功能，强烈推荐。</p></li></ul><p><img src="https://woolni.oss-cn-chengdu.aliyuncs.com/Blog/沙拉查词预览.png" width="320"></p><a id="more"></a><ul><li><p>在线截图工具<br><a href="https://browserframe.com" target="_blank" rel="noopener">BrowserFrame</a> 和 <a href="https://screen.guru" target="_blank" rel="noopener">Screen Guru</a>，让截的网站截图更具逼格。</p></li><li><p><a href="https://icon.wuruihong.com/" target="_blank" rel="noopener">一张图生成App 所有尺寸Icon</a></p></li></ul><ul><li><a href="https://goalkicker.com/" target="_blank" rel="noopener">🌟🌟🌟开发 Notes pdf下载网盘</a><br>下载来看过，相交于国内的书本质量要好的多，墙裂推荐！！</li></ul><h2 id="翻墙SS账号购买"><a href="#翻墙SS账号购买" class="headerlink" title="翻墙SS账号购买"></a>翻墙SS账号购买</h2><ul><li><a href="https://aity.ga" target="_blank" rel="noopener">Aity</a> 19年1月份买了一年（人民币36元）， 截止到2019-9-21（更新）还能用。看Youtube视频还是能看的，高清的需要缓存下，适合google文档查询使用。</li></ul><h2 id="iOS开发工具等"><a href="#iOS开发工具等" class="headerlink" title="iOS开发工具等"></a>iOS开发工具等</h2><ul><li><p><a href="https://github.com/indragiek/InAppViewDebugger" target="_blank" rel="noopener">视图调试器，可持续关注</a><br>实现了类似 Reveal 的基础调试功能，以树状结构展示 App 视图，并能控制视图的显示隐藏。虽说功能没有 Reveal 强大，但毕竟开源免费，也比 Xcode 自带的鸡肋调试器好用多了</p></li><li><p><a href="http://tool.oschina.net/codeformat/json" target="_blank" rel="noopener">在线代码格式化Json</a><br>复制一串多层结构的json，可以分级看，比较清晰。</p></li></ul><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><ul><li><a href="https://bigjpg.com/" target="_blank" rel="noopener">AI人工智能图片放大</a> 针对一些小而不清晰的图片有奇效</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><a href="https://i18ns.com/zh/index.html" target="_blank" rel="noopener">国际化翻译搜索</a><br>有个 Android 开发者花了两年时间，收集了 1500 多万条 App 的翻译数据， 并做成了一个搜索网站，希望能帮助独立开发者以更低的成本、更高质量的完成 App 国际化工作</li></ul><ul><li><a href="http://www.sohu.com/a/234226326_100112198" target="_blank" rel="noopener">配色网站，让颜色搭配不再难</a></li><li><p><a href="https://tuchong.com/1535376/t/21456512/" target="_blank" rel="noopener">配色App</a></p></li><li><p><a href="https://www.nowcoder.com/contestRoom" target="_blank" rel="noopener">牛客网 开发刷题网盘</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整理App变现方式</title>
      <link href="/2020/04/18/2019-12-03-%E6%95%B4%E7%90%86App%E5%8F%98%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
      <url>/2020/04/18/2019-12-03-%E6%95%B4%E7%90%86App%E5%8F%98%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><del>做App研发也有好多年，好多产品上的内容都是看过一眼就过去了，缺少了整理和规范，导致如果没有产品之类的角色来规范和引导，做很多内容都感觉憋手蹩脚的。开发人员还是要懂一些产品思维，懂一些能够让自己更好发挥实力的其他领域知识内容!</del></p><p><del>App变现的方式不管是公司还是个人做产品，都是需要考虑的内容，好的变现能够一定程度上引导好作品。近来有了这方面的迫切需求，就来归纳整理一下，已知的一些变现方式。大都是平时使用app时慢慢收集的，所以这篇内容会持续不断更新的。</del></p><p>额，啰嗦了点，直接点了 <strong>能在app上变现的方式整理：</strong></p><a id="more"></a><h2 id="变现方式"><a href="#变现方式" class="headerlink" title="变现方式"></a>变现方式</h2><h3 id="一、应用内广告"><a href="#一、应用内广告" class="headerlink" title="一、应用内广告"></a>一、应用内广告</h3><p>广告应该是我们最熟悉的变现方式了。接入各个平台的SDK，按规定带上各类广告，当你的应用足够多用户使用的时候，就能获取一笔不错的广告费用了。</p><h4 id="1-信息流广告"><a href="#1-信息流广告" class="headerlink" title="1. 信息流广告"></a>1. 信息流广告</h4><p>在阅读App的条目中，文章详情页，视频详情页下原生图文及视频广告:</p><figure><br><img src="http://woolni.oss-cn-chengdu.aliyuncs.com/Blog/a714ffe6f04f44a1813201840c11e0a6.png" width="300px/"><br></figure><h4 id="2-插屏广告"><a href="#2-插屏广告" class="headerlink" title="2. 插屏广告"></a>2. 插屏广告</h4><p>开发者针对原生环境进行渲染和展示的插屏广告形式。适用于所有具有弹窗广告的场景：</p><figure><br><img src="http://woolni.oss-cn-chengdu.aliyuncs.com/Blog/1bb488437b3248f3bdad096b523c4f38.png" width="300px/"><br></figure><h4 id="3-沉浸式视频信息流广告"><a href="#3-沉浸式视频信息流广告" class="headerlink" title="3. 沉浸式视频信息流广告"></a>3. 沉浸式视频信息流广告</h4><p>类似抖音视频的竖版视频信息流，与视频产品产品完全融为一体，全屏展示无干扰，广告主信息得以更好地传达，转化率更高</p><figure><br><img src="http://woolni.oss-cn-chengdu.aliyuncs.com/Blog/1daba92eaa4643789a9eb176e04c7457.png" width="300/"><br></figure><h4 id="4-Banner广告"><a href="#4-Banner广告" class="headerlink" title="4. Banner广告"></a>4. Banner广告</h4><p>在 APP 界面顶部、中部或底部出现的静态图、GIF图、文字链，或多帧图片滚动的广告形式，灵活性更好，样式美观，点击率更高，预算收益提升:</p><figure><br><img src="http://woolni.oss-cn-chengdu.aliyuncs.com/Blog/267066307ab94b9baab07e8351a98e7a.png" width="300/"><br></figure><h4 id="5-开屏广告"><a href="#5-开屏广告" class="headerlink" title="5. 开屏广告"></a>5. 开屏广告</h4><p>流量APP开机画面展示的广告，品牌广告主曝光首选，全屏位置可点击，点击率更高，CPM收益更好：</p><figure><br><img src="http://woolni.oss-cn-chengdu.aliyuncs.com/Blog/ca7bacd9ed254713a12d33645c47af94.png" width="300/"><br></figure><h4 id="6-激励视频广告"><a href="#6-激励视频广告" class="headerlink" title="6. 激励视频广告"></a>6. 激励视频广告</h4><p>深度适配流量APP原生模式的15～30秒全屏视频广告，用户可以选择观看视频广告来换取应用或游戏内的奖励：</p><figure><br><img src="http://woolni.oss-cn-chengdu.aliyuncs.com/Blog/f4fbd66798d343db8e242f43c6890b1b.png" width="300/"><br></figure><h4 id="7-全屏视频广告"><a href="#7-全屏视频广告" class="headerlink" title="7. 全屏视频广告"></a>7. 全屏视频广告</h4><p>由广告商提供素材并进行渲染和展示的全屏插屏视频广告形式。</p><figure><br><img src="http://woolni.oss-cn-chengdu.aliyuncs.com/Blog/99edc52b686a4c4b849b75bb8ae16558.png" width="300/"><br></figure><h3 id="二、应用内功能付费"><a href="#二、应用内功能付费" class="headerlink" title="二、应用内功能付费"></a>二、应用内功能付费</h3><h4 id="1-买断式"><a href="#1-买断式" class="headerlink" title="1. 买断式"></a>1. 买断式</h4><p>一次性购买并解锁的app功能，一次性消耗型的购买:</p><figure><br><img src="http://woolni.oss-cn-chengdu.aliyuncs.com/Blog/img4418.png" width="300/"><br></figure><h4 id="2-订阅付费"><a href="#2-订阅付费" class="headerlink" title="2. 订阅付费"></a>2. 订阅付费</h4><p>以提供一定期限内的服务收费，到期后付费服务自动失去。我们熟知的有视频网站VIP会员。这种方式收入就具有持续性，适合功能长期适用，留存高app使用。</p><figure><br><img src="http://woolni.oss-cn-chengdu.aliyuncs.com/Blog/img28d23537c1db1.jpeg" width="300/"><br></figure><h3 id="三、其他方式"><a href="#三、其他方式" class="headerlink" title="三、其他方式"></a>三、其他方式</h3><h4 id="买卖正常App、马甲App"><a href="#买卖正常App、马甲App" class="headerlink" title="买卖正常App、马甲App"></a>买卖正常App、马甲App</h4><p>这个没有实操，据说价格还挺美丽~~待补充了</p><h4 id="做马甲包"><a href="#做马甲包" class="headerlink" title="做马甲包"></a>做马甲包</h4><p>累，且不是长期收益。</p>]]></content>
      
      
      <categories>
          
          <category> 综合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长图控</title>
      <link href="/2020/04/18/2020-01-22-%E9%95%BF%E5%9B%BE%E6%8E%A7/"/>
      <url>/2020/04/18/2020-01-22-%E9%95%BF%E5%9B%BE%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<p><img src="https://feng-bbs-att-1255531212.image.myqcloud.com/2020/03/11/220810s6pk1t3dyopnbitt.png" alt=""></p><p>一个人一条龙完成的App，用了很多新的东西，还挺有成就感的。</p><p>有兴趣的朋友可以下载看看~，设计是UpLabs上找的，图标是阿里巴巴矢量图找的，边写边改，一直没咋宣传。</p><p><strong>长图控</strong> 一款<strong>整理和收纳长图</strong>的小工具：</p><p>长图和截图不同于相册中的风景照片、自拍照片等，它是含有很多信息的。很多时候我们保存了的长图和截图，随着时间的推移我们会遗忘，而长图控的目的就是让你管理好这些图片，充分利用好这些知识和资源。</p><a id="more"></a><p><a href="https://apps.apple.com/cn/app/%E9%95%BF%E5%9B%BE%E6%8E%A7/id1494926397" target="_blank" rel="noopener">长图控链接</a></p>]]></content>
      
      
      <categories>
          
          <category> UI </category>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> App </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dyld Library not loaded @rpath/ iOS 13.3.1</title>
      <link href="/2020/03/17/2020-03-17-dyld-Library-not-loaded/"/>
      <url>/2020/03/17/2020-03-17-dyld-Library-not-loaded/</url>
      
        <content type="html"><![CDATA[<h2 id="真机运行报错-dyld-Library-not-loaded-rpath-iOS-13-3-1"><a href="#真机运行报错-dyld-Library-not-loaded-rpath-iOS-13-3-1" class="headerlink" title="真机运行报错 dyld: Library not loaded: @rpath/ iOS 13.3.1"></a>真机运行报错 dyld: Library not loaded: @rpath/ iOS 13.3.1</h2><p>真机运行报像<strong>dyld: Library not loaded: @rpath/AFNetworking.framework/AFNetworking</strong>等的错误</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>造成这个的根本原因：<strong>真机系统版本升到iOS 13.3.1后，苹果禁止在免费账户上使用外部框架。</strong></p><a id="more"></a><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="1-换用付费了的开发者账号"><a href="#1-换用付费了的开发者账号" class="headerlink" title="1.换用付费了的开发者账号"></a>1.换用付费了的开发者账号</h3><p>对症上面的原因，选用正确的开发者组来调试开发。</p><h3 id="2-使用iOS-13-3及以下版本的真机设备"><a href="#2-使用iOS-13-3及以下版本的真机设备" class="headerlink" title="2.使用iOS 13.3及以下版本的真机设备"></a>2.使用iOS 13.3及以下版本的真机设备</h3><p>降级或者更换设备。</p><h3 id="3-不用use-frameworks"><a href="#3-不用use-frameworks" class="headerlink" title="3.不用use_frameworks!"></a>3.不用<code>use_frameworks!</code></h3><p>将<code>use_frameworks!</code>替换成<code>use_modular_headers!</code>，重新<code>pod install</code>。</p><hr><p>iOS 13.4 beta也没有这个修复，所以预计短时间不能像原来那样使用了。</p><p>如果需要查看更多后续解决方案，请看<a href="[https://stackoverflow.com/questions/60096258/library-not-loaded-rpath-fblpromises-framework-fblpromises-ios-13-3-1](https://stackoverflow.com/questions/60096258/library-not-loaded-rpath-fblpromises-framework-fblpromises-ios-13-3-1">statckoverflow.</a><br>)</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一些UI记录</title>
      <link href="/2020/01/16/2020-01-16-%E4%B8%80%E4%BA%9BUI%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/01/16/2020-01-16-%E4%B8%80%E4%BA%9BUI%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<figure><br><img src="http://woolni.oss-cn-chengdu.aliyuncs.com/UI/Bananza%20Nutrition%20App%20(concept).png" width="70%/"><br></figure><a id="more"></a><figure><br><img src="http://woolni.oss-cn-chengdu.aliyuncs.com/UI/preview_to_do%20list.jpg" width="70%/"><br></figure><p>这个用了下，借用这个设计做了长图控软件。</p><figure><br><img src="http://woolni.oss-cn-chengdu.aliyuncs.com/UI/attachment_to_do.jpg" width="70%/"><br></figure>]]></content>
      
      
      <categories>
          
          <category> UI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS审核问题大记录</title>
      <link href="/2019/12/28/2018-09-26-iOS%E5%AE%A1%E6%A0%B8%E9%97%AE%E9%A2%98%E5%A4%A7%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/12/28/2018-09-26-iOS%E5%AE%A1%E6%A0%B8%E9%97%AE%E9%A2%98%E5%A4%A7%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>作为iOS开发，注定了要与苹果审核做坚苦斗争。这里做一些记录，也没有用，就记录记录。</p><h3 id="2-1-大礼包"><a href="#2-1-大礼包" class="headerlink" title="2.1 大礼包"></a>2.1 大礼包</h3><p>解决方案：<br>这个大礼包在自己排查那几种常见的问题后，没有可以回复解释，有概率通过。</p><a id="more"></a><h3 id="2-3-1-包含未经必要授权的金融交易"><a href="#2-3-1-包含未经必要授权的金融交易" class="headerlink" title="2.3.1 包含未经必要授权的金融交易"></a>2.3.1 包含未经必要授权的金融交易</h3><blockquote><p>Guideline 2.3.1 - Performance</p></blockquote><blockquote><p>We discovered that your app contains hidden features. Attempting to hide features, functionality or content in your app is considered egregious behavior and can lead to removal from the Apple Developer Program.</p></blockquote><blockquote><p>Specifically, your app contains financial transactions without the necessary authorization.</p></blockquote><p>解决方案：<br>如果确定没有涉及到金融交易和隐藏功能，回复解释功能。<br>如果有，在附件文件中附加提交资质证明材料供审核。</p><h3 id="4-2-2"><a href="#4-2-2" class="headerlink" title="4.2.2"></a>4.2.2</h3><blockquote><p>Guideline 4.2.2 - Design - Minimum Functionality</p></blockquote><blockquote><p>We noticed that your app only includes links, images, or content aggregated from the Internet with limited or no native iOS functionality. Although this content may be curated from the web specifically for your users, since it does not sufficiently differ from a mobile web browsing experience, it is not appropriate for the App Store. </p></blockquote><p>解决方案：</p><p>①元数据方面修改方案</p><p>1，谈产品可用性，对于用户的需求点；</p><p>2，描述本产品与App Store其他产品区别，本产品做了哪些细节性优化，或者哪些具体功能的不同性；</p><p>②二进制方面修改方案</p><p>1，添加开关；方法类似于下方；</p><p>2，改功能；可以添加垃圾功能也可以独立开发其他的功能来丰富产品；</p><h2 id="记录一些审核问题分享链接"><a href="#记录一些审核问题分享链接" class="headerlink" title="记录一些审核问题分享链接"></a>记录一些审核问题分享链接</h2><p><a href="https://www.freebuf.com/column/188785.html" target="_blank" rel="noopener">苹果审核一直卡“审核中”怎么办?最新苹果App Store卡审“漏洞”解决教程</a></p><p><a href="https://www.freebuf.com/column/190066.html" target="_blank" rel="noopener">整理这近半年帮客户上架金融期货,彩票,棋牌游戏及其他App等等遇到的审核被拒问题解决方案</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RxJava梳理学习</title>
      <link href="/2019/12/06/2019-08-28-Rxjava%E6%A2%B3%E7%90%86%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/12/06/2019-08-28-Rxjava%E6%A2%B3%E7%90%86%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>Rxjava就是实现<code>异步操作</code>的库。</p><p>RxJava 的优势也是简洁，随着程序逻辑变得越来越复杂，它依然能够保持简洁。</p><p>这篇文章记录一下最核心的内容，不包含更进阶的用法~</p><a id="more"></a><h3 id="1-Observer-Subscriber-：观察者"><a href="#1-Observer-Subscriber-：观察者" class="headerlink" title="1.Observer(Subscriber)：观察者"></a>1.Observer(Subscriber)：观察者</h3><p>Observer 决定事件触发的时候将有怎样的行为。<br>RxJava 中的 Observer 接口的实现方式:</p><pre><code class="java">Observer&lt;String&gt; observer = new Observer&lt;String&gt;() {    @Override    public void onNext(String s) {        Log.d(tag, "Item: " + s);    }    @Override    public void onCompleted() {        Log.d(tag, "Completed!");    }    @Override    public void onError(Throwable e) {        Log.d(tag, "Error!");    }};</code></pre><p>除了 Observer 接口之外，RxJava 还内置了一个实现了 Observer 的抽象类：<code>Subscriber</code>。</p><p><code>onStart()</code>: 这是 <code>Subscriber</code> 增加的方法，它会在 subscribe 刚开始，而事件还未发送之前被调用，用来做一些准备工作，但是！！！这个不适用于显示进度条等UI线程操作</p><p><code>unsubscribe()</code>: 这是 Subscriber 所实现的另一个接口 Subscription 的方法，用于取消订阅。在这个方法被调用后，Subscriber 将不再接收事件。一般在这个方法调用前，可以使用 <code>isUnsubscribed()</code> 先判断一下状态。 unsubscribe() 这个方法很重要，因为在 subscribe() 之后， Observable 会持有 Subscriber 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 <code>onPause()</code> <code>onStop()</code> 等方法中）调用 unsubscribe() 来解除引用关系，以避免内存泄露的发生。</p><h3 id="2-Observable-可观察者即被观察者"><a href="#2-Observable-可观察者即被观察者" class="headerlink" title="2.Observable:可观察者即被观察者"></a>2.Observable:可观察者即被观察者</h3><p>创建被观察者，并定义事件触发规则。</p><pre><code class="java">Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() {    @Override    public void call(Subscriber&lt;? super String&gt; subscriber) {        subscriber.onNext("Hello");        subscriber.onNext("Hi");        subscriber.onNext("Aloha");        subscriber.onCompleted();    }});</code></pre><p><code>OnSubscribe</code> 会被存储在返回的 <code>Observable</code> 对象中，它的作用相当于一个计划表，当 Observable 被订阅的时候，OnSubscribe 的 call() 方法会自动被调用。这种模式就是观察者模式。</p><p><code>create()</code> 方法是 RxJava 最基本的创造事件序列的方法。基于这个方法， RxJava 还提供了一些方法用来快捷创建事件队列，例如<code>just(T...)</code>、<code>from(T[]) / from(Iterable&lt;? extends T&gt;) :</code></p><h3 id="3-Subscribe-订阅"><a href="#3-Subscribe-订阅" class="headerlink" title="3.Subscribe (订阅):"></a>3.Subscribe (订阅):</h3><p>建立订阅关系，由可观察者调用。</p><pre><code class="java">observable.subscribe(observer);// 或者：observable.subscribe(subscriber);</code></pre><h3 id="4-线程控制-——-Scheduler"><a href="#4-线程控制-——-Scheduler" class="headerlink" title="4.线程控制 —— Scheduler"></a>4.线程控制 —— Scheduler</h3><p>观察者模式本身的目的就是『后台处理，前台回调』的异步机制，而实现异步就需要Scheduler了。</p><p>在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用 subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 Scheduler （调度器）。</p><p>在RxJava 中，Scheduler ——调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。Android中常用的Scheduler有两个（有更多的，请看原始网站链接。）：</p><blockquote><p>Schedulers.io():I/O 操作,耗时的线程<br>AndroidSchedulers.mainThread()：主线程</p></blockquote><p><code>subscribeOn()</code>: <strong>指定 subscribe() 所发生的线程</strong>，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。<br><code>observeOn()</code>: <strong>指定 Subscriber 所运行在的线程</strong>。或者叫做事件消费的线程。</p><pre><code class="java">Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() {    @Override    public void call(Subscriber&lt;? super String&gt; subscriber) {//这里在IO线程操作        subscriber.onNext("Hello");        subscriber.onNext("Hi");        subscriber.onNext("Aloha");        subscriber.onCompleted();    }}).subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程.observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程.subscribe(new Action1&lt;Integer&gt;() {        @Override        public void call(Integer number) {//回调到主线程，进行UI操作            Log.d(tag, "number:" + number);        }    });</code></pre><p>事实上，这种在 <strong>subscribe()</strong> 之前写上两句 <strong>subscribeOn(Scheduler.io())</strong> 和 <strong>observeOn(AndroidSchedulers.mainThread())</strong> 的使用方式非常常见，它适用于多数的 『后台线程取数据，主线程显示』的程序策略。</p><h3 id="5-转换"><a href="#5-转换" class="headerlink" title="5.转换"></a>5.转换</h3><p>RxJava 提供了对事件序列进行变换的支持，这是它的核心功能之一，也是大多数人说『RxJava 真是太好用了』的最大原因。<strong>所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列</strong>。</p><p>一个map()的例子：</p><pre><code class="java">Observable.just("images/logo.png") // 输入类型 String    .map(new Func1&lt;String, Bitmap&gt;() {        @Override        public Bitmap call(String filePath) { // 参数类型 String            return getBitmapFromPath(filePath); // 返回类型 Bitmap        }    })    .subscribe(new Action1&lt;Bitmap&gt;() {        @Override        public void call(Bitmap bitmap) { // 参数类型 Bitmap            showBitmap(bitmap);        }    });</code></pre><p><strong>Func1</strong> 是Rxjava的一个接口，用于包装含有一个参数的方法，且有返回值。（<strong>Action0</strong> 和 <strong>Action1</strong> 对应的就是无返回值的）。而 <strong>FuncX</strong> 就是多个不同参数的方法。</p><p>可以看到，map() 方法将参数中的 String 对象转换成一个 Bitmap 对象后返回，而在经过 map() 方法后，事件的参数类型也由 String 转为了 Bitmap。这种直接变换对象并返回的，是最常见的也最容易理解的变换。不过 RxJava 的变换远不止这样，它不仅可以针对事件对象，还可以针对整个事件队列，这使得 RxJava 变得非常灵活。</p><h3 id="6-线程控制（二）Scheduler"><a href="#6-线程控制（二）Scheduler" class="headerlink" title="6.线程控制（二）Scheduler"></a>6.线程控制（二）Scheduler</h3><p>除了灵活的变换，RxJava 另一个牛逼的地方，就是线程的自由控制。</p><p>前面讲到了，可以利用 subscribeOn() 结合 observeOn() 来实现线程控制，让事件的产生和消费发生在不同的线程。可是在了解了 map() flatMap() 等变换方法后，有些好事的（其实就是当初刚接触 RxJava 时的我）就问了：能不能多切换几次线程？</p><p>答案是：能。因为 observeOn() 指定的是 Subscriber 的线程，而这个 Subscriber 并不是（严格说应该为『不一定是』，但这里不妨理解为『不是』）subscribe() 参数中的 Subscriber ，而是 observeOn() 执行时的当前 Observable 所对应的 Subscriber ，即它的直接下级 Subscriber 。换句话说，observeOn() 指定的是它之后的操作所在的线程。因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次 observeOn() 即可。上代码：</p><pre><code class="java">Observable.just(1, 2, 3, 4) // IO 线程，由 subscribeOn() 指定    .subscribeOn(Schedulers.io())    .observeOn(Schedulers.newThread())    .map(mapOperator) // 新线程，由 observeOn() 指定    .observeOn(Schedulers.io())    .map(mapOperator2) // IO 线程，由 observeOn() 指定    .observeOn(AndroidSchedulers.mainThread)     .subscribe(subscriber);  // Android 主线程，由 observeOn() 指定</code></pre><p>如上，通过 observeOn() 的多次调用，程序实现了线程的多次切换。<br>不过，不同于 observeOn() ， subscribeOn() 的位置放在哪里都可以，但它是只能调用一次的。</p><h3 id="7-参考理解例子"><a href="#7-参考理解例子" class="headerlink" title="7.参考理解例子"></a>7.参考理解例子</h3><h4 id="与Retrofit的结合"><a href="#与Retrofit的结合" class="headerlink" title="与Retrofit的结合"></a>与Retrofit的结合</h4><p>Retrofit传统方式定义API</p><pre><code class="java">@GET("/user")public void getUser(@Query("userId") String userId, Callback&lt;User&gt; callback);</code></pre><p>在程序的构建过程中， Retrofit 会把自动把方法实现并生成代码，然后开发者就可以利用下面的方法来获取特定用户并处理响应：</p><pre><code class="java">getUser(userId, new Callback&lt;User&gt;() {    @Override    public void success(User user) {        userView.setUser(user);    }    @Override    public void failure(RetrofitError error) {        // Error handling        ...    }};</code></pre><p>而使用 RxJava 形式的 API，定义同样的请求是这样的：</p><pre><code class="java">@GET("/user")public Observable&lt;User&gt; getUser(@Query("userId") String userId);</code></pre><p>使用时是这样的：</p><pre><code class="java">getUser(userId)    .observeOn(AndroidSchedulers.mainThread())    .subscribe(new Observer&lt;User&gt;() {        @Override        public void onNext(User user) {            userView.setUser(user);        }        @Override        public void onCompleted() {        }        @Override        public void onError(Throwable error) {            // Error handling            ...        }    });</code></pre><h4 id="不使用Retrofit来请求并更新数据库"><a href="#不使用Retrofit来请求并更新数据库" class="headerlink" title="不使用Retrofit来请求并更新数据库"></a>不使用Retrofit来请求并更新数据库</h4><pre><code class="java">getUser(userId, new Callback&lt;User&gt;() {    @Override    public void success(User user) {        new Thread() {            @Override            public void run() {                processUser(user); // 尝试修正 User 数据                runOnUiThread(new Runnable() { // 切回 UI 线程                    @Override                    public void run() {                        userView.setUser(user);                    }                });            }).start();    }    @Override    public void failure(RetrofitError error) {        // Error handling        ...    }};</code></pre><h4 id="使用RxJava来实现同样更新数据库的功能"><a href="#使用RxJava来实现同样更新数据库的功能" class="headerlink" title="使用RxJava来实现同样更新数据库的功能"></a>使用RxJava来实现同样更新数据库的功能</h4><pre><code class="java">getUser(userId)    .doOnNext(new Action1&lt;User&gt;() {        @Override        public void call(User user) {            processUser(user);        })    .observeOn(AndroidSchedulers.mainThread())    .subscribe(new Observer&lt;User&gt;() {        @Override        public void onNext(User user) {            userView.setUser(user);        }        @Override        public void onCompleted() {        }        @Override        public void onError(Throwable error) {            // Error handling            ...        }    });</code></pre><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>更多详细的请看大佬的文章<a href="https://gank.io/post/560e15be2dca930e00da1083#toc_25" target="_blank" rel="noopener">给 Android 开发者的 RxJava 详解</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android开发过程的中概念点梳理</title>
      <link href="/2019/12/03/2019-08-19-Android%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E7%9A%84%E4%B8%AD%E6%A6%82%E5%BF%B5%E7%82%B9/"/>
      <url>/2019/12/03/2019-08-19-Android%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E7%9A%84%E4%B8%AD%E6%A6%82%E5%BF%B5%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>太南了，因一些需求，需要开始学习 Android 开发😭，这篇文章来记录一些基础概念。<br>后续持续添加，防止遗忘也能偶尔翻来看看~</p><a id="more"></a><ul><li>EventBus和RxJava的区别</li></ul><p>EventBus是一个<strong>发布 / 订阅的事件总线</strong>。简单点说，就是两人约定好怎么通信，一人发布消息，另外一个约定好的人立马接收到你发的消息。<br>Rx：<strong>函数响应式编程</strong> ，响应式代码的基本组成部分是Observables和Subscribers（事实上Observer才是最小的构建块，但实践中使用最多的是Subscriber，因为Subscriber才是和Observables的对应的。）。Observable发送消息，而Subscriber则用于消费消息。</p><p>主要区别是，rx里面当建立起订阅关系时，你可以用操作符做任何处理（比如转换数据，更改数据等等），而且他能处理异步的操作。 eventbus 就相当于广播，发送了，总能接收到，他在发送后是不能做任何的数据改变，如果要改变，又要重新post一次。</p><p>EventBus有个缺点就是凡是使用了EventBus的类都不能进行混淆了，否则Evnetbus就找不到OnEvent方法了。</p><ul><li>synchronized</li></ul><p>使用synchronized修饰代码块时，每个类又且仅有一个锁（针对静态方法），每个类的示例也是有且仅有一个锁。</p><p>synchronized具有有两种使用方法，第一种是修饰方法，第二种修饰代码块。无论哪种方法，被修饰的内容都会同步执行。这也是synchronized的作用。关于两种方法的使用：对于修饰方法常常会发生不必要的代码块被同步，同时锁不可以选择，但是使用简单。对于修饰代码块方法用起来更精确，需要自己制定锁，用起来稍微麻烦一点。</p><hr><p>更多内容在个人笔记里，比较凌乱，大都是备忘记录的基础知识，或许有一天能够整理好格式，然后发布出来吧😂。</p><p>这篇就到这里了。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS应用审核通过，但是内购项目一直处于正在审核中</title>
      <link href="/2019/09/25/2018-07-03%E5%BA%94%E7%94%A8%E5%AE%A1%E6%A0%B8%E9%80%9A%E8%BF%87%EF%BC%8C%E4%BD%86%E6%98%AF%E5%86%85%E8%B4%AD%E9%A1%B9%E7%9B%AE%E4%B8%80%E7%9B%B4%E5%A4%84%E4%BA%8E%E6%AD%A3%E5%9C%A8%E5%AE%A1%E6%A0%B8%E4%B8%AD/"/>
      <url>/2019/09/25/2018-07-03%E5%BA%94%E7%94%A8%E5%AE%A1%E6%A0%B8%E9%80%9A%E8%BF%87%EF%BC%8C%E4%BD%86%E6%98%AF%E5%86%85%E8%B4%AD%E9%A1%B9%E7%9B%AE%E4%B8%80%E7%9B%B4%E5%A4%84%E4%BA%8E%E6%AD%A3%E5%9C%A8%E5%AE%A1%E6%A0%B8%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<p>近期应用上架会员功能，新增了几个内购项目，按部就班，应用测试通过后，提交应用商店审核。自信的勾选上审核通过后自动发布，可是应用通过审核并自动释放了，内购项目没有通过，导致线上用户版本，点击购买会员获取不到商品信息，没有任何反应，特难受。现在记录一下我的解决过程，希望对其他有遇到这个问题的朋友有所帮助。</p><p>尝试过重新修改下判断没有商店信息给出提醒，按照一些网友的解决方法：重新提交一个新版本审核，并改成了手动发布。然而事实告诉我，这样并没有用。审核员再次遗漏了我的内购项目。无奈之下，尝试了邮件申诉反馈。</p><a id="more"></a><p>附：</p><blockquote><p><a href="https://developer.apple.com/" target="_blank" rel="noopener">https://developer.apple.com/</a> -&gt; Contact Us -&gt; App Review -&gt; Other App Review questions -&gt; I would like to <strong>get the status of my app</strong>。</p></blockquote><p>这是我的选择步骤。</p><p>第二天，早上8点多邮件有通知，内购通过了，线上版本不用更新可以直接用了（PS：服务器同步要时间，等到下午的时候，会员才可以正常购买）。</p><h2 id="结语："><a href="#结语：" class="headerlink" title="结语："></a>结语：</h2><p>如果一个版本有新增的内购项，那么这个版本还是改成<code>手动释放</code>比较好。点击发布前要检查你的内购项是否是处于<code>已批准</code>状态。如果发现应用通过后，内购审核没有红点（也就说没有按要求填写而打回）处于正在审核中，请联系苹果客服，不要重新发包了，至少我这里的经验是这样的。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS私有API检测系统中是否安装了某款指定的软件</title>
      <link href="/2019/09/25/2018-06-25%E7%A7%81%E6%9C%89API%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E4%BA%86%E6%9F%90%E6%AC%BE%E6%8C%87%E5%AE%9A%E7%9A%84%E8%BD%AF%E4%BB%B6/"/>
      <url>/2019/09/25/2018-06-25%E7%A7%81%E6%9C%89API%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E4%BA%86%E6%9F%90%E6%AC%BE%E6%8C%87%E5%AE%9A%E7%9A%84%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>前段时间，在一个积分任务墙的项目，需要跳转到市场去安装App，需要检测iOS设备已安装应用列表的需求，要能获取到安装情况（包括安装进度啊，完成回调等）。经过一段时间的了解，还算完成了既定任务。这篇记录下使用和尝试过程。</p><a id="more"></a><h2 id="一、URL-Scheme"><a href="#一、URL-Scheme" class="headerlink" title="一、URL Scheme"></a>一、URL Scheme</h2><p>前期考虑过 <strong>URL Scheme </strong>来判断是否安装了某个应用，但是每个app是否设置了URL scheme不知道，而且iOS9上的这个方法能判断的上限是50个，</p><pre><code>[[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:url]]</code></pre><p>因此这个实际情况下无法使用。但是我们可能在其他场景下使用到URL Scheme(比如打开系统应用)，可以下面的方法列出所有的URL Scheme，但是哪个scheme是哪个应用就得靠猜了，一个应用也可能有多个URL Scheme。</p><pre><code class="objc">- (NSArray*)privateURLSchemes{    return [_workspace privateURLSchemes];}- (NSArray*)publicURLSchemes{    return [_workspace publicURLSchemes];}</code></pre><h2 id="二、获取系统中安装列表和各应用的bundleId。"><a href="#二、获取系统中安装列表和各应用的bundleId。" class="headerlink" title="二、获取系统中安装列表和各应用的bundleId。"></a>二、获取系统中安装列表和各应用的bundleId。</h2><pre><code class="objc"> Class LSApplicationWorkspace_class = objc_getClass("LSApplicationWorkspace");   SEL selector=NSSelectorFromString(@"defaultWorkspace");   NSObject* workspace = [LSApplicationWorkspace_class performSelector:selector];   _workspace = workspace</code></pre><pre><code class="objc">#include &lt;objc/runtime.h&gt;   SEL selectorALL = NSSelectorFromString(@"allApplications");   NSArray *apps = [_workspace performSelector:selectorALL]; NSLog(@"apps: %@", );   [apps[0] performSelector:NSSelectorFromString(@"applicationIdentifier")];//shortVersionString等。</code></pre><p>其余一些方法可以去这儿<a href="https://github.com/nst/iOS-Runtime-Headers/blob/master/Frameworks/MobileCoreServices.framework/LSApplicationProxy.h" target="_blank" rel="noopener">查看</a></p><p>关于LSApplicationWorkspace的使用可以查看<a href="https://www.jianshu.com/p/b8d882069197" target="_blank" rel="noopener">iOS私有方法LSApplicationWorkspace.h的一些使用</a></p><h2 id="三、通过定时器不断的调度-可以用下面的方法得到-所有正在下载的app"><a href="#三、通过定时器不断的调度-可以用下面的方法得到-所有正在下载的app" class="headerlink" title="三、通过定时器不断的调度 可以用下面的方法得到 所有正在下载的app"></a>三、通过定时器不断的调度 可以用下面的方法得到 所有正在下载的app</h2><pre><code class="objc">/** 通过定时器不断调用来获取系统中所有正在下载的内容及进度。*/- (IBAction)TimerUpdateToGetDownloadProgress:(id)sender {    void *lib = dlopen("/System/Library/Frameworks/MobileCoreServices.framework/MobileCoreServices", RTLD_LAZY);    if (lib){        Class LSApplicationWorkspace = NSClassFromString(@"LSApplicationWorkspace");        id AAURLConfiguration1 = [LSApplicationWorkspace performSelector:@selector(defaultWorkspace)];        if (AAURLConfiguration1){            id arrApp = [AAURLConfiguration1 performSelector:@selector(allApplications)];            for (int i=0; i&lt;[arrApp count]; i++) {                id LSApplicationProxy = [arrApp objectAtIndex:i];                NSString* bundleId =[LSApplicationProxy performSelector:@selector(applicationIdentifier)];                NSString* name = [LSApplicationProxy localizedName];                NSProgress *progress = (NSProgress *)[LSApplicationProxy performSelector:@selector(installProgress)];                NSLog(@"current progress:%lf bundleId:%@", [NSProgress currentProgress], bundleId);                // 正在安装的模型数据//                InstallingModel *model = [self getInstallModel:bundleId];                //如果是正在下载状态                if (progress){                    //已经检测到的//                    if (model) {//                        model.progress = [progress localizedDescription];//                        model.status  =  [NSString stringWithFormat:@"%@",[[progress userInfo] valueForKey:@"installState"]];                        //第一次检测到的//                    }else{//                        InstallingModel *model = [[InstallingModel alloc] init];//                        model.appName = name;//                        model.bundleID = bundleId;//                        model.progress = [progress localizedDescription];//                        model.status  = [NSString stringWithFormat:@"%@",[[progress userInfo] valueForKey:@"installState"]];////                        [_installedAry addObject:model];//                    }                }            }        }        if (lib) dlclose(lib);    }}</code></pre><h2 id="四、通过bundle-id判断是否安装并打开app"><a href="#四、通过bundle-id判断是否安装并打开app" class="headerlink" title="四、通过bundle id判断是否安装并打开app"></a>四、通过bundle id判断是否安装并打开app</h2><pre><code class="objc">//通过applicationIdentifier id。判断是否安装某个APP        BOOL isInstall = [workspace performSelector:@selector(applicationIsInstalled:) withObject:@"com.tencent.xin"];        if (isInstall) {            //通过bundle id打开APP            [workspace performSelector:@selector(openApplicationWithBundleID:) withObject:@"com.tencent.xin"];        }else{            NSLog(@"您还没安装");        }</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上一些方法大都使用到了私有API、故切记要上架到app store的应用不要使用。<br>在了解过程中，一并完成了一个测试demo，有需要的可以在此基础上试验。<br><a href="https://github.com/donglyu/CheckInstalledAppEtcIniOS" target="_blank" rel="noopener">Demo地址</a></p><p>- EOF -</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS面试问题实记</title>
      <link href="/2018/12/09/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%AE%9E%E8%AE%B0/"/>
      <url>/2018/12/09/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%AE%9E%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>整理一下这期iOS面试部分问题点，记录一下，时刻督促自己，保持警惕~</p><a id="more"></a><h3 id="layer层，还有哪些layer子类，有些什么作用。"><a href="#layer层，还有哪些layer子类，有些什么作用。" class="headerlink" title="layer层，还有哪些layer子类，有些什么作用。"></a>layer层，还有哪些layer子类，有些什么作用。</h3><blockquote><ul><li>CATextLayer（CALayer的一个子类，专门用来显示文字）</li><li>CAGradientLayer(渐变图层）</li><li>CAShapeLayer（波浪）</li><li>CATiledLayer（专为加载超大图.eg:地图资源）</li><li>CATransformLayer（3D变换、3D动画）</li><li>CAGradientLayer （渐变色Layer）</li><li>CAReplicatorLayer （<a href="https://www.cnblogs.com/xianfeng-zhang/p/7759919.html" target="_blank" rel="noopener">复制图层（多个相同图层组合起来动画）</a>）</li><li>CAScrollLayer  （滚动图层：for scrollView负责显示）</li><li>CAEmitterLayer （粒子发生器系统。用来创建实时的粒子动画：烟雾，火，雨，雪等。）</li><li>CAEAGLLayer （用来显示任意的OpenGL图形。OpenGL由近350个不同的函数调用组成，用来从简单的图元绘制复杂的三维景象，主要用途是CAD、科学可视化程序、虚拟现实、游戏程序设计。）</li><li>AVPlayerLayer （视频图层：本地网络视频播放AVPlayer）</li><li>CATextLayer使用CoreText进行绘制，渲染速度比使用WebKit的UILabel快很多。而且UILabel主要是管理内容，CATextLayer则是绘制内容、渲染文本。</li></ul></blockquote><h3 id="锁，常用的有哪些，优缺点对比呢"><a href="#锁，常用的有哪些，优缺点对比呢" class="headerlink" title="锁，常用的有哪些，优缺点对比呢"></a>锁，常用的有哪些，优缺点对比呢</h3><ul><li>先说几个概念：</li></ul><p><strong>临界区：</strong>指的是一块对公共资源进行访问的代码，并非一种机制或是算法。</p><p><strong>自旋锁：</strong>是用于多线程同步的一种锁，线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。 自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。</p><p><strong>互斥锁（Mutex）：</strong>是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。该目的通过将代码切片成一个一个的临界区而达成。</p><p><strong>读写锁：</strong>是计算机程序的并发控制的一种同步机制，也称“共享-互斥锁”、多读者-单写者锁) 用于解决多线程对公共资源读写问题。读操作可并发重入，写操作是互斥的。 读写锁通常用互斥锁、条件变量、信号量实现。</p><p><strong>信号量（semaphore）：</strong>是一种更高级的同步机制，互斥锁可以说是semaphore在仅取值0/1时的特例。信号量可以有更多的取值空间，用来实现更加复杂的同步，而不单单是线程间互斥。</p><ul><li>几种常用的锁介绍：<a href="https://blog.csdn.net/banbaodevelop/article/details/79279221" target="_blank" rel="noopener">https://blog.csdn.net/banbaodevelop/article/details/79279221</a></li></ul><p><strong>条件锁：</strong>就是条件变量，当进程的某些资源要求不满足时就进入休眠，也就是锁住了。当资源被分配到了，条件锁打开，进程继续运行。</p><p><strong>@synchronized</strong> 关键字加锁 互斥锁，性能较差不推荐使用</p><p><strong>NSLock：</strong>是Foundation以对象形式暴露的锁，NSLock 互斥锁 不能多次调用 lock方法,会造成死锁。定义了lock和unlock方法<br><strong>NSConditionLock</strong> 条件锁:一个线程获得了锁，其它线程等待。</p><p><strong>pthread_mutex：</strong>C语言</p><p><strong>dispatch_semaphore</strong> 信号量实现加锁<br>GCD中也已经提供了一种信号机制，使用它我们也可以来构建一把”锁”(从本质意义上讲，信号量与锁是有区别。)</p><h3 id="试用信号量来资源控制的性能，为什么有些时候不好"><a href="#试用信号量来资源控制的性能，为什么有些时候不好" class="headerlink" title="试用信号量来资源控制的性能，为什么有些时候不好"></a>试用信号量来资源控制的性能，为什么有些时候不好</h3><p>dispatch_semaphore</p><p>现在也是不太清楚[ಥ_ಥ]</p><h3 id="夜间模式的实现方式"><a href="#夜间模式的实现方式" class="headerlink" title="夜间模式的实现方式"></a>夜间模式的实现方式</h3><p>night_updateColor通知，运行时分类加属性。使用<a href="https://github.com/Draveness/DKNightVersion" target="_blank" rel="noopener">参考DKNightVersion</a>深化一下记忆。</p><h3 id="Cell的优化思路有哪些"><a href="#Cell的优化思路有哪些" class="headerlink" title="Cell的优化思路有哪些"></a>Cell的优化思路有哪些</h3><p><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/</a><br>优化一般有两个方向的原因：cpu消耗和gpu消耗。</p><ul><li>1.CPU消耗</li></ul><p><strong>对象创建：</strong> 对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。layer层轻量一些。</p><p><strong>对象调整：</strong>对象的调整也经常是消耗 CPU 资源的地方。比如layer，其实内部临时会创建方法。图层调整时，UIView和layer之间会出现很多的方法调用和通知。</p><p><strong>对象销毁：</strong>布局计算，后台线程提前计算好布局，并对布局缓存</p><p><strong>Autolayout：</strong> 复杂布局会有严重的性能问题。手动计算frame，或者用AsyncDisplayKit框架。来处理界面的问题</p><p><strong>文本计算：</strong>如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：用 <strong>[NSAttributedString boundingRectWithSize:options:context:]</strong> 来计算文本宽高，用<br><strong>-[NSAttributedString drawWithRect:options:context:] </strong>来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。</p><p>如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象，然后自己计算了，并且 CoreText 对象还能保留以供稍后绘制使用。</p><p><strong>文本渲染</strong></p><p><strong>图片加载和渲染</strong>：图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。</p><ul><li>2.GPU资源消耗</li></ul><p><strong>纹理的渲染：</strong>尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。<br><strong>视图的混合：</strong>应用应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示。</p><p><strong>图形的生成：</strong>CALayer 的 border、圆角、阴影、遮罩（mask），<code>CASharpLayer</code> 的矢量图形显示，通常会触发<code>离屏渲染</code>（offscreen rendering），而离屏渲染通常发生在 GPU 中。当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 <code>CALayer.shouldRasterize</code> 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。<br>最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。</p><p>以上来自：<a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS保持界面流程的技巧</a> 可以看看。</p><h3 id="断点续传的思想"><a href="#断点续传的思想" class="headerlink" title="断点续传的思想"></a>断点续传的思想</h3><p><a href="https://www.jianshu.com/p/0e6deea7de87" target="_blank" rel="noopener">iOS实现断点续传</a><br>这个偏原理剖析一点，只实现了单个任务下载。</p><p>NSURLSessionDataTask，按字节写入。</p><p>要实现断点续传的功能，通常都需要客户端记录下当前的下载进度，并在需要续传的时候通知服务端本次需要下载的内容片段。<br>修改http头部 content-length（示被下载文件的字节数）</p><p>请求时：</p><pre><code class="objc">// 设置请求头// Range : bytes=xxx-xxx，从已经下载的长度开始到文件总长度的最后都要下载NSString *range = [NSString stringWithFormat:@"bytes=%zd-",  DownloadLength];[request setValue:range forHTTPHeaderField:@"Range"];</code></pre><p>另外AFNetworking中也有对断点续传的实现。分别通过AFURLSessionManager的<strong>downloadTaskWithRequest…</strong>和<strong>downloadTaskWithResumeData…</strong></p><p>这里遇到了一个情况，网上看的内容基本都是底层剖析，用原生从零开始实现，而面试官交流后的感觉是想了解断点虚传的实现，问的内容较偏实现一点。</p><p>如果使用的是AFnetworking库，可以使用其自带的断点虚传功能。</p><h3 id="Coretext"><a href="#Coretext" class="headerlink" title="Coretext"></a>Coretext</h3><p><a href="https://www.cnblogs.com/purple-sweet-pottoes/p/5109413.html" target="_blank" rel="noopener">Coretext 原理和简单使用</a></p><p> Core Text是和Core Graphics配合使用的，一般是在UIView的drawRect方法中的Graphics Context上进行绘制的。 且Core Text真正负责绘制的是文本部分，图片还是需要自己去手动绘制，所以你必须关注很多绘制的细节部分。<br> Core Text是用来进行文字精细排版的。<br> 参考<a href="https://yq.aliyun.com/articles/35907?spm=5176.100240.searchblog.12.TGPd0O" target="_blank" rel="noopener">CoreText 入门</a></p><p> iOS UIKit的UIView的坐标系原点在左上角。<br>往底层看，Core Graphics的context使用的坐标系的原点是在左下角。而在iOS中的底层界面绘制就是通过Core Graphics进行的，那么坐标系列是如何变换的呢？ 在UIView的drawRect方法中我们可以通过UIGraphicsGetCurrentContext()来获得当前的Graphics Context。drawRect方法在被调用前，这个Graphics Context被创建和配置好，你只管使用便是。</p><p>Core Text一开始便是定位于桌面的排版系统，使用了传统的原点在左下角的坐标系，所以它在绘制文本的时候都是参照左下角的原点进行绘制的。</p><p>说起coreText就要说说开源框架 <strong>YYLabel</strong> 。这也是一个学习方向。我的感觉就是如果要实现一些自定义的文字排版，或者特殊图文排版，就得从 Core Text 下手了。</p><ul><li>YYLabel</li></ul><p>简要介绍：YYLabel 直接继承 UIView，作者自己实现 Label 的渲染。可以做一些图文混排的开发。<code>UIGraphicsBeginImageContextWithOptions</code>。<br> 分为普通渲染和异步渲染。异步：通过后台线程渲染图片。</p><h3 id="OC的多线程开发。"><a href="#OC的多线程开发。" class="headerlink" title="OC的多线程开发。"></a>OC的多线程开发。</h3><p><a href="https://www.jianshu.com/p/2d57c72016c6" target="_blank" rel="noopener">GCD全解</a></p><p>串行（每次只有一个任务被执行。让任务一个接着一个地执行。（只开启一个线程，一个任务执行完毕后，再执行下一个任务））、并行队列。</p><p>GCD 队列组：dispatch_group<br>等等。没有什么多说的，做iOS开发必备技能，一些原理性的东西还是能表达出来更好。</p><h3 id="套接字编程（Socket）"><a href="#套接字编程（Socket）" class="headerlink" title="套接字编程（Socket）"></a>套接字编程（Socket）</h3><p><a href="https://blog.csdn.net/dolacmeng/article/details/81085905" target="_blank" rel="noopener">iOS端Socket连接、发送数据</a></p><p>socket的方式实现长连接。<br>IM即时通讯是通过Socket的方式实现长连接，可运用于 </p><blockquote><p>1.直播聊天室、礼物。<br>2.微信、QQ等即时聊天。<br>3.游戏对话、技能等。</p></blockquote><p>套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行。建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket。建立连接时所需的寻址信息为IP地址和端口号</p><p>IP地址：用于区分那一台机器需要建立连接<br>端口号：用于区分和哪一个应用程序建立连接</p><p>套接字之间的连接过程分为三个步骤：<code>服务器监听</code>，<code>客户端请求</code>，<code>连接确认</code>。</p><p>创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。</p><p>Socket是我们使用TCP/IP 或者UDP/IP协议的<code>一组编程接口</code>，其介于应用层和传输层之间。传输层可以选择TCP或UDP，UDP是不可靠传输，为了保证数据的可靠性，实现起来会更加复杂(除非加上一些很多的其他私有协议，如QQ)，所以一般项目使用TCP即可.<br>我们在应用层，使用socket，轻易的实现了进程之间的通信</p><p>iOS使用Socket的常用方式有如下：<br>（1）<code>BSD Socket</code>：是UNIX系统中通用的网络接口，基于C语言，比较底层<br>（2）<code>CF Socket</code>：苹果官方提供，来自于<code>CoreFoundation</code>框架<br>（3）<code>AsyncSocket</code>：对BSD Socket的封装，OC语言<br>（4）<code>ysocket</code>：对BSD Socket的封装，Swift语言 </p><p>心跳包就是在客户端和服务器间定时通知对方自己状态的一个自己定义的命令字，按照一定的时间间隔发送，类似于心跳，所以叫做心跳包。<br>心跳包的发送，通常有两种技术</p><blockquote><p>方法1：应用层自己实现的心跳包<br>方法2：TCP的KeepAlive保活机制</p></blockquote><p>补充链接：</p><ul><li><p><a href="https://blog.csdn.net/qq_32010299/article/details/51787032" target="_blank" rel="noopener">心跳包的详细内容</a>  心跳检测步骤，等机制。</p></li><li><p><a href="https://www.cnblogs.com/letougaozao/p/3842113.html" target="_blank" rel="noopener">AsyncSocket的客户端开发和服务端简单开发</a></p></li></ul><ul><li>WebSocket</li></ul><h3 id="sdk制作注意事项"><a href="#sdk制作注意事项" class="headerlink" title="sdk制作注意事项"></a>sdk制作注意事项</h3><ul><li><p>由于OC没有命名空间概念,很大问题是重名问题.有以下几个地方都需要注意添加前缀,前缀一定要有辨识度,类名、宏定义、枚举、通知、类别等命名时加静态库统一特殊前缀，以避免命名冲突:</p></li><li><p>第三方公用库或静态库不要打入SDK进行编译<br>我们常用的网络库使用AFNetworking,SDWebImage,虽然引入到项目中,但是.m不要勾选”target membership”选项,只需要引入.h就OK.或者通过cocoapod,创建sdk工程,通过<code>cocopads</code>管理项目依赖.<br>常见的第三方框架,比如libssl.a,opencv.a,libcrypto.a等等,拖入工程的时候”Add to Target”(taget membership)都不要打勾.也就是sdk对这些公共库有依赖关系,但是最终生成的sdk不包含公共库的源码文件.</p></li></ul><ul><li>尽量减少使用Category<br>那么需要在Build settings-&gt;Other Linker Flags中添加-ObjC参数,解决运行时unrecognized selector send to instance的crash错误.<br>使用-all_load或者-force_load xxx在编译期间非常耗时.<br>为了减少耗时,本人是将通用的类创建成常用的全局函数,static函数,inline函数(注意添加前缀)</li></ul><ul><li>支持通用平台arm,x86等 (模拟器和真机都要去做处理）<br>arm指令集版本 ，要选好所有的设备。</li></ul><ul><li><p>Debug模式,必要Log输出与crash日志收集 。。  log信息如果需要收集的话，还需要自建一套系统。</p></li><li><p>涉及界面的问题，最好用自动约束。</p></li><li><p>bundle命名问题，文件配置问题。</p></li></ul><p>参考<a href="https://www.jianshu.com/p/56941218a0df" target="_blank" rel="noopener">iOS SDK应该注意的问题和tips</a></p><h3 id="Viewcontroller-的生命周期"><a href="#Viewcontroller-的生命周期" class="headerlink" title="Viewcontroller 的生命周期"></a>Viewcontroller 的生命周期</h3><p>暂略</p><h3 id="Socket与Http的关系"><a href="#Socket与Http的关系" class="headerlink" title="Socket与Http的关系"></a>Socket与Http的关系</h3><p>都是应用层。http是单项， socket建立链接时是需要http的。连接完毕后的数据传输是不需要http协议的。</p><h3 id="代理为什么用assgin、weak"><a href="#代理为什么用assgin、weak" class="headerlink" title="代理为什么用assgin、weak"></a>代理为什么用assgin、weak</h3><p>弱指针引用，减少内存释放问题。assign主要用来修饰基本的数据类型,weak用来修饰NSObject,两者对所修饰的数据都是<strong> 非拥有关系 </strong></p><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>Swift 中的普通类型不再能设为nil。那如何表示这个值不存在呢？所以引进了Optional的概念：<b><font color="10d3c4">代表 nil 或某个具体的值</font></b>。<br>所以更恰当的理解应该是：String! 只是<code>理解意义上的不为nil</code>，其本质还是一个 Optional，从声明来说它和 String? 完全等价，所以也能够赋值为 nil 。</p><h3 id="Swift常用库"><a href="#Swift常用库" class="headerlink" title="Swift常用库"></a>Swift常用库</h3><p>snapkit objectmapper swiftyjson<br>Alamofire<br>wcdb(微信、数据库) 了解学习一波</p><h3 id="组件化，常识"><a href="#组件化，常识" class="headerlink" title="组件化，常识"></a>组件化，常识</h3><ul><li><p>url-block 把调用组件使用的url和组件提供的服务block对应起来，保存到内存中，在使用组件的服务时，通过url找到对应的block，然后获取服务</p></li><li><p>protocol来定义服务接口</p></li></ul><p>等，当然还有其他方式~</p><p>组件化实施的方式<br>组件化可以利用git的源代码管理工具的便利性来实施，具体就是建立一个项目工程的私有化仓库，然后把各个组件的podspec上传到私有仓库，在需要用到组件时，直接从仓库里面取。</p><ol><li><p>封装公共库和基础UI库<br>在具体的项目开发过程中，我们常会用到三方库和自己封装的UI库，我们可以把这些库封装成组件，然后在项目里用pod进行管理。其中，针对三方库，最好再封装一层，使我们的项目部直接依赖三方库，方便后续开发过程中的更换。</p></li><li><p>独立业务模块化<br>在开发过程中，对一些独立的模块，如：登录模块、账户模块等等，也可以封装成组件，因为这些组件是项目强依赖的，调用的频次比较多。另外，在拆分组件化的过程中，拆分的粒度要合适，尽量做到组件的独立性。同时，组件化是一个渐进的过程，不可能把一个完整的工程一下子全部组件化，要分步进行，通过不停的迭代，来最终实现项目的组件化。</p></li><li><p>服务接口最小化<br>在前两步都完成的情况下，我们可以根据组件被调用的需求来抽象出组件对外的最小化接口。这时，就可以选择具体应用哪种组件化方案来实施组件化了。</p></li></ol><hr><h3 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h3><p><a href="http://www.cnblogs.com/ranyonsue/p/5984001.html" target="_blank" rel="noopener">关于HTTP协议，一篇就够了</a></p><h3 id="内存分配使用是什么样的。"><a href="#内存分配使用是什么样的。" class="headerlink" title="内存分配使用是什么样的。"></a>内存分配使用是什么样的。</h3><p>arc  以及简单的mrc<br><a href="https://blog.csdn.net/youngkehpu/article/details/56282885" target="_blank" rel="noopener">https://blog.csdn.net/youngkehpu/article/details/56282885</a></p><ol><li>代码区：用来存放函数的二进制代码，在运行时要防止被非法修改，只允许读取不允许操作</li><li>常量区：存储常量</li><li>静态区：（比如static声明的变量）<br>数据区：存放程序静态分配的变量和全局变量<br>BSS：包含了程序中未初始化全局变量</li><li>堆：由程序员分配和释放，存放进程运行中被动态分配的内存段，可大可小，根据存储的多少来调节大小。调用alloc等分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用realse释放内存时，被释放的内存从堆中被踢除（堆被缩减），因为我们现在iOS基本都使用ARC来管理对象，所以不用我们程序员来管理，但是我们要知道这个对象存储的位置</li><li>栈：栈是由编译器自动分配并释放，用来存放函数括弧“{}”中定义的变量。当函数被调用时，函数带有的参数也会被压入发起调用的进程栈中，待到调用结束后，函数的返回值也回被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。可以把栈看成一个临时数据寄存、交换的内存区。</li></ol><p>以上中堆和静态区以及常量区都是连续的，栈和代码区都是独立存放的，栈是向低地址扩展的数据结构，是一块连续的内存的区域。堆是向高地址扩展的数据结构，是不连续的内存区域。堆和栈不会碰到一起，之间间隔很大，绝少有机会能碰到一起，况且堆是链表方式存储！</p><h3 id="KVO和KVC"><a href="#KVO和KVC" class="headerlink" title="KVO和KVC"></a>KVO和KVC</h3><p>基于runtime</p><p>相当于系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法<br>每个类对象中都有一个 isa 指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将 isa 指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的 setter 方法。</p><p>KVC<br>KVC是Key Value Coding的简称。它是一种可以通过字符串的名字（key）来访问类属性的机制。<br>isa-swizzing就是类型混合指针机制</p><p>KVC的内部机制：<br>一个对象在调用setValue的时候进行了如下操作：</p><blockquote><p>（1）根据方法名找到运行方法的时候需要的环境参数<br>（2）他会从自己的isa指针结合环境参数，找到具体的方法实现接口。<br>（3）再直接查找得来的具体的实现方法</p></blockquote><h3 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h3><p><a href="http://www.cocoachina.com/ios/20180515/23380.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20180515/23380.html</a></p><p>深入浅出runloop： <a href="https://www.jianshu.com/p/7bc36b111774" target="_blank" rel="noopener">https://www.jianshu.com/p/7bc36b111774</a> 这个比较清楚一点。<br>一个线程一次只能执行一个任务，执行完成后线程就会退出。RunLoop 机制能让线程随时处理事件但并不退出。这里说的随时是指：程序需要运行时就保持程序的持续运行，不需要的时候就进入休眠状态。</p><p>不开启runloop的线程，运行完了后就关闭了。</p><p>苹果提供的runloop：Event Loop线程的任务直到我们主动让线程退出为止永远不会结束<br>RunLoop本质就是个Event Loop的do while循环。<br>就如小节标题保持线程的存活，而不是线性的执行完任务就退出了。<br>并且能在不处理消息的时候让线程休眠，节约资源，在接收到消息的时候唤醒线程做出对应处理的消息循环机制<br>线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p><p>线程默认不开启RunLoop，为什么我们的App或者说主线程却可以一直运行而不会结束？</p><p>主线程是唯一一个例外，当App启动以后主线程会自动开启一个RunLoop来保证主线程的存活并处理各种事件。而且从上面的源代码来看，任意一个子线程的RunLoop都会保证主线程的RunLoop的存在。</p><p>NSTimer定时器的触发正是基于RunLoop运行的，所以使用NSTimer之前必须注册到RunLoop。</p><p>FaceBook的AsyncDisplayKit</p><p>共同之处在于，通过合理利用RunLoop机制，将很多不是必须在主线程中执行的操作放在子线程中实现，然后在合适的时机同步到主线程中，这样可以节省在主线程执行操作的时间，避免卡顿</p><p>主线程中一般不需要我们手动添加autoreleasepool，但是，如果你希望某个对象或者变量尽快释放的时候我们也可以手动添加。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>算法中，什么是哈希值，哈希值怎么生成的，有什么用？<br>2017年10月25日 15:34:50 QianSong_Promise 阅读数：8855</p><ol><li><p>你可以把哈希值简单地理解成是一段数据（某个文件，或者是字符串）的DNA，或者身份证；</p></li><li><p>通过一定的哈希算法（典型的有MD5，SHA-1等），将一段较长的数据映射为较短小的数据，这段小数据就是大数据的哈希值。他有这样一个特点，他是唯一的，一旦大数据发生了变化，哪怕是一个微小的变化，他的哈希值也会发生变化。另外一方面，既然是DNA，那就保证了没有两个数据的哈希值是完全相同的。</p></li><li><p>正是因为这样的特点，它常常用来判断两个文件是否相同。比如，从网络上下载某个文件，只要把这个文件原来的哈希值同下载后得到的文件的哈希值进行对比，如果相同，则表示两个文件完全一致，下载过程没有损坏文件。而如果不一致，则表明下载得到的文件跟原来的文件不同，文件在下载过程中受到了损坏。</p></li></ol><h3 id="iOS消息发送"><a href="#iOS消息发送" class="headerlink" title="iOS消息发送"></a>iOS消息发送</h3><p>消息直到运行时才会与方法实现进行绑定（在OC中方法调用是一个消息发送的过程）</p><p>消息发送的主要步骤如下：</p><ol><li>首先检查这个selector是不是要忽略。</li><li>检测这个selector的target是不是nil，OC允许我们对一个nil对象执行任何方法不会Crash，因为运行时会被忽略掉。</li><li>如果上面两步都通过了，就开始查找这个类的实现IMP，先从cache里查找，如果找到了就运行对应的函数去执行相应的代码。</li><li>如果cache中没有找到就找类的方法列表中是否有对应的方法。</li><li>如果类的方法列表中找不到就到父类的方法列表中查找，一直找到NSObject类为止。</li><li>如果还是没找到就要开始进入动态方法解析（动态添加、重定向….）</li></ol><p>链接：<a href="https://www.jianshu.com/p/f31871b58cf0" target="_blank" rel="noopener">https://www.jianshu.com/p/f31871b58cf0</a>  很重要~~~。</p><p>描述一下消息发送的过程？</p><h3 id="1-SEL和IMP-！！！"><a href="#1-SEL和IMP-！！！" class="headerlink" title="1. SEL和IMP ！！！"></a>1. SEL和IMP ！！！</h3><p>使用过UIControl的朋友应该知道addTarget:action:forControlEvents:这个方法，里面的action参数通常用到一个@selector()，而这个语句的结果就是得到了一个SEL变量。SEL变量我们就叫做一个selector。Selector其实很好理解，就是在发送消息/方法调用时标识是哪个消息（方法）的东西。这个通常都是通过方法全名得来的，就比如上面UIControl的（addTarget:action:forControlEvents:）。</p><p>IMP实际上就是具体的一个方法逻辑实现（implementation，貌似IMP就是这么来的）。这个和上面代码示例中的C语言函数指针概念相似。到funcA的指针和到funcB的指针都是IMP变量。</p><p>Obejctive-C的运行时系统提供的消息的分派机制把SEL和IMP关联起来。但每次消息发送/方法调用都做一遍查找显然是很麻烦很低效的，所以在Objective-C的runtime这里一定是有缓存机制的， 使得对每个类特定selector对应的IMP可以很快找到。</p><p>当然，即使用最好的数据结构和最快的查找算法，和直接执行C函数调用的静态绑定方式相比，也一定有性能损失。但比起Objective-C运行时为开发者提供的诸多动态特性相比，这些都是值得的。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul><li><p>AFNetworking 内部实现。<br>AFNSURLSessionManager.<br>它的子类： AFHTTPSessionManager</p></li><li><p>图片上传用什么。<br>AFHTTPSessionManager</p></li></ul><p>更多请看源码，这里只做提纲列出。</p>]]></content>
      
      
      <categories>
          
          <category> 职业生涯 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>近期换工作了</title>
      <link href="/2018/12/03/%E8%BF%91%E6%9C%9F%E9%9D%A2%E8%AF%95%E4%BD%93%E9%AA%8C/"/>
      <url>/2018/12/03/%E8%BF%91%E6%9C%9F%E9%9D%A2%E8%AF%95%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>近期换工作，面试了很多家。突发发现我的很多表述能力还有“很大的潜力”。上家公司呆久了，没用到的基础性的知识，模糊的很，趁这个时候好好看了下，捡起来不少。</p><a id="more"></a><p>还是要保持竞争力才行啊。blog最好不要随心发布，还是经常学习，把笔记里的东西整理下发出来吧，满足一下~。</p><p>近期会更新一下面试的心得还有一些题。</p>]]></content>
      
      
      <categories>
          
          <category> 杂想 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Slice 1.0.1 Mac上简约计时工具</title>
      <link href="/2018/08/30/Slice%E6%9B%B4%E6%96%B01.0.1/"/>
      <url>/2018/08/30/Slice%E6%9B%B4%E6%96%B01.0.1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Slice更新："><a href="#一、Slice更新：" class="headerlink" title="一、Slice更新："></a>一、Slice更新：</h2><p><img src="https://woolni.oss-cn-chengdu.aliyuncs.com/Blog/slice_preview.webp" alt="SlicePreview"></p><p>Mac提升个人效率的一个小工具</p><h3 id="2019-3-26-更新"><a href="#2019-3-26-更新" class="headerlink" title="2019-3-26 更新"></a>2019-3-26 更新</h3><p>现开源在<a href="https://github.com/donglyu/DDNotice" target="_blank" rel="noopener">Github</a>，有兴趣的朋友可自行修改编译。<br>后续我可能会缩小占用的区域，只在状态栏上显示倒计时时间。</p><p>你是否有这样的体验，如果给你一上午的周末时间，可能会想着反正时间也多，打扫个卫生，刷刷微博一上午就过去，但如果是把这些时间划分成15分钟的片段，每个片段做一件事，一上午能做的事绝对超出你的想象。</p><p>在短暂的片刻时间内，指定一个几十分钟内要完成的任务。这几十分钟内只专做这件事，不要被其他打扰。只有倒计时才会给人紧迫感。与其在期望未来虚幻的成就，不如着眼现在，把握即将到来的一小段时间。</p><p>我个人也在用这个软件，使用下来，确实提升了不少效率。</p><a id="more"></a><h2 id="二、正确使用姿势："><a href="#二、正确使用姿势：" class="headerlink" title="二、正确使用姿势："></a>二、正确使用姿势：</h2><ul><li><p>脑中指定一件接下来要做的事，接下来的一段时间内只专注于这一件事（一段时间：就是自己输入的时间）。亲测，效率提升不少，并且有一丝紧迫感。</p></li><li><p>建议15分钟一次，太长会集中不了注意力，影响效率。此外，永远也不要做一件事超过1个小时。利用碎片时间，将整块的时间分成小片段，去做任何琐碎的事，而不会花掉整块时间处理。</p></li></ul><h2 id="三、功能特点："><a href="#三、功能特点：" class="headerlink" title="三、功能特点："></a>三、功能特点：</h2><ul><li>占用极小。</li><li>始终悬停在所有窗口最前面。</li><li>菜单栏点击，可以创建一个新的倒计时窗口（即支持多个计时器）</li><li>自定义提醒信息</li></ul><p>Slice 1.0.1. 在上一个版本的基础上，精简了一些功能。新增了以下一些功能：</p><ul><li>暂停功能：<br>可能在中途出现突发事情要去处理，可以暂停Slice时间。</li><li>更明显的提醒信息</li></ul><h2 id="四、后期功能计划"><a href="#四、后期功能计划" class="headerlink" title="四、后期功能计划"></a>四、后期功能计划</h2><ul><li>提醒音效可选择。</li><li>后期会加统计功能。</li></ul><h2 id="五、使用"><a href="#五、使用" class="headerlink" title="五、使用"></a>五、使用</h2><p>下载链接:<a href="https://pan.baidu.com/s/1roNYPESUcKJJhXRkOl6uzw" target="_blank" rel="noopener">https://pan.baidu.com/s/1roNYPESUcKJJhXRkOl6uzw</a>  密码:s1vx</p><p>解压后将<code>slice.app</code>拖动到系统的应用程序中</p><p>另外，针对某些用户所说，在10.11以后系统可能安装不了的情况，可以在“设置”中“安全与隐私”的“通用”选项下， 设置<b>允许从任何来源的应用</b>。然后就可以正常使用Slice了。因为Slice是本人在业余时间开发，并未上架App store，且OS X系统有这么一个保护机制，故有这样现象。</p><p><img src="https://woolni.oss-cn-chengdu.aliyuncs.com/Blog/slice安全设置所有来源.png" width="70%"></p><p>如果在这个地方没有“任何来源”一项的话，就需要打开系统应用“终端”，输入</p><pre><code class="sh">sudo spctl --master-disable</code></pre><p>然后再输入你的系统密码回车即可（不屏显）。</p><h2 id="六、联系我"><a href="#六、联系我" class="headerlink" title="六、联系我"></a>六、联系我</h2><p>如果你有什么建议或意见，请告诉我~<br>[邮箱]：<a href="mailto:dongingdao@163.com" target="_blank" rel="noopener">dongingdao@163.com</a></p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>记一则iOS封装SDK的开发过程之WebView和JS交互</title>
      <link href="/2018/05/20/%E8%AE%B0%E4%B8%80%E5%88%99iOS%E5%B0%81%E8%A3%85SDK%E7%9A%84%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B9%8BWebView%E5%92%8CJS%E4%BA%A4%E4%BA%92/"/>
      <url>/2018/05/20/%E8%AE%B0%E4%B8%80%E5%88%99iOS%E5%B0%81%E8%A3%85SDK%E7%9A%84%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B9%8BWebView%E5%92%8CJS%E4%BA%A4%E4%BA%92/</url>
      
        <content type="html"><![CDATA[<p>  近来接触了一个封装sdk的项目，过程中遇到了一些问题，现在空了下来，将这个过程记录一下。<br>项目主要由<u>iOS封装一个framework静态库，库里面引入由甲方提供的js方法库（一个js文件），原生调用js中的方法，将方法返回值通过原生方法回调会去</u>。相当于一个中间件的功能。</p><p>  我首先想到的是通过 <font color="a52a2a"><b>UIWebView</b></font> 或 <font color="a52a2a"><b>WKWebView</b></font> 来加载js，然后通过javascriptCore和WKWebView自带的方法来处理。这个甲方要求又不要显示html页面，所以使用WebView有点用了牛刀的感觉。查了查资料，没有找到直接能和js文件交互的方法，无奈还是采用了WKWebView。</p><a id="more"></a><p>  由于wkwebView是iOS8以后推出的新框架，故而一开始就使用使用了wkwebview。当对应的html、js到位后，发现js中的回调很奇怪，原生偶尔可以得到回调，猜测可能js方法库中方法太过繁忙，从而导致消息堵塞进而丢失掉。经过延时的操作，发现并不是这个问题。</p><p>  正如之前说的，项目并不需要展示webView，html中的内容也不需要展示。而需求是提供.framework，不可能头文件提供一个webView给开发者，添加到对应的界面上吧。因此做了一个小尝试，快速改换成了UIWebView，相应的js方法，和调用方法，以及回调方法改了下来测试。发现可以正常使用。这下得出结论WkWebView如果没有正常显示的话，内部有种“惰性”的感觉，某些js方法执行和回调很“迟缓”，往往点几次才会响应。</p><p>  研究到这，应该是换成UIWebView了。但是抱着不甘心，多查了些资料，和试验了几波，是真的因为那个原因吗？不多说了，总结了下我的两个解决方法：</p><h2 id="最终解决"><a href="#最终解决" class="headerlink" title="最终解决"></a>最终解决</h2><h3 id="1-使用UIWebView"><a href="#1-使用UIWebView" class="headerlink" title="1.使用UIWebView"></a>1.使用UIWebView</h3><p>js中使用下面的代码回调原生</p><pre><code class="js">bclMiddlecallback(callbackScheme, callbackPath); </code></pre><p>UIWebView可以不加在任何View上，也可以设置<code>.hidden = YES;</code></p><h3 id="2-继续使用WKWebView"><a href="#2-继续使用WKWebView" class="headerlink" title="2.继续使用WKWebView"></a>2.继续使用WKWebView</h3><p>js中使用下面的方法回调原生</p><pre><code class="js"> window.webkit.messageHandlers.bclMiddlecallback.postMessage(callbackScheme + callbackPath); </code></pre><p>！！！WKWebView必须加在某个View上，内部一些机制才能正常运转、回调才能正常发生。.hidden设置或者不设置不影响。</p><p>所以：</p><pre><code class="objc">WKWebView *wkWebView = [[WKWebView alloc] initWithFrame:CGRectMake(0, [[UIScreen mainScreen] bounds].size.height, 320, 480) configuration:configuration];_wkWebView = wkWebView;[[[UIApplication sharedApplication] windows].firstObject addSubview:wkWebView];wkWebView.hidden = YES;</code></pre><p>收工！</p><hr><p>如果你也遇到此问题，如果你有新的想法请联系我：<a href="mailto:dongigndao@163.com" target="_blank" rel="noopener">dongigndao@163.com</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS WebView修改userAgent的问题与解决</title>
      <link href="/2018/03/22/iOS%20WebView%E4%BF%AE%E6%94%B9userAgent%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/"/>
      <url>/2018/03/22/iOS%20WebView%E4%BF%AE%E6%94%B9userAgent%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>  前阵子做一个阅读应用，需要嵌入H5页面，要让网页检测到是App的webView访问。网页有个loading数据过程，这个loading效果比较复杂，于是乎由客户端实现，需要网页告诉客户端什么时候该关掉Loading动画遮罩层（还有一些其他交互效果）。这就涉及到了网页和原生的交互了。客户端使用的是<font color="a52a2a">WKWebView</font>。</p><a id="more"></a><p>  在UIWebView上修改全局userAgent就使用：</p><pre><code class="objc">UIWebView *webView = [[UIWebView alloc] initWithFrame:CGRectZero];    NSString *userAgent = [webView stringByEvaluatingJavaScriptFromString:@"navigator.userAgent"];    NSString *newUserAgent = [userAgent stringByAppendingString:@" AppFlag"];        newUserAgent = [newUserAgent stringByAppendingString:[NSString stringWithFormat:@" token/%@", token]];    }    NSDictionary *dictionary = [NSDictionary dictionaryWithObjectsAndKeys:newUserAgent, @"UserAgent", nil];    [[NSUserDefaults standardUserDefaults] registerDefaults:dictionary];</code></pre><p>  在UIWebView上获取userAgent的方法是同步的(Synchronous)。</p><p>  如果实在WKWebView上则使用：</p><pre><code class="objc">WKWebView *wkWebView = [[WKWebView alloc] initWithFrame:CGRectZero];    self.wkWebView = wkWebView;    [wkWebView evaluateJavaScript:@"navigator.userAgent" completionHandler:^(id result, NSError *error) {        NSString *userAgent = result;        NSString *newUserAgent = [userAgent stringByAppendingString:@" AppFlag"];    newUserAgent = [newUserAgent stringByAppendingString:[NSString stringWithFormat:@" token/%@", token]];        NSDictionary *dictionary = [NSDictionary dictionaryWithObjectsAndKeys:newUserAgent, @"UserAgent", nil];        [[NSUserDefaults standardUserDefaults] registerDefaults:dictionary];         [self.wkWebView setCustomUserAgent:customUserAgent]    }];</code></pre><p>  在WKWebView上获取userAgent就是异步的(Asynchronous)。</p><p>  如果在webView loadRequest之前使用WKWebView的方式修改了userAgent之后，在Safari中调试发现userAgent实际上可能并没有成功修改。其实是因为异步修改没有修改成功，如果再次load了一个新页面，再在Safari中控制台输入<code>navigator.userAgent</code>就可以查看到修改后的内容，这就是很多其他朋友说遇到的要第二次才能显示自定义的值。<strong><font color="10d3c4">这里建议使用UIWebView的方式修改全局userAgent，然后再使用WKWebView取加载内容，最简单最通用</font></strong>。如果使用WKWebView修改后再用WKWebView加载页面，需要注意获取并修改 userAgent 的 webView 对象，跟加载网页的 webView 不能是同一个对象，也就说在获取到当前的userAgent的回调里需要重新初始化 wKWebView来加载页面。</p><pre><code class="objc">     UIWebView *webView = [[UIWebView alloc] initWithFrame:CGRectZero];     NSString *userAgent = [webView stringByEvaluatingJavaScriptFromString:@"navigator.userAgent"];     NSString *newUserAgent = [userAgent stringByAppendingString:@" native_iOS"];//自定义需要拼接的字符串     NSDictionary *dictionary = [NSDictionary dictionaryWithObjectsAndKeys:newUserAgent, @"UserAgent", nil];     [[NSUserDefaults standardUserDefaults] registerDefaults:dictionary];     [self.wkWebView setCustomUserAgent:customUserAgent]</code></pre><p>  <strong>参考链接：</strong></p><p><a href="https://stackoverflow.com/questions/26994491/set-useragent-in-wkwebview" target="_blank" rel="noopener">https://stackoverflow.com/questions/26994491/set-useragent-in-wkwebview</a><br><a href="https://cloud.tencent.com/developer/article/1158832" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1158832</a></p>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>苹果的Marzipan</title>
      <link href="/2017/12/27/%E8%8B%B9%E6%9E%9C%E7%9A%84Marzipan/"/>
      <url>/2017/12/27/%E8%8B%B9%E6%9E%9C%E7%9A%84Marzipan/</url>
      
        <content type="html"><![CDATA[<p>  听说有个新的东西：为了增强Mac上的软件产品，苹果正在计划模糊macOS和iOS平台之间的界限，允许iOS App Store上的iPhone和iPad应用程序在Mac上运行：</p><p>  <code>Marzipan</code>  <a href="https://baijiahao.baidu.com/s?id=1587358985291753758&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">新闻来源</a>    <em>一个App适配所有设备。</em></p><a id="more"></a><p>  一方面，熟悉苹果生态的人都比较清楚，iOS上软件质量一向很高，数量也很多，几乎能够找到所有功能的App。而对应的MAC OS平台上相比较iOS，软件上数量上就少很多了（软件质量上我个人认为是不差的。）。<br>如果iOS上的App能够跨在MAC OS上使用就好了。</p><p>  另一方面，如果苹果能将这条通道打通的话，那么iPad的用武之地就大许多了，随之而来iPad的销量也将会大幅上升。毕竟现阶段iPad还是处于一个尴尬的处境，处理复杂事物时，还是需要Mac的文件管理系统，能够更加灵活的处理。处理文档、简单任务时，iPad还是有优势的。</p><p>  期待一下吧。</p>]]></content>
      
      
      <categories>
          
          <category> Apple </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift中的值类型引用类型相关内容</title>
      <link href="/2017/10/14/Swift%E4%B8%AD%E7%9A%84%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/"/>
      <url>/2017/10/14/Swift%E4%B8%AD%E7%9A%84%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Swift中的值类型和引用类型"><a href="#一、Swift中的值类型和引用类型" class="headerlink" title="一、Swift中的值类型和引用类型"></a>一、Swift中的值类型和引用类型</h2><h3 id="1-值类型和引用类型是啥"><a href="#1-值类型和引用类型是啥" class="headerlink" title="1.值类型和引用类型是啥"></a>1.值类型和引用类型是啥</h3><p>最近在用Swift写些小东西，发现Swift中的值类型和引用类型好像有些奇怪，包括之前了解到的NSArray和Array之间的关系，有些混淆了。现在静下来来学习下，记录一下，防止后面犯错。</p><p>首先来过一下基础概念：什么是值类型和引用类型。</p><blockquote><ul><li>值类型：每个实例都拥有数据的一份副本。当被赋值给一个变量或常量，或传递给一个函数时，它都会拷贝一份新的副本。</li><li>引用类型：所有实例共享一个数据副本。当被赋值给一个变量或常量，或传递给一个函数时候，一个引用类型一旦被初始化，会返回一个指向已存在实例的引用。</li></ul></blockquote><p>类(class)是一个引用类型，复制一个引用，即表示建立一个共享的实例。复制之后，两个变量都使用数据中同一份实例。</p><p>类(Class)是一个引用类型，意味着类中的变量不会存储实例，而是一个向内存(堆)中存储该实例位置的引用。</p><a id="more"></a><pre><code class="swift">class People{    var name = "张三"}var badStudent = People()var goodStudent = badStudentgoodStudent.name = "李四"print("badStudent's name:\(badStudent)") // 李四print("goodStudent's name:\(goodStudent)") // 李四// 修改goodStudent中的内容就相当于修改badStudent。它们所代表的是同一个东西。</code></pre><p>但除了Class外，Swift还有一种常用的类型：结构体。而结构体就是一个值类型。而Swift中用Struct的场景变多了。<br>类似<code>Array</code>、<code>Dictonary</code>。</p><pre><code class="swift">struct People{    var name = "张三"}var firstStudent = People()var secondStudent = firstStudentfirstStudent.name = "李四"print("firstStudent's name:\(firstStudent)") // 李四print("secondStudent's name:\(secondStudent)") // 张三// secondStudent用firstStudent赋值后，就是一个独立的数据实例了。</code></pre><p>当然，Swift中值类型和引用类型还有很多：</p><p><img src="http://cc.cocimg.com/api/uploads//20180503/1525333385999865.png" alt="Swift中值类型和引用类型表"></p><blockquote><p>Swift把一个引用类型看成一个类，这和Objective-C中很像。Objective-C中一切继承于NSObject都被按照引用类型存储。</p></blockquote><h3 id="2-什么时候用值引用和引用类型好"><a href="#2-什么时候用值引用和引用类型好" class="headerlink" title="2.什么时候用值引用和引用类型好"></a>2.什么时候用值引用和引用类型好</h3><ul><li>以下时候使用值类型：</li></ul><p>想要用==比较实例数据。一个双等号(==)用于比较值。</p><p>你想复制来建立独立数据。</p><p>数据要在多线程的代码中使用，那么你就不用担心数据会被其他线程改变。</p><ul><li>以下时候使用引用类型(比如一个类)：</li></ul><p>想要用==比较实例一致性。==会检查两个对象是否完全一致，包括存储数据的内存地址。</p><p>你想要创建用于共享，可改变的数据。</p><hr><h3 id="3-值类型和引用类型的存储"><a href="#3-值类型和引用类型的存储" class="headerlink" title="3.值类型和引用类型的存储"></a>3.值类型和引用类型的存储</h3><blockquote><p>值类型-在栈内存中存储、而引用类型-在托管堆内存中存储。</p></blockquote><p>像前面说的，引用类型实例存在堆中，值类型实例比如结构存在于一个称为栈的内存区域中。如果值类型实例是一个类的一部分，值会和类一起存在堆中。</p><p>栈被用于静态存储分配，栈用于动态存储分配，它们都存在计算机的RAM中。</p><p>栈被CPU紧密管理并优化，当一个函数创建一个变量，栈会存储这个变量，并在函数退出时候被毁掉。被分配到栈的变量直接存储在内存上，访问这段内存非常快。当一个函数或者方法调用另一个函数，另一个函数再依次调用其他函数等等，直到最后一个函数返回它的值之前，其他所有函数都会保持暂停执行。</p><p>栈总是按照LIFO顺序保留，最新保留的区块总是会下一个释放。这使得跟踪记录栈非常简单，释放一个栈上的区块不过是调整一个指针。因为栈非常组织有序，所以它快捷高效。</p><p>系统使用堆存储被其他对象引用的数据，堆是一大片内存，系统可以从中请求并动态分配内存区块。堆并不会像栈一样自动毁掉它的对象，需要外部工作来处理这些。在苹果设备中ARC就做这个工作。引用数量会被ARC追踪，当它变为0时对象会被释放。因此整个过程(分配，追踪引用，释放)会比栈要慢。所以值类型要快于引用类型。</p><h2 id="二、Swift中的Array"><a href="#二、Swift中的Array" class="headerlink" title="二、Swift中的Array"></a>二、Swift中的Array</h2><p>在OC中数组可以copy或者mutablecopy，可变数组和不可变数组可以来回拷贝数据。NSArray、NSMutableArray之间是不同点实例，来回处理过后，内部存储的元素其实指针所指向内容都是同一个。</p><p>而在Swift中常用的数组对象<code>Array</code>。跳转到其定义处：</p><pre><code class="swift">public struct Array&lt;Element&gt; {//...}</code></pre><p>发现其实Array是一个结构体，是一个值类型，且不自带copy方法的方法，数组分成:可变数组和不可变数组，分别使用let修饰的数组是不可变数组，使用var修饰的数组是可变数组。如果想要实现拷贝方法，则需要对对象实现拷贝方法。即遵守NSCopying协议和实现copyWithZone方法<br>eg:</p><pre><code class="swift">// 实现NSCopying协议。class Person : NSObject, NSCopying {    var name: String?    var age: Int?    func copyWithZone(zone: NSZone) -&gt; AnyObject {        let person = Person()        person.name = self.name        person.age = self.age        return person    }}</code></pre><p>所以在Swift中，像Array、Dictinary和Set这样的值类型集合，注意和OC中的NSArray、NSDictionary和NSSet有区别了。当被传递后，将会拷贝一份副本，之前那份数据的变更后面并不会同步更新过来，这点需要注意点。刚开始在这儿按照OC的惯性思维遇到了数据不一致的问题。另外提一句，像Array、Dictionary和Set这些是通过一个叫写时复制 (copy-on-write)的技术实现。<br>（简单提一下：就是为了提供高效的写时复制特性，我们需要知道一个对象 (比如这里的 NSMutableData) 是否是唯一的。如果它是唯一引用，那么我们就可以直接原地修改对象。否则，我们需要在修改前创建对象的复制。）。</p><p>—- 完 —-</p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift中常见的$0和$1有什么用？</title>
      <link href="/2017/09/08/Swift%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84$0%E4%BD%9C%E7%94%A8/"/>
      <url>/2017/09/08/Swift%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84$0%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><code>$0</code>，<code>$1</code>… 是对闭包中参数的简化写法</p><p>swift自动为 <b><font color="red">闭包</font></b> 提供参数名缩写功能，可以直接通过<code>$0</code>和<code>$1</code>等来表示闭包中的第一个第二个参数，并且对应的参数类型会根据函数类型来进行判断。</p><a id="more"></a><pre><code class="swift">// 不使用`$0` `$1`这些来代替let numbers = [1,2,5,4,3,6,8,7]        sortNumbers = numbers.sorted(by: { (a, b) -&gt; Bool in            return a &lt; b        })        print("numbers -" + "\(sortNumbers)")// 使用$0,$1let numbers = [1,2,5,4,3,6,8,7] var sortNumbers = numbers.sorted(by: {$0 &lt; $1}) print("numbers -" + "\(sortNumbers)")</code></pre> <!-- more --><p>使用<code>$0</code>、<code>$1</code>的话，参数类型可以自动判断，并且<code>in</code>关键字也可以省略，也就是只用写函数体就可以了。来看看另外个例子：</p><pre><code class="swift">var add = { (arg1: Int, arg2: Int) -&gt; Int in    return arg1 + arg2}add = { (arg1, arg2) -&gt; Int in    return arg1 + arg2}add = { arg1, arg2 in    arg1 + arg2}add = {    $0 + $1}let result = add(10, 10) // 20</code></pre><p>—– 完 —–</p>]]></content>
      
      
      <categories>
          
          <category> swift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于术业有专攻的小小感悟</title>
      <link href="/2017/09/01/%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%B0%8F%E7%9A%84%E7%BB%8F%E9%AA%8C/"/>
      <url>/2017/09/01/%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%B0%8F%E7%9A%84%E7%BB%8F%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>那就是 <b><font color="a52a2a" size="4">写些小工具如果要发布，还是和其他专业的人合作比较好一些。</font></b></p><a id="more"></a><p>最近在做一个项目，在APP的菜单结构犯了难，不知道该用这种比较符合。我的目的是尽量精致而简洁，没有一些花里胡哨的设计内容。<br>今天突然就想记录一下。也贴出来一些，我觉得还可以的设计。就算不在现在在做的sideProject中用，以后也有用的到的。</p><p>以前只是了解术业有专攻，每个人都不可能每个方面都擅长。跑道上领先的都是很懂的合作的人。</p>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Slice 一个小而简的Mac计时软件、拖延症神器、倒计时小工具</title>
      <link href="/2017/05/30/Slice%E4%B8%80%E4%B8%AA%E5%B0%8F%E8%80%8C%E7%B2%BE%E7%AE%80%E7%9A%84Mac%E8%AE%A1%E6%97%B6%E8%BD%AF%E4%BB%B6%EF%BC%8C%E6%8B%96%E5%BB%B6%E7%97%87%E7%A5%9E%E5%99%A8%EF%BC%8C%E5%80%92%E8%AE%A1%E6%97%B6%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
      <url>/2017/05/30/Slice%E4%B8%80%E4%B8%AA%E5%B0%8F%E8%80%8C%E7%B2%BE%E7%AE%80%E7%9A%84Mac%E8%AE%A1%E6%97%B6%E8%BD%AF%E4%BB%B6%EF%BC%8C%E6%8B%96%E5%BB%B6%E7%97%87%E7%A5%9E%E5%99%A8%EF%BC%8C%E5%80%92%E8%AE%A1%E6%97%B6%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>对于常年和电脑打交道的人群来说，在很多时候, 人往往变得浮躁, 坐在电脑旁不到几分钟就像打开网页看视频啊, 打开游戏, 干些不相关的东西，专注力不够，从而导致工作效率低，工作质量不高的效果，进而影响到我们的生活，心情等。</p><p>现在你试试这个小工具：<br><img src="http://ocs32tleq.bkt.clouddn.com/14961482427792.jpg" alt=""></p><p>  有研究表明，合理的运用人的精力，松紧有弛，能够最大限度的发挥人的能力。自然界本身有它的脉动，一种在活动和休息之间周期性的像波浪一样的运动。想想潮涨潮落、季节变化，以及每天的日出日落。同样，所有的机体都遵循一种维持生命的有规则的变化。就像运动员，我们发现那些成绩好的运动员往往更懂得如何放松和规划自己的精力，在高强度，长时间，高压力的比赛中，很难保持长时间的高水准，因此这些人通常会抓紧一切时间储存精力，等到需要的爆发的时候，集中全部的注意力，更能发挥出好的运动水平，对于普通人，这也同样适用。</p><a id="more"></a>  <p><img src="http://ocs32tleq.bkt.clouddn.com/%E5%92%96%E5%95%A1.jpg" alt="咖啡"></p><p>  现在针对这种情况，您可以使用Slice这个小工具，别看它小，但是简洁简单有效，可以有效指定完成某项工作要花的时间，让您有一种紧迫感来做事，进而提高注意力提高工作效率。也可以用来控制工作时间，毕竟人的精力精神不会连续好几个小时高度保持注意，懂得平衡的奥秘，累了，渴了不如出去走走，喝喝水，看看远方，说不定工作的难题就在这些休息过程中想到的最佳的解决方案la😄。</p><h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><p><img src="http://ocs32tleq.bkt.clouddn.com/14961479652001.jpg" alt=""></p><p>写好要做的事，订好一个时间，就可以开始啦。</p><p>  还可以做一些小的设置：<br><img src="http://ocs32tleq.bkt.clouddn.com/14961482832008.jpg" alt=""></p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>自定义下一件唯一要做的事，让你专注于工作中…</li><li>自定义提示文字信息。</li><li>可简单控制结束的音效播放。</li><li>CPU 占用率超低, 不会影响您的工作。</li></ul><p>  总之，可以通过Slice，可以平复烦躁杂乱的心，专注于单线程，提升效率。</p><p><br></p><font size="6" color="10d3c4">您唯一要做的事就是自己要遵守自己定的要做的事</font><h3 id="可能遇到的问题："><a href="#可能遇到的问题：" class="headerlink" title="可能遇到的问题："></a>可能遇到的问题：</h3><p>  针对某些用户所说，在10.11以后系统可能安装不了的情况。</p><p>可以在“设置”中“安全与隐私”的“通用”选项下， 设置<b>允许从任何来源的应用</b>。然后就可以正常使用Slice了。<br>因为Slice是本人在业余时间开发，并未上架App store，且OS X系统有这么一个保护机制，故有这样现象。</p><p><img src="http://ocs32tleq.bkt.clouddn.com/PastedGraphic-1-systemSettingforMac.png" alt="系统设置"></p><p>  如果在这个地方没有“任何来源”一项的话，就需要打开系统应用“终端”，输入</p><p><code>sudo spctl --master-disable</code><br>然后再输入你的系统密码回车即可（不屏显）。</p><h3 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a>下载地址：</h3><p><a href="http://pan.baidu.com/s/1mium0J2" target="_blank" rel="noopener">Slice 1.0</a></p><p><br></p><h3 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h3><p>  这个小的app希望对你有用。虽然很小，还还算有用，平时提醒喝喝茶或者短暂休息下。<br>如果你希望能更新此软件的功能，或者有什么建议或者意见，可以通过下面的方式联系我：<br><a href="mailto:dongingdao@163.com" target="_blank" rel="noopener">dongingdao@163.com</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS实现实时通信或推送的常用策略</title>
      <link href="/2017/04/20/iOS%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E9%80%9A%E4%BF%A1%E6%88%96%E6%8E%A8%E9%80%81%E7%9A%84%E5%B8%B8%E7%94%A8%E7%AD%96%E7%95%A5/"/>
      <url>/2017/04/20/iOS%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E9%80%9A%E4%BF%A1%E6%88%96%E6%8E%A8%E9%80%81%E7%9A%84%E5%B8%B8%E7%94%A8%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="1-iOS静默推送，不含alert，没有声音没有弹框，具体更多可以看这儿"><a href="#1-iOS静默推送，不含alert，没有声音没有弹框，具体更多可以看这儿" class="headerlink" title="1.iOS静默推送，不含alert，没有声音没有弹框，具体更多可以看这儿"></a>1.iOS静默推送，不含alert，没有声音没有弹框，具体更多可以看<a href="http://blog.csdn.net/hherima/article/details/50469519" target="_blank" rel="noopener">这儿</a></h3><p>限制与注意：<br><code>Silent Remote Notifications</code>是在Apple的限制下有一定的频率控制，并不是所有的静默推送都能按预期到达客户端触发函数的。<br>前提：客户端需处于Background或Suspended状态。<br>Apple 官方文档说：<a href="https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html" target="_blank" rel="noopener">Configuring a Silent Notification</a></p><pre><code>Silent notifications are not meant as a way to keep your app awake in the background, nor are they meant for high priority updates. APNs treats silent notifications as low priority and may throttle their delivery altogether if the total number becomes excessive. The actual limits are dynamic and can change based on conditions, but try not to send more than a few notifications per hour.</code></pre><p>用户如果禁止了推送权限，还能收到静默推送吗？这将是一个问题。</p><a id="more"></a><h3 id="2-轮询"><a href="#2-轮询" class="headerlink" title="2.轮询"></a>2.轮询</h3><p>1.Http polling<br>2.Http Long-polling</p><blockquote><p>Http polling也就是轮询的策略，它唯一的优点就是实现简单，技术门槛低。但是缺点也很明显：不够实时，且效率低下，导致server端负载较高。</p></blockquote><blockquote><p>Http Long-polling（长轮询，也称作comet）技术，是在Http polling基础上优化而来。在长轮询策略下，当server端没有数据推送到client端时，请求不会立即返回，而是被server端hold住，直到有数据发送，或者超时，才发送响应。Client端收到响应之后，立即重新发起http请求。<br>这种策略比简单的轮询优化了许多，但开发和维护成本也提高了许多。并且，效率还不够高，存在资源的浪费。而这主要是因为http协议头本身带来的overhead。</p></blockquote><h3 id="3-长连接"><a href="#3-长连接" class="headerlink" title="3.长连接"></a>3.长连接</h3><blockquote><p>Socket长连接是目前认为优点最多的解决方案。这一方案的原理是client端向server端建立一个TCP长连接，通过心跳的机制维护连接畅通，当有数据需要交互时，双方都可以通过这个长连接进行通信。</p></blockquote><blockquote><p>多年前这种方案无法应用在浏览器端，然而随着html5的兴起和浏览器的发展，目前主流的浏览器都已经支持websocket了，可以很好的实现长连接。</p></blockquote><blockquote><p>Socket长连接是最理想的方案，但开发成本也相应的最高。服务端需要支持大量的连接数，且长连接本身的特性也决定了服务不再是无状态的，这给服务的稳定性和可扩展性带来了一定的挑战。</p></blockquote><h2 id="评估："><a href="#评估：" class="headerlink" title="评估："></a>评估：</h2><p>从成本来说，客户端轮询请求 服务器压力最小，但是不太敏感<br>tcp长连接呢，服务器压力大些，但是消息及时。</p><p>iOS如果要用socket长连接的话，可以用<a href="http://www.cocoachina.com/ios/20160602/16572.html" target="_blank" rel="noopener">这篇文章</a>提到的<a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="noopener">CocoaAsyncSocket</a></p><p>可以用<code>CocoaAsyncSocket</code>先写一个<a href="http://www.cnblogs.com/XYQ-208910/p/5169209.html" target="_blank" rel="noopener">Demo</a></p><p>如果想了解更多CocoaAsyncSocket可以从这篇文章入手：<a href="http://www.cocoachina.com/ios/20170127/18619.html" target="_blank" rel="noopener">iOS即时通讯进阶 - CocoaAsyncSocket源码解析(Connect篇)</a></p><p>备选：<a href="https://github.com/facebook/SocketRocket" target="_blank" rel="noopener">SocketRocket</a></p><hr><p>— 备注区，不算入文章内。</p><ul><li>其他</li></ul><p>  建立tcp连接，定期发keep alive防止socket超时断开。发消息直接发tcp数据包。<br>或者直接用第三方的push notification服务。原理类似，只不过平台统一keep alive省电。需要注册在服务提供方注册。</p><p>  服务端给客户端推送，普遍做法是客户端与服务端维持一个长连接，客户端定时向服务端发送心跳以维持这个长连接。当有新消息过来的时候，服务端查出该消息对应的TCP Channel的ID并找到对应的通道进行消息下发。</p><p>  国内安卓应用，如果没有使用GCM，绝大多数没有使用，那就起后台Service定时唤醒系统查询，一个是为了保持心跳，一个是为了查询消息。这种机制非常浪费运营商的资源，也非常费电。所以，建议把所有的应用设置都看清楚，尽量选择非推送。尤其是天气预报，手工查一下就行了，否则，那个所谓的墨迹天气，5分钟查一次，频率比得上微信了。完全没有必要，太费电了。要是赶上小区拥堵的情况，频繁的PDP激活，建立RRC连接，再释放，电池消耗特别大。而且还会发热，用户体验会很糟糕。</p><p>  连接都是由客户端发起的！（因为客户端通常在子网下，没有公网IP，根本没办法接受连接）所谓『推送』的实现方式无外乎两种：一是基于长连接，客户端发起连接，双方维护这个连接，服务器端有变动随时拿这个连接通知客户端。这就是正常意义上的『推送』。二是基于短连接，客户端轮询发起短连接，询问服务器端变化。这实际上是『拉取』，并不是『推送』。燃鹅，维护连接的成本太大了，除了即时性要求苛刻的场景之外，大家普遍采用了第二种方法。</p><h3 id="iOS中应用内部实现长连接发送接受机制。"><a href="#iOS中应用内部实现长连接发送接受机制。" class="headerlink" title="iOS中应用内部实现长连接发送接受机制。"></a>iOS中应用内部实现长连接发送接受机制。</h3><ol><li>基于Http的长连接。（用的比较少）</li><li>基于Socket的长连接。</li><li>基于xmpp的消息P2P消息机制</li></ol><p>貌似普通的socket连接对服务器的消耗太大了。（是否有其他协议，比较有名的是MQTT协议）</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对UIMenuController菜单自定义</title>
      <link href="/2017/02/06/%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89UIWebView%20%E7%9A%84UIMenuController%E9%80%89%E9%A1%B9/"/>
      <url>/2017/02/06/%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89UIWebView%20%E7%9A%84UIMenuController%E9%80%89%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<p>  项目中遇到了需要对UIWebView中弹出菜单的一些定制，所以查找一些资料，整理记录一下。</p><p>首先看看UIMenuController默认支持的方法：</p><pre><code class="objc">- (void)cut:(nullable id)sender NS_AVAILABLE_IOS(3_0);- (void)copy:(nullable id)sender NS_AVAILABLE_IOS(3_0);- (void)paste:(nullable id)sender NS_AVAILABLE_IOS(3_0);- (void)select:(nullable id)sender NS_AVAILABLE_IOS(3_0);- (void)selectAll:(nullable id)sender NS_AVAILABLE_IOS(3_0);- (void)delete:(nullable id)sender NS_AVAILABLE_IOS(3_2);- (void)makeTextWritingDirectionLeftToRight:(nullable id)sender NS_AVAILABLE_IOS(5_0);- (void)makeTextWritingDirectionRightToLeft:(nullable id)sender NS_AVAILABLE_IOS(5_0);- (void)toggleBoldface:(nullable id)sender NS_AVAILABLE_IOS(6_0);- (void)toggleItalics:(nullable id)sender NS_AVAILABLE_IOS(6_0);- (void)toggleUnderline:(nullable id)sender NS_AVAILABLE_IOS(6_0);- (void)increaseSize:(nullable id)sender NS_AVAILABLE_IOS(7_0);- (void)decreaseSize:(nullable id)sender NS_AVAILABLE_IOS(7_0);// 更多带_的私有方法可以看: https://yq.aliyun.com/articles/39475</code></pre><a id="more"></a><p>而我们常用的是<code>cut</code>，<code>copyt</code>，<code>past</code>，<code>selct</code>等。因此主要是对这几个方法的处理。</p><h3 id="实现自定义菜单（UITextView、UITextField）"><a href="#实现自定义菜单（UITextView、UITextField）" class="headerlink" title="实现自定义菜单（UITextView、UITextField）"></a>实现自定义菜单（UITextView、UITextField）</h3><p>  要想实现自定义显示的长按文字菜单, subClass UIWebViewController. 然后重写方法:</p><pre><code class="objc">-(BOOL)canPerformAction:(SEL)action withSender:(id)sender{    if (action == @selector(selectAll:) || action == @selector(cut:)\        || action == @selector(delete:)\        || action == @selector(toggleUnderline:)\        || action == @selector(toggleBoldface:)\        || action == @selector(toggleItalics:)\        || action == NSSelectorFromString(@"_showTextStyleOptions:")) {        return NO;    }    return [super canPerformAction:action withSender:sender];}</code></pre><h3 id="可编辑的UIWebView自定义UIMenuController选项"><a href="#可编辑的UIWebView自定义UIMenuController选项" class="headerlink" title="可编辑的UIWebView自定义UIMenuController选项"></a>可编辑的UIWebView自定义UIMenuController选项</h3><p>  前期尝试过创建UIWebView之类, 然后重写<code>canPerformAction:(SEL)action withSender:(id)sender</code>方法来控制显示和隐藏哪些菜单项, 但是发现不行(UITextView等可以)。查看UIWebView的subViews, 可以发现一个类: <font color="a52a2a">UIWebBrowserView</font>which has a text property, from this we know what class we need to subclass.然而这个UIWebBrowserView又是一个私有类,通过正常方式又获取不到.<br>思路有两个: 一个是通过运行时替换这个class的方法成我们自己的方法。二是通过创建<code>UIWebBrowserView</code>的类别，并用我们的方法替换掉原来的方法(私有API,传App Store会被打回)。</p><hr><h4 id="1-通过runtime替换方法"><a href="#1-通过runtime替换方法" class="headerlink" title="1. 通过runtime替换方法"></a>1. 通过runtime替换方法</h4><p>添加方法<code>mightPerformAction:withSender:</code></p><pre><code class="objc">- (BOOL)mightPerformAction:(SEL)action withSender:(id)sender {NSLog(@"******Action!! %@******",NSStringFromSelector(action));  if (action == @selector(copy:))  {      NSLog(@"Copy Selector");      return NO;  }  else if (action == @selector(cut:))  {      NSLog(@"cut Selector");      return NO;  }  else if (action == NSSelectorFromString(@"_define:"))  {      NSLog(@"define Selector");      return NO;  }  else if (action == @selector(paste:))  {      NSLog(@"paste Selector");      return NO;  }  else  {      return [super canPerformAction:action withSender:sender];  }}</code></pre><p>然后是替换旧的<code>canPerformAction:action withSender:sender</code>方法</p><pre><code class="objc">- (void) replaceUIWebBrowserView: (UIView *)view{//Iterate through subviews recursively looking for UIWebBrowserViewfor (UIView *sub in view.subviews) {    [self replaceUIWebBrowserView:sub];    if ([NSStringFromClass([sub class]) isEqualToString:@"UIWebBrowserView"]) {        Class class = sub.class;        SEL originalSelector = @selector(canPerformAction:withSender:);        SEL swizzledSelector = @selector(mightPerformAction:withSender:);        Method originalMethod = class_getInstanceMethod(class, originalSelector);        Method swizzledMethod = class_getInstanceMethod(self.class, swizzledSelector);        //add the method mightPerformAction:withSender: to UIWebBrowserView        BOOL didAddMethod =        class_addMethod(class,                        originalSelector,                        method_getImplementation(swizzledMethod),                        method_getTypeEncoding(swizzledMethod));        //replace canPerformAction:withSender: with mightPerformAction:withSender:        if (didAddMethod) {            class_replaceMethod(class,                                swizzledSelector,                                method_getImplementation(originalMethod),                                method_getTypeEncoding(originalMethod));        } else {            method_exchangeImplementations(originalMethod, swizzledMethod);        }    }}}</code></pre><p>最后在ViewController的viewDidLoad中调用</p><pre><code class="objc">[self replaceUIWebBrowserView:self.webView];</code></pre><blockquote><p>注意1: 在viewController中添加 #import &lt;objc/runtime.h&gt; 避免 error(Method).</p></blockquote><blockquote><p>注意2:  使用<code>NSSelectorFromString</code>方法避免审核过程中被检测到使用到了私有API.</p></blockquote><p>参考: <a href="http://stackoverflow.com/questions/25263687/disable-long-press-menu-in-text-area-input-uiwebview/25263688#25263688" target="_blank" rel="noopener">http://stackoverflow.com/questions/25263687/disable-long-press-menu-in-text-area-input-uiwebview/25263688#25263688</a> </p><h4 id="2-通过扩展类别"><a href="#2-通过扩展类别" class="headerlink" title="2.通过扩展类别"></a>2.通过扩展类别</h4><p>另外在查找资料的过程中还发现种方法(UIWebBrowserView), 但是这种方法使用到了私有api, 会被打回. 切记:<br><a href="http://www.ios-blog.co.uk/tutorials/rich-text-editing-highlighting-and-uimenucontroller-part-3/" target="_blank" rel="noopener">http://www.ios-blog.co.uk/tutorials/rich-text-editing-highlighting-and-uimenucontroller-part-3/</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -runtime -运行时 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC开发相关注意事项</title>
      <link href="/2016/10/20/OC%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%9B%9B/"/>
      <url>/2016/10/20/OC%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="第7章-熟悉系统框架"><a href="#第7章-熟悉系统框架" class="headerlink" title="第7章 熟悉系统框架"></a>第7章 熟悉系统框架</h2><p>将一系列代码封装为动态库 (dynamic library) , 并在其中放入描述其借口的头文件, 这样做出来的东西就叫 <font color="a52a2a">框架</font> .有时为 iOS 平台构建的第三方框架实用的是静态库 (static libaray), 这是因为 iOS 应用程序不允许在其中包含动态库.</p><p>开发者主要会碰到<code>Foundation</code>, 像是 <code>NSOject</code>, <code>NSArray</code>, <code>NSDictionary</code> 等类都在其中, <code>Foundation</code> 是应用程序的 “基础”.</p><p>还有个与 <code>Foundation</code> 相伴的框架, 叫做 <code>CoreFoundation</code> , 从技术上来将, <code>CoreFoundation</code> 框架不是 <code>Objective-C</code> 框架, 但它是编写 <code>Objective-C</code> 应用程序时所应熟悉的重要框架. <code>Foundation</code> 框架中的很多功能, 都可以在此框架中找到对应的 C 语言 API. 可以用”无缝桥接”(tollfree bridging). 可以吧 <code>CoreFoundation</code> 中的 C 语言数据结构平滑转换为 <code>Foundation</code>中的 Objective-C 对象.</p><p>除了<code>Foundation</code> 还有 <code>CFNetwork</code> , <code>CoreAudio</code>, <code>AVFoundation</code>, <code>CoreData</code>, <code>CoreText</code> ….</p><a id="more"></a><p><br></p><h3 id="1-构建缓存时选用-NSCache-而非-NSDictionary"><a href="#1-构建缓存时选用-NSCache-而非-NSDictionary" class="headerlink" title="1. 构建缓存时选用 NSCache 而非 NSDictionary"></a>1. 构建缓存时选用 <code>NSCache</code> 而非 <code>NSDictionary</code></h3><p>因为 <code>NSCache</code> 可以提供优雅的自动删减功能, 而且是 “线程安全的”. 此外, 它与字典不同, 不会拷贝键.<br>可以给 <code>NSCache</code> 对象设置上限, 用以限制缓存中的对象总个数及”总成本”<br>将 <code>NSPurgeableData</code> 与 <code>NSCache</code> 搭配使用, 可实现自动清除数据的功能.</p><h3 id="2-loadView-amp-initialize"><a href="#2-loadView-amp-initialize" class="headerlink" title="2. loadView &amp; initialize"></a>2. <code>loadView</code> &amp; <code>initialize</code></h3><p><code>loadView</code> &amp; <code>initialize</code> 中的代码要尽量精简.这有助于保持应用程序的响应能力, 也能减少引入 “依赖环” 的几率.</p><p><code>initialize</code>是惰性调用的, 只有当程序用到了相关的类时, 才会调用. 而对于<code>loadView</code>来说, 应用程序必须阻塞并等着所有类的 load 都执行万, 才能继续.</p><p><code>initialize</code>方法 只应该用来设置内部数据.</p><ul><li>在加载阶段, 如果类实现了 load 方法, 那么系统就会调用它. 分类里也可以定义此方法, 类的 load 方法要比分类中的先调用.</li><li>首次实用某个类之前, 系统会向其发送 <code>initialize</code> 消息. 由于此方法遵从普通的覆写规则, 所以通常应该在里面判断当前要初始化的是哪个类.</li><li>无法在编译期设定的全局常量, 可以放在 <code>initialize</code> 方法里初始化.</li></ul><h3 id="3-NSTimer-会保留其目标对象"><a href="#3-NSTimer-会保留其目标对象" class="headerlink" title="3. NSTimer 会保留其目标对象."></a>3. NSTimer 会保留其目标对象.</h3><p>记得 手动调用或 <code>delloc</code> 方法中调用</p><pre><code class="objc">[_timer invalidate];_timer = nil;</code></pre><p>反复执行任务的计时器, 很容易引入保留环.</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>快速遍历</p><pre><code>(for ... in ...) </code></pre><hr><p><br></p><p>本篇文章参考摘自 <font color="#B8860B">Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的52个有效方法</font></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC开发相关注意事项</title>
      <link href="/2016/10/19/OC%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%89/"/>
      <url>/2016/10/19/OC%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>ARC :<code>Automatic Reference Counting,ARC</code>, ARC 几乎把所有内存管理事宜都交由编译器来决定, 开发者只需专注于业务逻辑.</p><h3 id="1-引用计数"><a href="#1-引用计数" class="headerlink" title="1. 引用计数"></a>1. 引用计数</h3><p>Objective-C 语言实用引用计数来管理内存. 每个对象都有个可以递增和递减的计数器, 用以标识当前有多个事情想令此对象继续存活下去.<br>计数<font color="#A52A2a">&gt;=0</font>表示对象继续存活. 当保留计数降为<font color="#A52A2a"> 0 </font>后, 对象就会被释放了.</p><p>ARC 只负责管理 <code>Objective-C</code> 对象的内存. 注意: <font color="#A52A2a">CoreFoundation</font>对象不归 ARC 管理, 开发者必须适时调用 <font color="#A52A2a">CFRetain/CFRelease</font>.</p><h3 id="2-在-dealloc-方法中只释放引用并解除监听"><a href="#2-在-dealloc-方法中只释放引用并解除监听" class="headerlink" title="2. 在 dealloc 方法中只释放引用并解除监听"></a>2. 在 dealloc 方法中只释放引用并解除监听</h3><p>对象在经历其生命周期后, 最终会为系统所回收, 这时就要执行 <code>dealloc</code> 方法了. 在每个对象的生命周期内, 此方法仅执行以此. 也就是但保留计数降为 0 的时候.</p><p>虽说应该于 <code>dealloc</code> 中释放引用, 但是开销较大或系统内稀缺的资源则不在此列 ,像是文件描述符( file descriptor ), 套接字 (socket), 大块内存等都属于这种资源. 不能指望 <code>dealloc</code> 方法必定会在某个特定的时机调用, 因为有一些无法预料的东西可能也会持有此对象. 在这种情况下, 如果非要等到系统调用 <code>dealloc</code> 方法时才释放, 那么保留这些稀缺资源的时间就太长了, 这么做不合适. 通常的做法时, 实现另外一个方法, 但应用程序用完资源对象后, 就调用此方法 (例如 <font color="#A52A2a">Open</font> 对应 <font color="#A52A2a">Close</font> 方法) . 这样一来, 资源对象的生命期就变得更明确了.</p><a id="more"></a><h3 id="3-以-“自动释放池块”-降低内存峰值"><a href="#3-以-“自动释放池块”-降低内存峰值" class="headerlink" title="3. 以 “自动释放池块” 降低内存峰值"></a>3. 以 “自动释放池块” 降低内存峰值</h3><p>在 Objective-C 的引用计数架构中, 有一项特性叫做 “<font color="#A52A2a">自动释放池</font>“ (autorelease pool). 释放对象有两种方式: 一种时调用 <code>release</code> 方法, 另一种时调用 <code>autorelease</code> 方法, 将其降入 “自动释放池” 中. 自动释放池用于存放那些需要在稍后某个时刻释放的对象. 清空(drain)自动释放池时, 系统会向其中的对象发送 <code>release</code> 消息.</p><pre><code class="objc">@autoreleasepool{    // ...    for (int i = 0; i &lt; 100000; i++){        [self doSomethingWithInt:i];    }}</code></pre><p>使用 <font color="#A52A2a">自动释放池</font> 来降低应用程序的 <font color="#A52A2a">峰值内存</font>.</p><p><br></p><hr><h2 id="block与GCD"><a href="#block与GCD" class="headerlink" title="block与GCD"></a>block与GCD</h2><p>GCD 是一种与块有关的计数, 它提供了对线程的抽象, 而这种抽象则机遇 “派发队列”(<code>dispatch queue</code>). 开发者可将块排入队列中, 由 GCD 负责处理所有调度事宜.</p><h3 id="1-block"><a href="#1-block" class="headerlink" title="1. block"></a>1. block</h3><p>每个 Objective-C 对象都占据着某个内存区域. 因为实例变量的个数及对象所包含的关联数据不同, 所以每个对象所占的内存区域也有大有小. 块对象也是对象, 在存放块对象的内存区域中, 首个变量时指向 Class 对象的指针, 该指针叫做 <font color="A52A2A">isa</font> .其余内存里含有块对象正常运转所需的各种信息.</p><p><img src="http://ocs32tleq.bkt.clouddn.com/blockMemory.png" alt="块对象的内存布局"></p><p>在内存布局中, 最重要的时 <font color="a52a2a">invoke</font> 变量, 这是个函数指针, 指向块的实现代码. 块其实就是一种代替函数指针的语法结构.</p><p>定义块的时候, 其所占的内存是分配在 <font color="a52a2a">栈 </font>中的. 块只在定义它的那个范围有效. 编译器有可能把分配给块的内存覆写掉. 给 block 对象发送 copy 消息拷贝, 就拷贝到堆上, 块就成了带引用计数的对象了.后续的复制操作都不会真的执行复制, 只是增加对象的引用计数.</p><h3 id="2-GCD"><a href="#2-GCD" class="headerlink" title="2. GCD"></a>2. GCD</h3><p>少用 <code>performSelector</code> 系列方法, 用 GCD 相关方法来实现.</p><ul><li>通过 <code>Dispatch Group</code> 机制, 根据系统资源状况来执行任务.一系列任务可关于一个 <code>dispatch group</code> 中. 开发者可以再这组任务执行完毕时获得通知.</li></ul><p>使用下面这个函数可以创建 <code>dispatch group</code>:</p><pre><code class="objc">dispatch_group_tdispatch_group_create();</code></pre><p>另外可选 使用 <code>dispatch_apply</code> 方法, 此函数会将块仿佛执行一定的次数, 每次传给块的参数值都会递增..</p><pre><code class="objc">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIRITY_DEFAULT, 0);dispatch_apply(array.count, queue, ^(size_t i){    id object = array[i];    // ...}</code></pre><p>然而, <code>dispatch_apply</code> 会持续阻塞队列, 直到所有任务都执行完毕为止. 若想到后台执行任务, 则应使用 <code>dispatch group</code></p><p>更多内容请看我的另外一篇 : <a href="http://www.donglyu.com/2016/02/08/GCD处理多个异步处理的同步方法/" target="_blank" rel="noopener">GCD 多任务</a></p><ul><li>使用 <code>dispatch_once</code> 来执行只需运行以此的线程安全代码.<br>单例模式中使用的多.</li></ul><pre><code class="objc">+ (id)sharedInstance{    static EOCClass *sharedInstance = nil;    static dispatch_once_t onceToken;    dispatch_once(&amp;onceToken, ^{        shareInstance = [[self alloc] init];    });    return sharedInstance;}</code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li>调试内存管理问题时, 可以将 <font color="#A52A2a">NSZombieEnabled</font> 环境变量设为 YES . 给僵尸对象(应该是是否的对象, 不应再被调用) 发送消息, 控制台会打印消息, 应用程序会终止.</li></ul><hr><p><br></p><p>本篇文章参考摘自 <font color="#B8860B">Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的52个有效方法</font></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地推送之定时推送</title>
      <link href="/2016/10/18/%E6%9C%AC%E5%9C%B0%E6%8E%A8%E9%80%81%E4%B9%8B%E5%AE%9A%E6%97%B6%E6%8E%A8%E9%80%81/"/>
      <url>/2016/10/18/%E6%9C%AC%E5%9C%B0%E6%8E%A8%E9%80%81%E4%B9%8B%E5%AE%9A%E6%97%B6%E6%8E%A8%E9%80%81/</url>
      
        <content type="html"><![CDATA[<p>项目中使用到了定时提醒推送, 故整理记录下来.</p><h2 id="iOS10-之前-使用旧的本地推送注册方式"><a href="#iOS10-之前-使用旧的本地推送注册方式" class="headerlink" title="iOS10 之前, 使用旧的本地推送注册方式:"></a>iOS10 之前, 使用旧的本地推送注册方式:</h2><h3 id="1-在-AppDelegate中代理注册使用通知-和注册远程通知一致"><a href="#1-在-AppDelegate中代理注册使用通知-和注册远程通知一致" class="headerlink" title="1. 在 AppDelegate中代理注册使用通知, 和注册远程通知一致"></a>1. 在 <code>AppDelegate</code>中代理注册使用通知, 和注册远程通知一致</h3><pre><code class="objc"> UIMutableUserNotificationCategory *categorys = [[UIMutableUserNotificationCategory alloc] init]; UIUserNotificationSettings *userSettings = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeBadge|UIUserNotificationTypeSound|UIUserNotificationTypeAlert                                                                                     categories:[NSSet setWithObject:categorys]]; [[UIApplication sharedApplication] registerUserNotificationSettings:userSettings]; [[UIApplication sharedApplication] registerForRemoteNotifications];   </code></pre><a id="more"></a><h3 id="2-注册本地推送-在固定时间推送通知"><a href="#2-注册本地推送-在固定时间推送通知" class="headerlink" title="2. 注册本地推送,在固定时间推送通知"></a>2. 注册本地推送,在固定时间推送通知</h3><pre><code class="objc">+ (void)RegisterLocalNotificationiOS10Before:(NSDate *)time{    UILocalNotification *notification = [[UILocalNotification alloc] init];    // 设置触发通知的时间//    NSDate *fireDate = [NSDate dateWithTimeIntervalSinceNow:10];    notification.fireDate = time; // fireDate    // 时区    notification.timeZone = [NSTimeZone defaultTimeZone];    // 设置重复的间隔    notification.repeatInterval = kCFCalendarUnitDay; // 每天提醒.    // 通知内容    notification.alertTitle = @"时光匆匆，我只在乎你";    notification.alertBody = @"今天有什么想要记录和分享吗？";     notification.applicationIconBadgeNumber = 1;    // 通知被触发时播放的声音    notification.soundName = UILocalNotificationDefaultSoundName;    // 通知参数    NSDictionary *userDict = [NSDictionary dictionaryWithObject:LPVMNoticeEveryDayKey forKey:LPVMNoticeEveryDayKey];    notification.userInfo = userDict;    notification.repeatInterval = NSCalendarUnitDay;    // 执行通知注册    [[UIApplication sharedApplication] scheduleLocalNotification:notification];}</code></pre><h3 id="3-取消本地推送"><a href="#3-取消本地推送" class="headerlink" title="3. 取消本地推送"></a>3. 取消本地推送</h3><pre><code class="objc">+ (void)CancelLocalNotificationWithKey:(NSString *)key {    // 获取所有本地通知数组    NSArray *localNotifications = [UIApplication sharedApplication].scheduledLocalNotifications;    for (UILocalNotification *notification in localNotifications) {        NSDictionary *userInfo = notification.userInfo;                if (userInfo) {            // 根据设置通知参数时指定的key来获取通知参数            NSString *info = userInfo[key];            // 如果找到需要取消的通知，则取消            if (info != nil) {                [[UIApplication sharedApplication] cancelLocalNotification:notification];                DLog(@"移除一条注册了的本地推送");               }        }    }}</code></pre><hr><p><br></p><h2 id="iOS-10后本地定时推送"><a href="#iOS-10后本地定时推送" class="headerlink" title="iOS 10后本地定时推送"></a>iOS 10后本地定时推送</h2><h3 id="1-注册推送"><a href="#1-注册推送" class="headerlink" title="1. 注册推送"></a>1. 注册推送</h3><pre><code class="objc">+ (void)RegisterLocalNotificationiOS10Later:(NSDate *)time{    // 使用 UNUserNotificationCenter 来管理通知    UNUserNotificationCenter* center = [UNUserNotificationCenter currentNotificationCenter];    //需创建一个包含待通知内容的 UNMutableNotificationContent 对象，注意不是 UNNotificationContent ,此对象为不可变对象。    UNMutableNotificationContent* content = [[UNMutableNotificationContent alloc] init];    content.title = [NSString localizedUserNotificationStringForKey:@"时光匆匆，我只在乎你" arguments:nil];    content.body = [NSString localizedUserNotificationStringForKey:@"今天有什么想要记录和分享吗？" arguments:nil];    content.sound = [UNNotificationSound defaultSound];    content.userInfo = [NSDictionary dictionaryWithObject:LPVMNoticeEveryDayKey forKey:LPVMNoticeEveryDayKey];    // 1.在一段时间后推送本地推送    //UNTimeIntervalNotificationTrigger* trigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:10 repeats:NO];    NSDateComponents *components = [[NSDateComponents alloc] init];    NSCalendar *cal = [NSCalendar currentCalendar];    NSInteger unitFlags = NSCalendarUnitHour | NSCalendarUnitMinute;//NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit;    NSDateComponents *dd = [cal components:unitFlags fromDate:time];    components.hour = [dd hour];    components.minute = [dd minute]; // 例如每日21:00时推送    // 2. 指定日期触发    UNCalendarNotificationTrigger *trigger = [UNCalendarNotificationTrigger triggerWithDateMatchingComponents:components repeats:YES];    // 3. 根据位置触发    //CLLocationCoordinate2D cen = CLLocationCoordinate2DMake(39.990465,116.333386);    //CLRegion *region = [[CLCircularRegion alloc] initWithCenter:cen radius:100 identifier:@"center"];    //region.notifyOnEntry = YES;    //region.notifyOnExit = NO;    //UNLocationNotificationTrigger *trigger = [UNLocationNotificationTrigger triggerWithRegion:region     repeats:YES];    UNNotificationRequest* request = [UNNotificationRequest requestWithIdentifier:LPVMNoticeEveryDayKey                                                                          content:content trigger:trigger];    //添加推送成功后的处理！    [center addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) {        if (error) {            DLog(@"iOS10Later addNotification Error: %@", error);        }    }];}</code></pre><p>说明:<br>有4种触发器</p><p><code>UNPushNotificationTrigger</code> 触发APNS服务，系统自动设置（这是区分本地通知和远程通知的标识)</p><p><code>UNTimeIntervalNotificationTrigger</code> 一段时间后触发</p><p><code>UNCalendarNotificationTrigger</code> 指定日期触发</p><p><code>UNLocationNotificationTrigger</code> 根据位置触发，支持进入某地或者离开某地或者都有</p><h3 id="2-iOS10Later取消推送"><a href="#2-iOS10Later取消推送" class="headerlink" title="2. iOS10Later取消推送"></a>2. iOS10Later取消推送</h3><pre><code class="objc"> UNUserNotificationCenter* center = [UNUserNotificationCenter currentNotificationCenter];        [center removeAllPendingNotificationRequests];  // remove all at this moment.</code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>本地推送的回调, 会调用 <code>AppDeleage</code> 下的<code>application:(UIApplication *)application didReceiveLocalNotification</code>方法</p><pre><code class="objc">-(void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification{  // TO DO}</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推送 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单明了搞定 iOS 10推送适配</title>
      <link href="/2016/10/08/%E7%AE%80%E5%8D%95%E6%98%8E%E4%BA%86%E6%90%9E%E5%AE%9AiOS10%E6%8E%A8%E9%80%81%E9%80%82%E9%85%8D/"/>
      <url>/2016/10/08/%E7%AE%80%E5%8D%95%E6%98%8E%E4%BA%86%E6%90%9E%E5%AE%9AiOS10%E6%8E%A8%E9%80%81%E9%80%82%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>iOS 10 更新了后发现正式环境, 推送粗问题了.查了相关资料后, 整理了一下解决办法。 iOS 10后, 增加了<font color="#1E90FF">UNUserNotificationCenter</font>, 并且推送通知的处理要在代理方法</p><ul><li><p><font color="#A52A2A">userNotificationCenter:didReceiveNotificationResponse</font> 推送时 APP 在后台</p></li><li><p><font color="#A52A2A">userNotificationCenter:willPresentNotification</font> 推送时 APP 在前台</p></li></ul><a id="more"></a><p><br></p><h4 id="1-导入头文件"><a href="#1-导入头文件" class="headerlink" title="1. 导入头文件"></a>1. 导入头文件</h4><pre><code class="objc">#import &lt;UserNotifications/UserNotifications.h&gt;</code></pre><h4 id="2-遵守协议"><a href="#2-遵守协议" class="headerlink" title="2. 遵守协议"></a>2. 遵守协议</h4><pre><code class="objc">@interface AppDelegate ()&lt;UNUserNotificationCenterDelegate&gt;@end</code></pre><h4 id="3-在application-didFinishLaunchingWithOptions方法中注册推送。"><a href="#3-在application-didFinishLaunchingWithOptions方法中注册推送。" class="headerlink" title="3. 在application: didFinishLaunchingWithOptions方法中注册推送。"></a>3. 在<font color="#1E90FF">application: didFinishLaunchingWithOptions</font>方法中注册推送。</h4><pre><code class="objc">if (kiOS10Later) {  //iOS10 之后用UNUserNotificationCenter注册通知        UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];        center.delegate = self;        [center requestAuthorizationWithOptions:(UNAuthorizationOptionBadge | UNAuthorizationOptionSound | UNAuthorizationOptionAlert) completionHandler:^(BOOL granted, NSError * _Nullable error) {            if (!error) {                [[UIApplication sharedApplication] registerForRemoteNotifications];                NSLog(@"OK!");            }        }];    }else{ //iOS10 之前的注册通知        if ([[UIApplication sharedApplication] respondsToSelector:@selector(registerUserNotificationSettings:)]) {        UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:(UIUserNotificationTypeBadge |UIUserNotificationTypeSound |UIUserNotificationTypeAlert)                                                                                 categories:nil];        [[UIApplication sharedApplication] registerUserNotificationSettings:settings];        [[UIApplication sharedApplication] registerForRemoteNotifications];        }    }</code></pre><h4 id="4-APP-未启动-iOS10中遗弃UIApplicationLaunchOptionsRemoteNotificationKey-采用统一的方式来处理-见下一条"><a href="#4-APP-未启动-iOS10中遗弃UIApplicationLaunchOptionsRemoteNotificationKey-采用统一的方式来处理-见下一条" class="headerlink" title="4. APP 未启动, iOS10中遗弃UIApplicationLaunchOptionsRemoteNotificationKey,采用统一的方式来处理, 见下一条."></a>4. APP 未启动, iOS10中遗弃<font color="#1E90FF">UIApplicationLaunchOptionsRemoteNotificationKey</font>,采用统一的方式来处理, 见下一条.</h4><pre><code class="objc">// application: didFinishLaunchingWithOptions 中 iOS 9及以下,还是要保留以下代码 NSDictionary *remoteUserInfo = launchOptions[UIApplicationLaunchOptionsRemoteNotificationKey];      if (remoteUserInfo) {          NSLog(@"remoteUserInfo:%@",remoteUserInfo);          //APP未启动，点击推送消息，iOS10下还是跟以前一样在此获取      }  </code></pre><h4 id="5-实现接收推送消息的回调方法"><a href="#5-实现接收推送消息的回调方法" class="headerlink" title="5. 实现接收推送消息的回调方法"></a>5. 实现接收推送消息的回调方法</h4><p>iOS10之前使用<font color="#1E90FF">application: didReceiveRemoteNotification</font> 来进行回调处理，而在iOS10里则要实现用<font color="1E90FF">UNUserNotificationCenterDelegate</font>的两个代理方法： </p><blockquote><ul><li><font color="#A52A2A">userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification</font></li><li><font color="#A52A2A">userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse</font></li></ul></blockquote><pre><code class="objc">//iOS10之前 接收推送消息- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler {    Log(@"userInfo: %@", userInfo);    if ( application.applicationState == UIApplicationStateActive) {// 程序在运行过程中受到推送通知    } else { //在background状态受到推送通知    }    completionHandler(UIBackgroundFetchResultNewData);}// iOS 10之后 后台推送消息接收- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)())completionHandler{    NSDictionary *userInfo = response.notification.request.content.userInfo;    // TO DO    completionHandler(UIBackgroundFetchResultNewData);}// iOS 10之后 前台推送消息处理.- (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(nonnull UNNotification *)notification withCompletionHandler:(nonnull void (^)(UNNotificationPresentationOptions))completionHandler{    DLog(@"iOS 10 Receive Remote Notification in foreground! [willPresentNotification]");    // 可在APP 前台状态下,弹出推送弹窗    completionHandler(UNNotificationPresentationOptionAlert);}</code></pre><h4 id="6-而对于本地推送回调-和以前没有变化"><a href="#6-而对于本地推送回调-和以前没有变化" class="headerlink" title="6. 而对于本地推送回调, 和以前没有变化:"></a>6. 而对于本地推送回调, 和以前没有变化:</h4><pre><code class="objc">-(void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification{  // TO DO}</code></pre><p><br></p><h4 id="7-其他补充"><a href="#7-其他补充" class="headerlink" title="7. 其他补充"></a>7. 其他补充</h4><ul><li>对于<font color="#1E90FF">Xcode 8</font>, 默认生成的<font color="#1E90FF">XXX.entitlements</font>中的<font color="#1E90FF">APS Enviroment</font> 发布时,可以不用从development 改成 production. Xcode 在发布时会自动帮我们处理改好.</li></ul><ul><li>推送开关记得要打开;capabilities 里面<font color="#1E90FF">Background Modes–&gt;remote notification&amp;push notification</font></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS10适配 </tag>
            
            <tag> 推送 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC开发相关注意事项</title>
      <link href="/2016/09/20/OC%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%BA%8C/"/>
      <url>/2016/09/20/OC%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="接口与-API-设计"><a href="#接口与-API-设计" class="headerlink" title="接口与 API 设计"></a>接口与 API 设计</h2><p>我们在构建应用程序编写接口应考虑将其设计成易于复用的形式, 方便后续项目复用或其他模块使用. 这就需要遵守一定的编程范式, 遵守一些约定俗成的”规则”.</p><h3 id="1-用前缀避免命名空间冲突"><a href="#1-用前缀避免命名空间冲突" class="headerlink" title="1. 用前缀避免命名空间冲突"></a>1. 用前缀避免命名空间冲突</h3><p>OC 没有其他语言内置的命名空间机制. 因此在命名时设法避免潜在的命名冲突, 否则容易就重名.否则会出现类似错误:</p><pre><code class="objc">duplicate symbol _OBJC_METACLASS_$_EOCTHECLASS in:build/something.obuild/something_else.o...</code></pre><p>苹果宣称其保留使用所有”两字母前缀”(two-letter prefix)的权利,因此我们的命名前缀最好避免使用两个字母当前缀.</p><a id="more"></a><hr><h3 id="2-提供”全能初始方法”"><a href="#2-提供”全能初始方法”" class="headerlink" title="2. 提供”全能初始方法”"></a>2. 提供”全能初始方法”</h3><ul><li>在类中提供一个全能初始化方法, 并于文档中指名. 其他初始化方法均应调用此方法.</li><li>若全能初始化方法与超类不同, 则需要覆写超类中的对应方法.</li><li>如果超类的初始化方法不适用于之类, 那么应该覆写这个超类方法, 并在其中抛出异常.</li></ul><hr><h3 id="3-实现-description-方法"><a href="#3-实现-description-方法" class="headerlink" title="3. 实现 description 方法"></a>3. 实现 description 方法</h3><pre><code>NSLog(@"object = %@", object);</code></pre><p>实现 object 的 description 方法, 打印 object 中用户关心的信息.</p><ul><li>若想在调试时打印更详尽的对象描述信息, 则应实现 debugDescription 方法.</li></ul><hr><h3 id="4-尽量使用不可变对象"><a href="#4-尽量使用不可变对象" class="headerlink" title="4. 尽量使用不可变对象"></a>4. 尽量使用不可变对象</h3><p>若属性仅可以用于对象内部修改, 则在”class-continuation 分类”中将其由<code>readonly</code>属性扩展为 readwirte.<br>不要把可变的 <code>collection</code>作为属性公开, 而应时提供相关方法, 以此修改对象中的可变 <code>collection</code>.</p><hr><h3 id="5-命名方式"><a href="#5-命名方式" class="headerlink" title="5.命名方式"></a>5.命名方式</h3><p>用<code>p_</code>开头来命名私有方法. 而苹果公司用的是拿一个下划线作为前缀, 而我们最好不要用, 不然可能因为<font color="#A52A2A">动态方法派发系统(dynamic method dispatch system)</font>可能在子类中无意覆盖了方法.</p><h3 id="6-NSCopying协议"><a href="#6-NSCopying协议" class="headerlink" title="6. NSCopying协议"></a>6. NSCopying协议</h3><p>要想让自定义类支持拷贝操作, 就需要实现<font color="#A52A2A"> NSCopying</font>协议, 该协议只有一个方法:</p><pre><code class="objc">- (id)copyWithZone:(NSZone*)zone</code></pre><p>为何会出现 <code>NSZone</code> 呢? 因为以前开发程序时, 会据此把内存分成不同的”区”(<code>zone</code>), 而对象会创建在某个区里面, 而现在不用了, 每个程序只有一个<code>default zone</code></p><p>对于不可变的 <code>NSArray</code> 与可变的 <code>NSMutableArray</code> 来说, 下列关系总是成立的:</p><pre><code>- (NSMutableArray copy] =&gt; NSArray- (NSArray mutableCopy] =&gt; NSMutableArray</code></pre><p>另外, 在可变对象上调用 <code>copy</code> 方法则是会返回另外一个不可变类的实例.</p><p><br></p><hr><h2 id="协议与分类"><a href="#协议与分类" class="headerlink" title="协议与分类"></a>协议与分类</h2><p>OC 不支持多重继承, 因而我们把某个类应该实现的一系列方法定义在协议里面. 协议最为常见的用途时实现委托模式.</p><h3 id="1-委托"><a href="#1-委托" class="headerlink" title="1. 委托"></a>1. 委托</h3><p>对于需要频繁通过数据源协议从数据源中获取多份相互独立的数据, 下面的这种优化方式, 值得使用.</p><pre><code class="objc">@interface EOCNetworkFetcher(){    struct {        unsigned int didReceiveData    : 1;        unsigned int didFailWithError    : 1;        unsigned int didUpdateProgressTo : 1;        } _delegateFlags;    }@end// set Flag_delegateFlags.didReceiveData = 1;- (void)setDelegate:(id&lt;EOCNetworkFetcher&gt;)delegate{    _delegate = delegate;    _delegateFlags.didReceiveData = [delegate respondsToSelector:@selector(networkFetcher:didReceiveData:)]    ;    //...}</code></pre><p>这样就不用, 每次都去检测委托对象是否能响应给定的选择子了.</p><hr><h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h3><p>当类的实现文件过于膨胀而无法管理时, 将类分类, 提取到分别的不同的文件中区.</p><pre><code>XXX+Friendship(.h/.m)XXX+Work(.h/.m)// ...</code></pre><p>另外可以创建名为<code>Private</code>的分类.一般这个类中的方法只在类或框架内部使用.以隐藏实现细节.</p><hr><h3 id="3-通过协议提供匿名对象"><a href="#3-通过协议提供匿名对象" class="headerlink" title="3. 通过协议提供匿名对象"></a>3. 通过协议提供匿名对象</h3><p>委托就使用的了</p><pre><code>@property (nonatomic, weak) id &lt;EOCDelegate&gt; delegate;</code></pre><p>该属性的类型是<code>id&lt;EOCDelegate&gt;</code>, 所以实际上任何类的对象都能充当这一属性, 即便该类不继承自 <code>NSObject</code>, 只要遵循 <font color="#A52A2A">EOCDelegate</font> 就可以了</p><p><br></p><hr><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ol><li><p>OC 中无法将某个类标识为<font color="#A52A2A">抽象类</font>. 要想达成类似效果, 最好的方法时在那些子类必须覆写的超类方法中抛出异常.</p></li><li><p>遵循使用属性的 <code>setter</code> 方法，或通过 <code>key-path</code> 来设置：<br><code>[target setAge:30];</code> <code>[target setValue:[NSNumber numberWithInt:30] forKey:@"age"];</code> <font color="#A52A2A">KVO</font> 键值观察才能正确获得变化.</p></li></ol><hr><p><br></p><p>本篇文章参考摘自 <font color="#B8860B">Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的52个有效方法</font></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC开发相关注意事项</title>
      <link href="/2016/08/24/OC%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2016/08/24/OC%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="一些基本信息"><a href="#一些基本信息" class="headerlink" title="一些基本信息"></a>一些基本信息</h2><h3 id="1-内存相关"><a href="#1-内存相关" class="headerlink" title="1. 内存相关"></a>1. 内存相关</h3><p>分配在堆中的内存必须直接管理, 而分配在栈中的用于保存变量的内存则会在其栈弹出时自动清理.<br>    Objective-C将堆内存管理抽象出来了. 不需要用malloc及free来分配或释放对象所占内存. Objective-C运行期环境把这部分工作抽象为一套内存管理框架-“引用计数”</p><p>在OC中, 有时会遇到定义里不含*的变量, 可能会使用<code>栈空间</code>. 这些变量所保存的不是Objective-C对象, 比如CoreGraphics中的CGRect.</p><hr><h3 id="2-在类的头文件中尽量少引入其他头文件"><a href="#2-在类的头文件中尽量少引入其他头文件" class="headerlink" title="2. 在类的头文件中尽量少引入其他头文件"></a>2. 在类的头文件中尽量少引入其他头文件</h3><p>而是采用向前声明(forward declaring)<br>减少类的使用者, 所需引入的头文件数量,减少编译时间.<br>也能解决两个类互相引用的问题</p><a id="more"></a><hr><h3 id="3-多用字面量语法-少用与之等价的方法"><a href="#3-多用字面量语法-少用与之等价的方法" class="headerlink" title="3. 多用字面量语法, 少用与之等价的方法"></a>3. 多用字面量语法, 少用与之等价的方法</h3><p>字面量语法,比如:</p><pre><code class="objc">NSString *something = @"Effective Objective-C 2.0";</code></pre><pre><code class="objc">//字面数值NSNumber *someNumber = [NSNumber numberWithInt:1]; -&gt; NSNUmber *someNumber = @1;//字面量数组NSArray *animals = @[@"cat", @"dog"];// 数组中若有nil会 抛出异常.//字面量字典NSDictionary *personData = @{@"firstName" : @"Matt",@"lastName" : @"za"};//可变数组mutableArray[1] = @"dog";// 尽量通过下标操作来访问数组, 或者字典中的所对应的元素.</code></pre><hr><h3 id="4-多用类型常量-少用-define-预处理指令"><a href="#4-多用类型常量-少用-define-预处理指令" class="headerlink" title="4. 多用类型常量, 少用#define 预处理指令"></a>4. 多用类型常量, 少用#define 预处理指令</h3><pre><code class="objc">static const NSTimeInterval kAnimationDuration = 0.3;</code></pre><p>命名, 若常量局限于某”编译单元”(也就是实现文件中, implementation中),则在前面加字母k; 若常量在类之外可见, 则通常以类名为前缀.<br>尽量不要在头文件中声明预处理指令或定义常量 static const.</p><pre><code class="objc">@interface AnimatedView: UIView@endstatic const NSTimeInterval kAnimationDuration = 0.3;@implementation AnimatedView// ...@end// static修饰意味着, 该变量仅局限于此变量的编译单元(在OC语境下, 一般通常指每个类的实现文件(.m))中.如不加static, 在另一.m文件中也声明了同名变量, 会抛出常见的duplicate_symbol错误</code></pre><p>实际上, 如果一个变量既声明为static, 有声明为const, 那么编译器根本不会创建符号, 而是想#define预处理指令一样, 把所有遇到的变量都替换成常值. 不过这种方式定义的常量是带有类型信息的, 这点也相当关键.</p><ul><li>通知, 发送者和接受者都需要个外界可见的常量变量(即通知的名称).</li></ul><p>这时,此类变量需放在”全局符号表”(global symbol table)中, 以便可以在定义该变量的编译单元之外使用.</p><pre><code class="objc">// In the header fileextern NSString *const EOCStringConstant;// In the implementation fileNSString *const EOCStringConstant = @"VALUENOTIFICATION";</code></pre><p>常量定义从右至左解读,这里是”一个常量, 而这个常量是个指针, 指向一个NSString对象”<br>这里面的命名要注意谨慎, 避免名称冲突, 最好用与值相关的类名做前缀.</p><h3 id="5-用枚举表示状态、选项、状态码"><a href="#5-用枚举表示状态、选项、状态码" class="headerlink" title="5. 用枚举表示状态、选项、状态码"></a>5. 用枚举表示状态、选项、状态码</h3><pre><code class="objc">enum EOCConnectionStateConnectionState{    EOCConnectionStateDisconnected = 1,    EOCConnectionStateConnecting,    EOCConnectionStateConnected,};</code></pre><p>定义可以彼此组合的枚举. 定义的对后, 各选项之间就可通过”按位或操作符”(bitwise OR operator)来组合.</p><pre><code class="objc">enum UIViewAutoresizing {    UIViewAutoresizingNone                        = 0,    UIViewAutoresizingFlexbleLeftMargin        = 1 &lt;&lt; 0,    UIViewAutoresizingFlexbleWidth                = 1 &lt;&lt; 1,    UIViewAutoresizingFlexbleRighMargin         = 1 &lt;&lt; 2,    .....}</code></pre><ul><li>在处理枚举类型的switch语句中不要实现default分支. 这样的话, 加入新枚举之后, 编译器就会提示开发者. switch语句并未处理所有枚举.</li></ul><hr><h2 id="对象、消息、运行期"><a href="#对象、消息、运行期" class="headerlink" title="对象、消息、运行期"></a>对象、消息、运行期</h2><h3 id="6-理解属性这一概念"><a href="#6-理解属性这一概念" class="headerlink" title="6.理解属性这一概念"></a>6.理解属性这一概念</h3><p>属性用来通过存取放方法来访问实例变量, 是OC提供的一个简洁方便管理的抽象机制. @property语法. 如果用了这些属性了, 编译器会自动编写访问这些属性所需的方法, 次过程叫”自动合成”(autosynthesis),并添加对应的实例变量. 也可以在类的实现代码里通过<code>@synthesize</code>语法来指定实例变量的名字</p><pre><code class="objc">@implementaion EOCPerson@synthesize fireName = _myFirstname;@synthesize lastName = _myLastName;@end</code></pre><p>可通过<code>@dynamic</code>关键字来告诉编译器不要自动创建实现属性所用的实例变量和存取方法.</p><p>修饰属性的特质关键字</p><ul><li>weak 表明定义了一种”非拥有关系”. 为这种属性设置新值时, 设置方法既不保留新值, 也不释放旧值. 当属性所指的对象遭到销毁时, 属性值也会清空(nil).</li><li>unsafe_unretained 该特质的语义表达一种”非拥有关系”, 当目标对象遭到销毁时, 属性值不会自动清空(unsafe), 这一点和weak不同.</li><li>在iOS程序是, 应用nonatomic属性, 避免影响性能</li></ul><p><br></p><hr><h3 id="7-在对对象内部尽量直接访问实例变量"><a href="#7-在对对象内部尽量直接访问实例变量" class="headerlink" title="7. 在对对象内部尽量直接访问实例变量"></a>7. 在对对象内部尽量直接访问实例变量</h3><p>直接访问实例变量, 速度会快一点, 但是对一个声明的copy的属性, 那么并不会拷贝该属性, 只会保留新值并释放旧值. 也不能触发”键值观察”(KVO), 一般比较折中的方式是写入实例变量时, 通过其”设置方法”来做, 而在读取实例变量是, 则直接访问.<br>注意的地方:<br>在初始化方法中应该如何设置属性值, 这种情况总是应该直接访问实例变量, 因为子类可能overide重写了设置方法.</p><p>对于懒加载或者说惰性初始化(lazy initialization)来说,就必须通过存取方法来访问属性.</p><p><br></p><hr><h3 id="8-理解”对象等同性”"><a href="#8-理解”对象等同性”" class="headerlink" title="8. 理解”对象等同性”"></a>8. 理解”对象等同性”</h3><p>有时,按照==操作符比较出来的结果未必是我们想要的, 该操作比较的是两个指针本身, 而不是所指的对象. 应该使用NSObject协议中声明的<code>isEqual</code><br>NSObject协议中有两个用于判断等同性的关键方法:</p><pre><code class="objc">- (BOOL)isEqual:(id)object;- (NSUInteger)hash;</code></pre><ul><li><p>若想检测对象的等同性, 请提供<code>isEqual:</code>与<code>hash</code>方法.</p></li><li><p>相同的对象必须具有相同的哈希码, 但两个哈希码相同的对象却未必相同.</p></li><li><p>编写hash方法时, 应该使用计算速度快而且哈希码碰撞几率低的算法.</p></li></ul><p><br></p><hr><h3 id="9-以”类族模式”隐藏实现细节"><a href="#9-以”类族模式”隐藏实现细节" class="headerlink" title="9.以”类族模式”隐藏实现细节."></a>9.以”类族模式”隐藏实现细节.</h3><p>类方法(也叫类别方法)<br>类族模式可以把实现细节隐藏在一套简单的公共接口后面.</p><p>系统框架中经常使用类族(NSArray)</p><p><br></p><hr><h3 id="11-理解objc-msgSend的作用"><a href="#11-理解objc-msgSend的作用" class="headerlink" title="11. 理解objc_msgSend的作用"></a>11. 理解objc_msgSend的作用</h3><p>传递消息, C语言使用静态绑定(static binding), 在编译期内就能决定运行时所应调用的函数.函数地址实际上是硬编码在指令之中的.</p><p>so 对应的有动态绑定, 在OC中, 如果向某对象传递消息, 那就会使用动态绑定机制来决定需要调用的方法.</p><ul><li>给某对象”发送消息”(invoke a message)也就相当于在该对象上”调用方法”(call a method)</li><li>发给某对象的全部消息都要由”动态消息派发系统”(dynamic message dispatch system)来处理, 该系统会查处对应的方法, 并执行其代码.</li></ul><p><br></p><hr><h3 id="12-理解消息转发机制"><a href="#12-理解消息转发机制" class="headerlink" title="12. 理解消息转发机制"></a>12. 理解消息转发机制</h3><ul><li>若对象无法响应某个选择子, 则进入消息转发流程.</li><li>通过运行期的动态方法解析功能, 我们可以在需要用到某个方法时再讲其加入类中.</li><li>对象可以把其无法解读的某些选择子转交给其他对象来处理.</li><li>经过上述两步后, 如果还是没有办法处理选择子, 那就启动完整的消息转发机制.</li></ul><p><br></p><hr><h3 id="14-理解”类对象”的用意"><a href="#14-理解”类对象”的用意" class="headerlink" title="14. 理解”类对象”的用意"></a>14. 理解”类对象”的用意</h3><p>OC 有个特殊类型 <font color="#00fffff">id</font> 指代任意的 OC 对象类型. 一般情况下,消息转发给了 此 id 的对象, 但不知其具体类型是否能响应. 我们知道如果向某明确类型发送了无法解读的消息, 那么就会产生警告信息, 而 <font color="#00fffff">id</font>类型让编译器假定其能响应所有消息, 留待后续”在运行期检视对象类型”,看是否能够响应其方法.</p><ul><li>每个实例都有一个指向 Class 对象的指针, 用以表明其类型, 而这些 Class 对象则构成了类的继承体系.</li><li>如果对象类型无法在编译期确定,那么久应该实用类型信息查询方法来判断 <code>isKindOfClass</code>…</li><li>尽量实用类型信息查询方法来确定对象类型, 而不要直接比较类对象, 因为某些对象可能实现了消息转发功能.</li></ul><hr><p><br></p><p>本篇文章参考摘自 <font color="#B8860B">Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的52个有效方法</font></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整理下Swift与Objective-C的一些不同</title>
      <link href="/2016/08/23/%E7%AE%80%E5%8D%95%E6%95%B4%E7%90%86Swift%E4%B8%8EObjective-C%E7%9A%84%E4%B8%8D%E5%90%8C/"/>
      <url>/2016/08/23/%E7%AE%80%E5%8D%95%E6%95%B4%E7%90%86Swift%E4%B8%8EObjective-C%E7%9A%84%E4%B8%8D%E5%90%8C/</url>
      
        <content type="html"><![CDATA[<p>在OC中对代码进行逻辑组织用的是#pragma mark - , 生成分割线<br>而在swift中有了一些新的语法<br>如: <code>//MARK:</code> <code>//FIXME</code> <code>TODO:</code></p><p><code>//MARK: -</code> 生成分割线</p><p><code>//MARK:</code> 说明</p><a id="more"></a><ul><li>Swift中对类进行扩展<br>OC中采用的是分类, 而Swift中没有分类, 相对应的只有扩展(<code>Extensions</code>)<br>以UIView为例 , 新建UIView+Ext.swift</li></ul><pre><code class="objc">import Foundationimport UIKitextension UIView {    public var x: CGFloat{        get{            return self.frame.origin.x        }        set{            var r = self.frame            r.origin.x = newValue            self.frame = r        }    }    // ....}</code></pre><hr><h2 id="ChangeLog"><a href="#ChangeLog" class="headerlink" title="ChangeLog"></a>ChangeLog</h2><p>2016-12-3 区别太多，放弃，当新学一门语言吧，感觉还快些，😄。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阶段总结</title>
      <link href="/2016/08/23/%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/"/>
      <url>/2016/08/23/%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>8月</p><p>Swift还是在学习中,可能会搁置一段时间. 基本语法是了解了, 在了解过程也发现某些语法确实和看到的资料不同, 有人开玩笑说, 每过一段时间就好像是学一门新的语言.😁</p><a id="more"></a><p>但是以目前的Swift语言的状态来说, 确实不太适合作为某些公司的主力开发语言<br>因此之后的比例会减少, 继续OC.</p><p>Swift包括网络库等等, 都要熟悉, 头疼.<br>后续会抽空更新Swift语言的相关知识整理, 也是方便自己之后的查阅~~. </p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Photos Framework记录</title>
      <link href="/2016/08/22/Photos%20Framework%E8%AE%B0%E5%BD%95/"/>
      <url>/2016/08/22/Photos%20Framework%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>几个概念是接触Photos需要了解的.</p><h2 id="1-PHAsset-、PHAssetCollection、PHCollectionList"><a href="#1-PHAsset-、PHAssetCollection、PHCollectionList" class="headerlink" title="1. PHAsset 、PHAssetCollection、PHCollectionList"></a>1. PHAsset 、PHAssetCollection、PHCollectionList</h2><p><strong>PHAsset</strong> 、<strong>PHAssetCollection</strong>、<strong>PHCollectionList</strong> 是Photos框架中的模型类，PHAsset类是数据模型，描述图片或者视频文件数据；PHAssetCollection描述了包括相册、moments、智能相册以及共享照片流等一系列图片或者视频文件的集合的元数据；PHCollectionList是一组资源集合，可能是一组Assets，也可能是一组collection<br><br></p><h3 id="1-1-PHAsset-存储获取图片和视频文件的元数据"><a href="#1-1-PHAsset-存储获取图片和视频文件的元数据" class="headerlink" title="1.1 PHAsset: 存储获取图片和视频文件的元数据."></a>1.1 PHAsset: <strong>存储获取图片和视频文件的元数据.</strong></h3><p>这些图片和视频文件可能在手机内, 或者只存在iCloud(当开启了iCloud照片图片功能上传到iCloud了)中,<br>相比以前的ALAsset,提供了更多的资源信息.</p><p>有几个要点</p><blockquote><ul><li>需要使用[PHAsset fetchAsset…]系列类方法获取.</li><li>PHAsset对象只包含原数据, 不包含图片或视频的数据. 要图片和视频数据, 需要使用PHImageManager加载<a id="more"></a></li></ul></blockquote><p>重要的属性:</p><blockquote><ul><li><code>mediaType</code> : 资源类型  图片/音频/视频</li><li><code>mediaSubtypes</code> : 全景图、HDR图片、屏幕截图、live Photo</li><li><code>Favorite</code> : 标记资源是否被用户标为”收藏”</li><li><code>hidden</code> : 是否被用户设置为隐藏</li><li><code>representsBurst</code> 和 <code>burstSelectionTypes</code>: 对于一个资源，如果其 PHAsset 的 representsBurst 属性为 true，则表示这个资源是一系列连拍照片中的代表照片 (多张照片是在用户按住快门时拍摄的)。它还有一个属性是 burstIdentifier，如果想要获取连拍照片中的剩余的其他照片，可以通过将这个值传入 fetchAssetsWithBurstIdentifier(…) 方法来获取。用户可以在连拍的照片中做标记；此外，系统也会自动用各种试探来标记用户可能会选择的潜在代表照片。这个元数据是可以通过 PHAsset 的 burstSelectionTypes 属性来访问。这个属性是用三个常量组成的位掩码：.UserPick 表示用户手动标记的资源，.AutoPick 表示用户可能标记的潜在资源，.None 表示没有标记的资源。</li></ul></blockquote><p><br></p><ul><li><code>sourceType</code> : 资源可以来源于用户相册、iCloud、iTunes同步</li></ul><pre><code class="objc">PHAssetSourceTypeNone, PHAssetSourceTypeUserLibrary,PHAssetSOurceTypeCloudShared,PHAssetSourceTypeiTunesSynced</code></pre><ul><li>localIdentifier</li></ul><p>Photos框架中的根类PHObject只有一个公开接口localIdentifier, 是对象的<em>唯一标识符</em>.PHObject实现了<code>-isEqual</code>和<code>-hash</code>方法. 可以直接使用localIdentifier属性对PHObject及其子类迭代进行对比</p><h3 id="1-2-PHAssetCollection"><a href="#1-2-PHAssetCollection" class="headerlink" title="1.2 PHAssetCollection"></a>1.2 PHAssetCollection</h3><p>PHAssetColletion是一组有序的资源集合, 包含相册,智能相册,照片流等等.<br><br><br><br></p><h3 id="1-3-PHCollectionList"><a href="#1-3-PHCollectionList" class="headerlink" title="1.3 PHCollectionList"></a>1.3 PHCollectionList</h3><p>一组有序的资源集合的集合</p><h2 id="2-获取数据"><a href="#2-获取数据" class="headerlink" title="2. 获取数据"></a>2. 获取数据</h2><p>PHAsset 、PHAssetCollection、PHCollectionList</p><h3 id="2-1-PHAsset获取PHAsset的类方法"><a href="#2-1-PHAsset获取PHAsset的类方法" class="headerlink" title="2.1 PHAsset获取PHAsset的类方法"></a>2.1 PHAsset获取PHAsset的类方法</h3><pre><code class="objc">+ fetchAssetsInAssetCollection:options:+ fetchAssetsWithMediaType:options:+ fetchAssetsWithLocalIdentifiers:options:+ fetchKeyAssetsInAssetCollection:options:+ fetchAssetsWithOptions:+ fetchAssetsWithBurstIdentifier:options:+ fetchAssetsWithALAssetURLs:options:</code></pre><ul><li>PHFetchOptions</li></ul><p>1-predicate: 选择的约束条件</p><p>2-sortDescriptors 对结果进行排序</p><p>3-includeHiddenAssets 获取结果是否包含被隐藏的资源</p><p>4-includeAllBurstAssets 获取结果是否包含联排资源</p><p>属性: </p><blockquote><ol><li>predicate: 选择的约束条件</li><li>sortDescriptors 对结果进行排序</li><li>includeHiddenAssets 获取结果是否包含被隐藏的资源</li><li>includeAllBurstAssets 获取结果是否包含连拍资源</li></ol></blockquote><p>示例:</p><pre><code class="objc">PHFetchOptions *options = [[PHFetchOptions alloc] init];options.wantsIncrementalChangeDetails = YES;options.includeAllBurstAssets = YES;options.includeHiddenAssets = YES;// 只取图片options.predicate = [NSPredicate predicateWithFormat:@"mediaType == %d",PHAssetMediaTypeImage];// 按时间排序options.sortDescriptors = @[[NSSortDescriptor sortDescriptorWithKey:@"creationDate" ascending:YES]];PHFetchResult *albums = [PHAssetCollection fetchAssetCollectionsWithType:PHAssetCollectionTypeSmartAlbum subtype:PHAssetCollectionSubtypeSmartAlbumAllHidden options:nil];</code></pre><ul><li>PHFetchResult</li></ul><p>类似数组, 存储获取到的asset对象集合.<br>操作方式也和NSArray数组类似</p><h2 id="3-修改数据-写入相册"><a href="#3-修改数据-写入相册" class="headerlink" title="3. 修改数据, 写入相册"></a>3. 修改数据, 写入相册</h2><p>// …. 待写</p><h3 id="3-1-PHPhotoLibrary"><a href="#3-1-PHPhotoLibrary" class="headerlink" title="3.1 PHPhotoLibrary"></a>3.1 PHPhotoLibrary</h3><p>系统中PHPhotoLibrary单例对象 是用来维护用户照片库。当我们需要编辑资源对象元数据、资源内容、或者插入新的资源对象等，都可以借助通过PHPhotoLibrary单例对象执行block，block中创建我们指定的请求对象(比如PHAssetChangeRequest,PHAssetCollectionChangeRequest, PHCollectionListChangeRequest的对象)。photoLibraryDidChange(changeInfo: PHChange!)中进行.</p><p><br></p><h2 id="4-请求图片数据"><a href="#4-请求图片数据" class="headerlink" title="4 请求图片数据"></a>4 请求图片数据</h2><h3 id="4-1-PHImageManager"><a href="#4-1-PHImageManager" class="headerlink" title="4.1 PHImageManager"></a>4.1 PHImageManager</h3><p>请求图片主要用了<code>PHImageManager</code>, <code>[PHImageManager defaultManager]</code>其提供了加载图片和视频的方法</p><pre><code class="objc">// 请求图片- requestImageForAsset:targetSize:contentMode:options:resultHandler:- requestImageDataForAsset:options:resultHandler:// 请求视频- requestPlayerItemForVideo:options:resultHandler:- requestExportSessionForVideo:options:exportPreset:resultHandler:- requestAVAssetForVideo:options:resultHandler:</code></pre><p><br></p><h3 id="4-2-请求图片"><a href="#4-2-请求图片" class="headerlink" title="4.2 请求图片"></a>4.2 请求图片</h3><pre><code class="objc">static PHImageRequestID requestID = -1;    CGFloat scale = [UIScreen mainScreen].scale;    CGFloat width = MIN([UIScreen mainScreen].bounds.size.width, 500);    if (requestID &gt;= 1 &amp;&amp; size.width / width == scale) {        [[PHCachingImageManager defaultManager] cancelImageRequest:requestID];    }    PHImageRequestOptions *option = [[PHImageRequestOptions alloc] init];    option.deliveryMode = PHImageRequestOptionsDeliveryModeOpportunistic;    //    option.resizeMode = PHImageRequestOptionsResizeModeFast;    option.resizeMode = resizeMode;    requestID = [[PHCachingImageManager defaultManager] requestImageForAsset:asset targetSize:size contentMode:PHImageContentModeAspectFill options:option resultHandler:^(UIImage * _Nullable result, NSDictionary * _Nullable info) {        if (![[info objectForKey:PHImageResultIsDegradedKey] boolValue]) {            dispatch_async(dispatch_get_main_queue(), ^{                completion(result,info);            });        }    }];</code></pre><p>  其中需要注意的是：该方法在默认情况下是异步执行的，而且 Photos 库可能会多次执行 resultHandler 块，因为这种情况就是图像需要从 iCloud 中下载的情况。在 requestImageForAsset 返回的内容中，一开始的那一次请求中会返回一个小尺寸的图像版本，当高清图像还在下载时，开发者可以首先给用户展示这个低清的图像版本，然后 block 在多次调用后，最终会返回高清的原图。至于当前返回的图像是哪个版本的图像，可以通过 block 返回的 NSDictionary info 中获知，PHImageResultIsDegradedKey 表示当前返回的 UIImage 是低清图。所以需要判断一下是否是已获取到我们需要的图片。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Photos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的mvp,mvvm理解</title>
      <link href="/2016/03/25/%E6%88%91%E7%9A%84mvp_mvvm%E7%90%86%E8%A7%A3/"/>
      <url>/2016/03/25/%E6%88%91%E7%9A%84mvp_mvvm%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>控制器Controller是app的“胶水代码”：协调模型和视图之间的所有交互, 过于臃肿。而作为对比的 Model过于轻量级. 等等原因, 原本的mvc缺陷体现</p><h5 id="mvvm"><a href="#mvvm" class="headerlink" title="mvvm"></a>mvvm</h5><p>Model-View-ViewModel<br>在mvvm中, view和view controller正式联系在一起, 可以视为一个组件,<br>视图view仍然不能直接引用模型model, controller也不能.但能引用视图模型view Model<br>view Model适合放置用户输入验证逻辑,视图显示逻辑, 发起网络请求和其他各种各种的代码.<br>刚开始使用mvvm的最好方式, 可以可将一小部分逻辑放入视图模型, 然后当你逐渐习惯于使用这个范式的时候再迁移.</p><h5 id="mvp"><a href="#mvp" class="headerlink" title="mvp"></a>mvp</h5><p>M: 逻辑Model层<br>V: 视图层<br>P: protocol协议层</p><p>Model层类似  MVVM的viewModel, 主要负责存储抽象逻辑数据, 另外Model还有部分工作实现对应的协议层协议. 提供协议对应的各种属性以及服务.</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mvp mvvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CocoaPods安装和使用</title>
      <link href="/2016/03/08/CocoaPods%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2016/03/08/CocoaPods%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>  CocoaPods应该是iOS和Mac开发中最常用最有名的类库管理工具了，这篇就来整理下CocoaPods的安装和使用。<br>如果pod update pod Setup慢 请直接跳到 <font color="10d3c4"><b>标题2.4</b></font></p><h2 id="一-CocoaPods安装"><a href="#一-CocoaPods安装" class="headerlink" title="一. CocoaPods安装:"></a>一. CocoaPods安装:</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>  cocoaPods是用 Ruby 实现的, 要想使用它就需要有 Ruby 环境, 幸运的是OS X 系统默认支持 Ruby, 打开终端输入命令安装 cocoaPods</p><pre><code class="ruby">$ sudo gem install -n /usr/local/bin cocoapods</code></pre><p>  CocoaPods是以Ruby gem包的形式被安装的。在安装执行的过程中，可能会问我们是不是更新rake，输入y即可。这是因为rake gem包会在安装的过程中检查更细，如果有可用的新版本就会出现刚才的选项。<br>在安装进程结束的时候，执行命令：</p><pre><code class="ruby">$ pod setup  </code></pre><p>如果没有报错，就说明一切安装就成功了！<br><br></p><a id="more"></a><h3 id="2-安装中可能遇到的问题"><a href="#2-安装中可能遇到的问题" class="headerlink" title="2. 安装中可能遇到的问题:"></a>2. 安装中可能遇到的问题:</h3><h4 id="2-1-gem-install-cocoapods-命令半天后没反应"><a href="#2-1-gem-install-cocoapods-命令半天后没反应" class="headerlink" title="2.1 gem install cocoapods 命令半天后没反应"></a>2.1 gem install cocoapods 命令半天后没反应</h4><ol><li><p>首先可使用代理, 继续安装</p><p><del>2. 用淘宝的RubyGems镜像来代替官方版</del> (已经不维护了，文章更新于2016-11-24)</p><p>执行以下代码:</p></li></ol><pre><code class="ruby">gem sources --remove https://rubygems.org/# gem sources -a http://ruby.taobao.org/gem sources --add https://gems.ruby-china.org/gem sources -l</code></pre><h4 id="2-2-gem版本过老"><a href="#2-2-gem版本过老" class="headerlink" title="2.2 gem版本过老"></a>2.2 gem版本过老</h4><p>  gem是管理Ruby库和程序的标准包，如果它的版本过低也可能导致安装失败，解决方案自然是升级gem，执行下述命令即可：</p><pre><code class="ruby">$ sudo gem update --system  </code></pre><h4 id="2-3-pod-setup-后卡住半天不反应"><a href="#2-3-pod-setup-后卡住半天不反应" class="headerlink" title="2.3 pod setup 后卡住半天不反应"></a>2.3 pod setup 后卡住半天不反应</h4><p>  实际上, 这时也并非真的卡住了, 只是pod 在安装第三方库的索引目录(200MB+++, 较大容易下载出错).因此有如下方法解决</p><p>1 ) 手动下载索引</p><ol><li>前往<a href="https://github.com/CocoaPods/Specs" target="_blank" rel="noopener">https://github.com/CocoaPods/Specs</a> 下载该索引. (可通过 GitHub Desktop 下载)</li><li>Specs 文件夹更名<code>master</code>然后拷进repos文件夹下[目录在<code>/Users/用户名/.cocoapods/repos</code>]</li><li>完全退出终端，重启终端，pod功能即可正常使用。</li></ol><p>解释：pod setup的本质就是将<code>https://github.com/CocoaPods/Specs上的Specs</code>项目clone到<code>/Users/用户名/.cocoapods/repos</code>目录下。若此目录下已有Specs项目，则会将项目更新到最新的状态。由于Specs很大，容易导致pod setup失败。这时就需要我们手动安装Specs。若直接从github上下载zip文件，由于缺少git文件，会导致cocoa pods不使用。若用git clone，由于文件过大，容易导致失败。但是使用GitHub Desktop软件，则会提高clone的成功率，并且会给出clone的进度, 也可以手动切换到目标目录下, 查看具体下载的文件大小。</p><p>2 ) Pod install 或 pod update 很慢时, 可以使用下面两句来更新. 表示忽略升级 specs 库 [此条适合在已有库, 但未更新的情况]</p><p>实际上这两条命令是取消了repo的更新，从而变快了pod的速度。但是，假如开发者本地的repo真的已经过时了（就是第三方的地址list有点旧旧的），则无法逃避repo的更新，所以使用还是要pod repo update，依然是慢的不能忍。</p><p>所以，此处需要对pod的source换源<br>有大神提供了几个镜像，使用如下方法换掉repo的源</p><p>3 ) pod repo 换源</p><pre><code class="ruby">$ pod repo</code></pre><p>会出现以下的字眼:</p><pre><code class="ruby">master- Type: git (master)- URL:  https://github.com/CocoaPods/Specs.git- Path: /Users/donglyu/.cocoapods/repos/master</code></pre><p>  这个repo记录着许许多多第三方库的地址，默认选择了github作为源，假如开发者需要升级repo，实际上就是从github上面把一个庞大无比的地址list克隆到本地一个叫什么 .CocoaPods之类的隐藏文件夹里面。<br>通过下面的方法替换掉源</p><pre><code class="ruby">$ pod repo remove master$ pod repo add master https://git.coding.net/hging/Specs.git $ pod repo update</code></pre><p>目前可选源举例:<br><code>source 'https://git.coding.net/hging/Specs.git '</code><br>此条不可用的话,可以再找找其他常见的Git托管站.<br>完成了上述两处地方更改之后，就可以直接使用了.</p><pre><code class="ruby">$ pod install$ pod update</code></pre><p>如果换源方法不成功或者setup 不成功<br>出现 <code>[!] To setup the master specs repo, please run pod setup.</code>, 请采用以下方法.</p><pre><code class="ruby">git clone https://git.coding.net/CocoaPods/Specs.git ~/.cocoapods/repos/masterpod setup  //务必在手动下载代码后执行一次,执行后 Setup completed//再执行pod install --verbose --no-repo-update //避免去更新了</code></pre><p><font color="#A52A2A">注意:</font><br>每次编写的<code>Podfile</code> 中文件中都要以你换的源开头</p><pre><code>source 'https://git.coding.net/hging/Specs.git'platform :ios, '8.0'// ...</code></pre><p><br></p><h2 id="2-4-附"><a href="#2-4-附" class="headerlink" title="2.4 附:"></a>2.4 附:</h2><p>  用了这么久, 个人觉得最好的方式, 也是目前使用的方式:<br>解决pod setup pod update 时, 下载速度很慢. 且又没有vpn或ss代理的情况: </p><p>其实主要慢的原因是因为会去官方github源更新将近200M+++的repo , 不然无法<code>pod setup</code></p><p>好消息是国内由github的repo的镜像源 (<a href="http://git.coding.net/hging/Specs.git" target="_blank" rel="noopener">coding.net</a>). 只不过做一步移花接木<br>打开终端: 输入</p><pre><code class="ruby">cd /Users/[你的用户名]/.cocoapods/reposgit clone git://git.coding.net/hging/Specs.git masterpod setup# 然后 cd 到工程中, pod update</code></pre><p>如此 每次更新repo 这样操作.<br>配合</p><pre><code class="ruby">pod install --verbose --no-repo-update </code></pre><p>使用.</p><hr><p><br></p><h2 id="二-使用-CocoaPods"><a href="#二-使用-CocoaPods" class="headerlink" title="二. 使用 CocoaPods"></a>二. 使用 CocoaPods</h2><p>命令行中输入:</p><pre><code class="ruby">pod search JSONKittouch Podfileopen -e Podfileplatform :iospod 'JSONKit', '~&gt; 1.5pre'pod install</code></pre><ul><li>Podfile中具体内容 :</li></ul><pre><code class="ruby">platform :iosplatform:ios, '8.0'target 'XXXTarget' do    pod 'AFNetworking'    pod 'Masonry'end</code></pre><p>一些说明: </p><pre><code>pod ‘AFNetworking’      //不显式指定依赖库版本，表示每次都获取最新版本pod ‘AFNetworking’,  ‘2.0’     //只使用2.0版本pod ‘AFNetworking’, ‘&gt;2.0′     //使用高于2.0的版本pod ‘AFNetworking’, ‘&gt;=2.0′     //使用大于或等于2.0的版本pod ‘AFNetworking’, ‘&lt;2.0′     //使用小于2.0的版本pod ‘AFNetworking’, ‘&lt;=2.0′     //使用小于或等于2.0的版本pod ‘AFNetworking’, ‘~&gt;0.1.2′     //使用大于等于0.1.2但小于0.2的版本，相当于&gt;=0.1.2并且&lt;0.2.0pod ‘AFNetworking’, ‘~&gt;0.1′     //使用大于等于0.1但小于1.0的版本pod ‘AFNetworking’, ‘~&gt;0′ //高于0的版本，写这个限制和什么都不写是一个效果，都表示使用最新版本</code></pre><p>当发现无法引入库时, 尝试下面这个方法<br>可以在target-Build Settings下修改“User Header Search Paths”项，新增<code>${SRCROOT}</code>并选择<code>rcursive</code></p><p><br></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocoaPods </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCD处理多个异步处理的同步方法</title>
      <link href="/2016/02/08/GCD%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95/"/>
      <url>/2016/02/08/GCD%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h4 id="1-并行队列中执行任务-并在并行队列中加入多个串行队列"><a href="#1-并行队列中执行任务-并在并行队列中加入多个串行队列" class="headerlink" title="1.并行队列中执行任务, 并在并行队列中加入多个串行队列"></a>1.并行队列中执行任务, 并在并行队列中加入多个串行队列</h4><pre><code class="objc">dispatch_group_t group = dispatch_group_create();// Start the first servicedispatch_group_enter(group);[self.configService startWithCompletion:^(ConfigResponse *results, NSError* error){    // Do something with the results    configError = error;    dispatch_group_leave(group);}];// Start the second servicedispatch_group_enter(group);//异步操作(网络请求等)[self.preferenceService startWithCompletion:^(PreferenceResponse *results, NSError* error){    // Do something with the results    preferenceError = error;    dispatch_group_leave(group);}];// 监视队列中的任务都结束后, 汇总结果dispatch_group_notify(group,dispatch_get_main_queue(),^{    // Assess any errors    NSError *overallError = nil;    if (configError || preferenceError)    {        // Either make a new error or assign one of them to the overall error        overallError = configError ?: preferenceError;    }    // Now call the final completion block    completion(overallError);});</code></pre><a id="more"></a><h4 id="2-信号量"><a href="#2-信号量" class="headerlink" title="2. 信号量"></a>2. 信号量</h4><pre><code class="objc">// 在创建信号量后, block中方法执行完后才会接着执行dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);        dispatch_queue_t queue = dispatch_queue_create("MJPhotoBrowserForAsset", DISPATCH_QUEUE_SERIAL);        dispatch_async(queue, ^{            [assetsLibrary assetForURL:mediaItem.assetURL resultBlock:^(ALAsset *asset) {                mediaItem.curAsset = asset;                photo.image = [UIImage imageWithCGImage:asset.defaultRepresentation.fullScreenImage];                dispatch_semaphore_signal(semaphore);            } failureBlock:^(NSError *error) {                mediaItem.curAsset = nil;                photo.url = [NSURL URLWithString:mediaItem.urlStr]; // 图片路径                dispatch_semaphore_signal(semaphore);            }];        });        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GCD 同步异步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UITextView,UITextField记录</title>
      <link href="/2016/02/01/UITextView,UITextField%E8%AE%B0%E5%BD%95/"/>
      <url>/2016/02/01/UITextView,UITextField%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h4 id="一-UITextView"><a href="#一-UITextView" class="headerlink" title="一.UITextView"></a>一.UITextView</h4><p>1.点击return,隐藏键盘</p><pre><code class="objc">// 实现UITextViewDelegate shouldChangeTextInRange方法-(BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString*)text {     if ([text isEqualToString:@"\n"]) {         [textView resignFirstResponder];         return NO;    }    return YES; } </code></pre><h4 id="二-UITextField"><a href="#二-UITextField" class="headerlink" title="二. UITextField"></a>二. UITextField</h4><pre><code class="objc">当你想要收回弹出的键盘时却发现平时用的resignFirstResponder和endEditing都失去作用时，应该考虑一下当前的TextField是否为第一响应者，如果不是第一响应者的话，自然下面的几个方法都没有效果，解决办法有二：1、找出当前第一响应者，然后resignFirstResponder。2、先对TextField becomeFirstResponder 然后再 resignFirstResponder 。[self.view endEditing:YES];  [self.field resignFirstResponder];  [[UIApplication sharedApplication].keyWindow endEditing:YES];  ﻿当上面的方法都无效的时候，可以考虑用下面的方法：// Presentation modes may keep the keyboard visible when not required. Default implementation affects UIModalPresentationFormSheet visibility.- (BOOL)disablesAutomaticKeyboardDismissal NS_AVAILABLE_IOS(4_3);直接return NO 就好了。</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UITextView UITextField </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给项目添加一个合适的开源许可证</title>
      <link href="/2016/01/08/%E7%BB%99%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%90%88%E9%80%82%E7%9A%84%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81/"/>
      <url>/2016/01/08/%E7%BB%99%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%90%88%E9%80%82%E7%9A%84%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<p>将项目与代码开源，可以让更多的人与你共享代码，协同合作，让产品质量更高，更加适应社会的需求。然而，这并不代表该项目是可以被随意甚至是滥用的，想要成为真正的开源项目，不是单单把源代码开放在网上即可，必须在释出的项目当中说明，其代码是以某个开源许可证 (Open Source License) 来进行许可，将特定权利赋予给用户的同时，也规范公众的利用行为，让人们正确的享受开源所带来的好处与乐趣。</p><h3 id="开源许可证是什么"><a href="#开源许可证是什么" class="headerlink" title="开源许可证是什么"></a><strong>开源许可证是什么</strong></h3><p>为了维护作者和贡献者的合法权利，保证这些软件不被一些商业机构或个人窃取，影响软件的发展，开源社区开发出了各种的开源许可协议。许可证是具有法律效应的协议，目前已有超过 70 种被开放源代码促进会 (Open Source Initiative, OSI) 通过，其中 GPL、LGPL、Apache、BSD、MIT 等是最常见的。</p><h3 id="如何选择开源许可证"><a href="#如何选择开源许可证" class="headerlink" title="如何选择开源许可证"></a><strong>如何选择开源许可证</strong></h3><p>如何在这么多的许可证中选取一个适合自己项目的呢？我们可以通过下面这张图清晰地了解：</p><p><a href="http://blog.gitcafe.com/wp-content/uploads/2015/07/bg2011050101.png" target="_blank" rel="noopener"><img src="http://blog.gitcafe.com/wp-content/uploads/2015/07/bg2011050101.png" alt="bg201105010\"></a></p><p>图片来源于阮一峰的博客。</p><p>具体而言，这几种开源许可证的特点为：</p><h4 id="GNU-Lesser-General-Public-License-LGPL"><a href="#GNU-Lesser-General-Public-License-LGPL" class="headerlink" title="GNU Lesser General Public License (LGPL)"></a><strong>GNU Lesser General Public License (LGPL)</strong></h4><p>允许商业软件通过类库引用 (link) 方式使用 LGPL 类库而不需要开源商业软件的代码，但是如果修改 LGPL 协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用 LGPL 协议。。</p><h4 id="Mozilla-Public-License-MPL"><a href="#Mozilla-Public-License-MPL" class="headerlink" title="Mozilla Public License (MPL)"></a><strong>Mozilla Public License (MPL)</strong></h4><p>除了接口程序的源代码以 MPL 许可证的形式对外许可外，源代码库中的源代码就可以不用 MPL 许可证的方式强制对外许可。</p><h4 id="GNU-General-Public-License-GPL"><a href="#GNU-General-Public-License-GPL" class="headerlink" title="GNU General Public License (GPL)"></a><strong>GNU General Public License (GPL)</strong></h4><p>可以开源或者免费地使用代码与引用、修改衍生代码，但强制修改后和衍生的代码必须在发布和销售时也必须开放源代码给用户，因此经常与闭源商业软件的商业模式有所冲突。</p><h4 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a><strong>BSD</strong></h4><p>可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布，要包含许可协议的声明，但是不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。</p><h4 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a><strong>MIT</strong></h4><p>你必须在你的发行版里包含原许可协议的声明，无论你是以二进制发布的还是以源代码发布的。</p><h4 id="Apache-Licence"><a href="#Apache-Licence" class="headerlink" title="Apache Licence"></a><strong>Apache Licence</strong></h4><p>著名的非盈利开源组织 Apache 基金会采用的协议。该协议鼓励代码共享和尊重原作者的著作权，同样允许代码修改，作为开源或者商业软件再发布。</p><p>如果要在GitHub &amp; GitCafe等平台上发布开源代码就需要添加开源许可.</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 许可证, 开源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2015, 停滞, 行进, 停滞, 行进, 快步行进的一年</title>
      <link href="/2015/12/31/2015%E5%81%9C%E6%BB%9E,%20%E8%A1%8C%E8%BF%9B,%20%E5%81%9C%E6%BB%9E,%20%E8%A1%8C%E8%BF%9B,%E5%BF%AB%E6%AD%A5%E8%A1%8C%E8%BF%9B%E7%9A%84%E4%B8%80%E5%B9%B4/"/>
      <url>/2015/12/31/2015%E5%81%9C%E6%BB%9E,%20%E8%A1%8C%E8%BF%9B,%20%E5%81%9C%E6%BB%9E,%20%E8%A1%8C%E8%BF%9B,%E5%BF%AB%E6%AD%A5%E8%A1%8C%E8%BF%9B%E7%9A%84%E4%B8%80%E5%B9%B4/</url>
      
        <content type="html"><![CDATA[<p>日历又要到翻到2016年了. 不同于上半年的玩玩耍耍过去了, 下半年更加的充实, 学的更多了, 更重要的有了明确的目标和方向了.  </p><p>越来越意识到自己的不足之处,  生活上2016希望能处理的更好, 待人处事, 沟通交流, 衣着, 形体, 感觉好多好多, 人丑多读书, 希望慢慢做到, 一步步改善, 在忘了的事, 看看希望的样子, 提醒和鞭策一下</p><p>少些时间去耍和去做无意义的事</p><p>工作上, 兴趣是最好的老师, 做iOS还是很有乐趣的. 看了很多的iOS前辈的经验, 总是有很多感触, 有冲动做一件事, 就要持续去做, done</p><p> 总是比不做, 做一半好. 有很多期望, 近几几个月的经验:拆分大的长的任务为一个个小任务, 来分别完成,真的很好使….</p><p>用好工具, 吸收和学习别人优秀的成果, 提升影响力. 工作上体现出差异性</p><p>用好github, 自己搭的blog, 这在以后是个绝好的工作敲门砖. 简书,博客园还是太小了…墙外的东西很多, 加以利用是绝好的.</p><p>思维导图要用好, 在某些时候对自身理解帮助很大.</p><p>尝试做出一些有帮助意义的具有”高感知价值的物品”</p><p>要想获得更多,得付出更多</p><p>学习一些公司愿意付钱的技术.~~~</p><p>另外, 英语!!!!!. 一方面更多的看国外开发文档, 确实很多英文资料更全, 讲的更透彻.</p><p>心里不太平静时, 听听歌,调解下.</p><p>2016, 快节奏工作学习的一年!!!! 期待</p><p><img src="http://ww3.sinaimg.cn/large/923848a3gw1ezj988mqizj20hs0hsq47.jpg" alt="http://ww3.sinaimg.cn/large/923848a3gw1ezj988mqizj20hs0hsq47.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> up </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS GCD记录</title>
      <link href="/2015/12/07/iOS-GCD%E8%AE%B0%E5%BD%95/"/>
      <url>/2015/12/07/iOS-GCD%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h4 id="GCD异步"><a href="#GCD异步" class="headerlink" title="GCD异步"></a>GCD异步</h4><pre><code class="objc">dispatch_async(dispatch_get_global_queue(0, 0), ^{    // 处理耗时操作的代码块...   // do something.//通知主线程刷新     dispatch_async(dispatch_get_main_queue(), ^{     //回调或者说是通知主线程刷新，      }); });</code></pre><a id="more"></a><p>dispatch_async开启一个异步操作，第一个参数是指定一个gcd队列，第二个参数是分配一个处理事物的程序块到该队列。 </p><p>dispatch_get_global_queue(0, 0)，指用了全局队列。 </p><p>一般来说系统本身会有3个队列。 </p><p>global_queue，current_queue,以及main_queue. </p><p>获取一个全局队列是接受两个参数，第一个是我分配的事物处理程序块队列优先级。分高低和默认，0为默认2为高，-2为低 </p><p>======</p><h4 id="GCD之并发概念"><a href="#GCD之并发概念" class="headerlink" title="GCD之并发概念:"></a>GCD之并发概念:</h4><p>异步的核心概念就是一个新线程，一个消息回调通知。 </p><p>异步解决了线程堵塞，而并发则是在异步的基础上，提高了符合特性事件的处理时间效率</p><pre><code class="objc">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{  NSURL * url = [NSURL URLWithString:@"http://avatar.csdn.net/2/C/D/1_totogo2010.jpg"];  NSData * data = [[NSData alloc]initWithContentsOfURL:url];  UIImage *image = [[UIImage alloc]initWithData:data];  if (data != nil) {      dispatch_async(dispatch_get_main_queue(), ^{          self.imageView.image = image;       });  }  });</code></pre><hr><h4 id="iOS下使用block-GCD实现异步处理"><a href="#iOS下使用block-GCD实现异步处理" class="headerlink" title="iOS下使用block+GCD实现异步处理."></a>iOS下使用block+GCD实现异步处理.</h4><p>文章原地址: <a href="http://my.oschina.net/fvmitnick/blog/185089?fromerr=xpS0DGVX" target="_blank" rel="noopener">http://my.oschina.net/fvmitnick/blog/185089?fromerr=xpS0DGVX</a></p><ul><li>因为任何对UI的操作，在iOS中实际上并不是立刻执行，只是做了个<em>标记</em>，在当前事件循环(runloop)完成后，在下一个事件循环开始前，系统根据做的标记来决定屏幕哪一块需要更新，并进行重绘.</li></ul><pre><code class="objc">//不论哪种异步方式，最后一定要有一个办法通知主线程任务已完成。具体到iOS，有若干方法可以使用，比如：// delegate, KVO, NSNotification, performSelectorOnMainThread:等。//使用KVO方式观察后台任务的结束[calcOperation addObserver:self keyPath:@"isFinished"...];- (void) observeValueForKey:keyPath ofObject:object . {  if([@"isFinished" isEqualToString:keyPath] &amp;&amp; [object isKindOfClass:[MyPICalcOperation class]]) {      // 观察到了我们想要的状态变化，即运算结束。这里我们调用回调处理结果。确保回调在主线程上进行  }}</code></pre><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a>注意事项:</h5><ol><li>UI操作必须在主线程上完成。</li><li>耗时的同步网络、同步IO、运算等操作不要在主线程上跑，以避免阻塞</li><li>一个好的程序，对任何耗时操作都要给用户提供半路取消的选择。要做到这一点，还是需要增加一些代码 </li><li>block就象一个object，也有自己的生存周期问题，也会出现类似野指针和内存泄漏的情况。如果你自己做一个基于block的异步库供别人使用，非 常容易产生循环引用的错误（对方的app class retain了你的异步库，你的异步库retain了app提供的回调block，而block中一般又通过self引用了app class本身），需要特别小心。 </li><li>假如在运算完成前用户就退出这个页面（比如回退到上一页），运算还是会进行，view controller的销毁被延后到运算结束的时候。假如不想要这个效果的话，一是要实现1中的取消机制，二是要在块中避免引用self（否则会被自动 retain）。具体看文档。</li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GCD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CoreData使用记录</title>
      <link href="/2015/12/06/CoreData%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2015/12/06/CoreData%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>Core Data是苹果针对Mac和iOS平台开发的一个框架, 通过CoreData可以在本地生成数据库sqlite,提供了ORM的功能，将对象和数据模型相互转换 . 通过Core Data管理和操作. 能够快速达到项目的存储数据的需求.<br>      CoreData优点：能够合理管理内存，避免使用sql的麻烦，高效, 由于是苹果提供的解决方案, 所以不用太过担心会有其他问题.  我的观念就是先使用上了后再考虑其他, 问题有一个就解决一个.<br>Core Data 默认使用Sqlite. 因此在沙盒Document文件夹中找到.sqlite的数据库文件. </p><p> 这里顺便提一个一个比较好用的快速打开模拟器沙盒路径的工具: <a href="https://github.com/opensim/opensim" target="_blank" rel="noopener">https://github.com/opensim/opensim</a></p><h3 id="1-使用CoreData"><a href="#1-使用CoreData" class="headerlink" title="1.使用CoreData"></a>1.使用CoreData</h3><ol><li>创建工程时, 勾选Use Core Data</li><li>手动添加, (如何要想向创建时没有选择Use Core Data<br>如果不知道该添加什么, 一个比较便捷的方法, 是直接新建一个空白工程, 勾选Use Core Data后, 对比AppDelegate.h中的代码, 然后再将多的内容添加到工程中.)</li></ol><a id="more"></a><p>添加Core Data后, 在AppDelegate.h中就有帮我们生成用于管理、存储这些模型的对象，我们可以通过添加AppDelegate头文件来使用.<br>添加Core Data后, 就是建立数据模型,说到模型, 就要提一下Core Data常用的6个对象：</p><blockquote><p>1、NSManagedObjectContext<br>管理对象，上下文，持久性存储模型对象<br>2、NSManagedObjectModel<br>被管理的数据模型，数据结构<br>3、NSPersistentStoreCoordinator<br>连接数据库的<br>4、NSManagedObject<br>被管理的数据记录<br>5、NSFetchRequest<br>数据请求<br>6、NSEntityDescription<br>表格实体结构<br>此外还需要知道.xcdatamodel文件编译后为.momd或者.mom文件  </p></blockquote><p>一.开始  </p><blockquote><p>右键添加一个Core data -&gt; Data Model(如果创建工程时, 直接勾选use core data, 会直接默认生成.xcdatamodeld).<br>选中.xcdatamodeld主要使用到了下列一些东西:<br>Entity: 实体(我们要生成的模型对象的实体, User, Car, Person等等)<br>Attributes:实体对象属性<br>ReaationShips:关系<br>Fetched Properties:</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/1106214-2fa5fda1a8bff45e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=">_<"></p><p>另外多表关联内容可以看看: <a href="http://www.jianshu.com/p/e9f3b5e0cd19" target="_blank" rel="noopener">http://www.jianshu.com/p/e9f3b5e0cd19</a></p><p>二.创建实体管理 </p><p>右键添加一个Core data -&gt; NSManagedObject subclass, 一直选择,  选中Car, Wheel.  到最后会实现<br><img src="http://upload-images.jianshu.io/upload_images/1106214-265946bce916ef5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20151206-1"></p><p>三.导入AppDelegate.h头文件, 开始管理数据库  </p><p>主要操作:</p><pre><code class="objc">//先取出coredata上下文管理者AppDelegate *appDelegate = [[UIApplication sharedApplication] delegate];NSManagedObjectContext *context = appDelegate.managedObjectContext;//1.保存新数据Car *car = [NSEntityDescription insertNewObjectForEntityForName: @"Car" inManagedObjectContext: context];car.carName = label1.text;car.carType = label2.text;[appDelegate saveContext];//2.查询数据NSError *error;NSFetchRequest *request = [NSFetchRequest new];NSEntityDescription *entity = [NSEntityDescription entityForName: @"Car" inManagedObjectContext: context];[request setEntity: entity];NSPredicate *predicate = [NSPredicate predicateWithFormat:@"carName=%@", carName];[request setPredicate:predicate];NSArray *results = [[context executeFetchRequest: request error: &amp;error] copy];for (Car *car in results) {　    NSLog(@"%@", car.carName);}//3.更新数据{NSFetchRequest** request=[[NSFetchRequest alloc] init];NSEntityDescription *car=NSEntityDescription entityForName:@"car" inManagedObjectContext:_myAppDelegate.managedObjectContext];  [request setEntity:car];///查询条件NSPredicate* predicate=[NSPredicate predicateWithFormat:@"carName==%@",@"name"]; [request setPredicate:predicate];NSError* error=nil;NSMutableArray* mutableFetchResult=[[_myAppDelegate.managedObjectContext executeFetchRequest:request error:&amp;error] mutableCopy]; if (mutableFetchResult==nil) {　NSLog(@"Error:%@",error); }NSLog(@"The count of entry: %i",[mutableFetchResult count]);   for (Car* car in mutableFetchResult) {  　car.carName = @"name1"  ;    ...    } //更新后要进行保存，否则没更新  [_myAppDelegate.managedObjectContext save:&amp;error];}  //4.删除数据    {  NSFetchRequest* request=[[NSFetchRequest alloc] init];        NSEntityDescription* car=[NSEntityDescription entityForName:@"Car" inManagedObjectContext:_myAppDelegate.managedObjectContext];        [request setEntity:car];        NSPredicate* predicate=[NSPredicate predicateWithFormat:@"carName==%@",@"name"];        [request setPredicate:predicate];        NSError* error=nil;        NSMutableArray* mutableFetchResult=[[_myAppDelegate.managedObjectContext executeFetchRequest:request error:&amp;error] mutableCopy];        if (mutableFetchResult==nil) {    　 NSLog(@"Error:%@",error);        }        NSLog(@"The count of entry: %i",[mutableFetchResult count]);        for (Car *car in mutableFetchResult) {    　　 [_myAppDelegate.managedObjectContext deleteObject:car];        }        if ([_myAppDelegate.managedObjectContext save:&amp;error]) {    　NSLog(@"Error:%@,%@",error,[error userInfo]);    　}    }</code></pre><ul><li>条件查询的更多内容, 可以查看官方文档:<br><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Predicates/Articles/pCreating.html" target="_blank" rel="noopener">https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Predicates/Articles/pCreating.html</a></li></ul><h3 id="2-NSFetchRequest-常用方法-setEntity"><a href="#2-NSFetchRequest-常用方法-setEntity" class="headerlink" title="2.NSFetchRequest 常用方法 -setEntity:"></a>2.NSFetchRequest 常用方法 -setEntity:</h3><p>设置你要查询的数据对象的类型（Entity）</p><ul><li>-setPredicate:<br>设置查询条件</li><li>-setFetchLimit:<br>设置最大查询对象数目</li><li>-setSortDescriptors:<br>设置查询结果的排序方法  </li></ul><ul><li>-setAffectedStores:<br>设置可以在哪些数据存储中查询<br>[request setFetchBatchSize:500];//从数据库里每次加载500条数据来筛选数据<br>[request setFetchOffset:sizeCount];//读取数据库的游标偏移量，从游标开始读取数据<br>sizeCount = 10;<br>[request setFetchLimit:10];//每次要取多少条数据，10就是每次从数据库读取10条数据<br>NSPredicate用于查询和过滤<br>在SQL中作为查询条件通常用WHERE，但在COREDATA中作为查询条件就可以用到NSPredicate.<br>NSPredicate 不单可以和COREDATA中的FetchRequest 配合使用。也可以与NSArray配合使用<br>一个线程用一个NSManagedObjectContext对象.<br>使用coredata 在项目中建立表，它会自己来生成数据库，而在每个表中都有它自己生成的Z_PK,Z_ENT,Z_OPT 这三个字段，<br>Z_PK     表的主键，从1开始递增， 具有唯一性<br>可以通过主键访问和获取对象的途径:</li></ul><pre><code class="objc">  NSFetchRequest* request = [[NSFetchRequest alloc] init];  request setEntity:entity];  [request setResultType:NSManagedObjectIDResultType];  [request setFetchBatchSize:20];  NSError* error = nil;  NSArray* items = [context executeFetchRequest:request error:&amp;error];  for (NSManagedObjectID* objectID in items) {  　NSManagedObject* object = [context objectWithID:objectID];      ...  }</code></pre><p>Z_ENT  表在xcdatamodel 中的索引值，如果有6个表那么它的值的区间就是[1,6 ]<br>Z_OPT  表示的是每条数据被操作的次数，初始化值为1，只要是增删改查都会加1</p><h3 id="3-其他记录"><a href="#3-其他记录" class="headerlink" title="3.其他记录"></a>3.其他记录</h3><blockquote><p>方便查阅<br>1.通过core data存储任意类型的数据:<a href="http://blog.csdn.net/likendsl/article/details/8549333" target="_blank" rel="noopener">http://blog.csdn.net/likendsl/article/details/8549333</a><br>2.多表关联时, 动态设置删除关系.:<a href="http://blog.csdn.net/fengsh998/article/details/8090111" target="_blank" rel="noopener">http://blog.csdn.net/fengsh998/article/details/8090111</a><br>3.批量操作、聚合操作、WWDC 2015新特性: <a href="http://www.cocoachina.com/ios/20150730/12785.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20150730/12785.html</a>  </p></blockquote><h3 id="4-问题记录"><a href="#4-问题记录" class="headerlink" title="4.问题记录"></a>4.问题记录</h3><blockquote><p>当查询返回数据是fault时,  可以加上这句试试:<br>[request setReturnsObjectsAsFaults:NO];</p></blockquote><p>学习记录, 难免可能会有不准确的, 多多包涵~~</p><p>End!</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> coredata </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS动画整理</title>
      <link href="/2015/11/07/iOS%E5%8A%A8%E7%94%BB%E6%95%B4%E7%90%86/"/>
      <url>/2015/11/07/iOS%E5%8A%A8%E7%94%BB%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="一-Core-Animation"><a href="#一-Core-Animation" class="headerlink" title="一. Core Animation"></a>一. Core Animation</h3><p>Core Animation (核心动画), 一组跨平台动画API, 可以再Mac OS X和iOS平台使用.<br>Core Animation 的动画执行不会阻塞主线程.<br>Core Animation 是直接作用在CALayer上的, 并非UIView.</p><h4 id="基本动画"><a href="#基本动画" class="headerlink" title="基本动画"></a>基本动画</h4><ol><li>引入头文件&lt;QuartzCore/QuartzCore.h&gt;</li><li>初始化一个CAAnimation对象.</li><li>通过给UIView的CALayer方法添加CAAnimation到CALayer中.</li></ol><p>CAAnimation是所有动画类的父类, 但不能直接实用, 应该使用它的之类.<br>常用的属性有: </p><blockquote><p>duration: 动画持续时间<br>repeatCount: 动画的重复次数<br>timingFunction: 控制动画运行的节奏</p></blockquote><p>补充: <code>CABasicAnimation</code>, <code>CAKeyframeAnimation</code>, <code>CATransition</code> , <code>CAAnimationGroup</code> 4 个子动画类<br><code>CAPropertyAnimation</code> 是 <code>CAAnimation</code> 的子类, 但是不能直接使用, 要想创建动画对象, 应该用它的两个子类: <font color="10d3c4">CABasicAnimation</font> 和 <font color="10d3c4">CAKeyframeAnimation</font>.</p><p>它由个 <font color="10d3c4">keyPath</font>属性. 可以指定CALayer的某个属性名为 keyPath, 并且对CALayer的这个属性进行修改, 达到相应的动画效果. 比如: 指定 <font color="10d3c4">@”position”</font>为keyPath, 就会修改CALayer的position属性的值, 以达到平移的动画效果.</p><a id="more"></a><p>eg:</p><pre><code class="objc">CABasicAnimation *anima=[CABasicAnimation animation];//平移anima.keyPath=@"position";//设置执行的动画anima.toValue=[NSValue valueWithCGPoint:CGPointMake(200, 300)];//设置执行动画的时间anima.duration=2.0;//设置动画执行完毕之后不删除动画anima.removedOnCompletion=NO;//设置保存动画的最新状态anima.fillMode=kCAFillModeForwards;//anima.fillMode=kCAFillModeBackwards;//设置动画的代理anima.delegate=self;//2.添加核心动画[self.customView.layer addAnimation:anima forKey:nil];</code></pre><h3 id="二-UIView封装动画"><a href="#二-UIView封装动画" class="headerlink" title="二. UIView封装动画"></a>二. UIView封装动画</h3><p>UIKit 直接将动画集成到UIView类中, 当内部的一些属性发生改变时, UIView将为这些改变提供动画支持. 但是执行动画所需要的工作由 UIView 类自动完成, 但仍要在洗碗执行动画时通知视图, So 需要将改变属性的代码放在 <font color="10d3c4">[UIView beginAnimations:nil context:nil]</font> 和 <font color="10d3c4"> [UIView commitAnimations]</font> 之间.</p><p>常见方法: </p><pre><code class="objc">+ (void)setAnimationDelegate:(id)delegate     //设置动画代理对象，当动画开始或者结束时会发消息给代理对象+ (void)setAnimationWillStartSelector:(SEL)selector   //当动画即将开始时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector+ (void)setAnimationDidStopSelector:(SEL)selector  //当动画结束时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector+ (void)setAnimationDuration:(NSTimeInterval)duration   //动画的持续时间，秒为单位+ (void)setAnimationDelay:(NSTimeInterval)delay  //动画延迟delay秒后再开始+ (void)setAnimationStartDate:(NSDate *)startDate   //动画的开始时间，默认为now+ (void)setAnimationCurve:(UIViewAnimationCurve)curve  //动画的节奏控制+ (void)setAnimationRepeatCount:(float)repeatCount  //动画的重复次数+ (void)setAnimationRepeatAutoreverses:(BOOL)repeatAutoreverses  //如果设置为YES,代表动画每次重复执行的效果会跟上一次相反+ (void)setAnimationTransition:(UIViewAnimationTransition)transition forView:(UIView *)view cache:(BOOL)cache  //设置视图view的过渡效果, transition指定过渡类型, cache设置YES代表使用视图缓存，性能较好</code></pre><p>eg:</p><pre><code class="objc">//首尾式动画[UIView beginAnimations:nil context:nil];//执行动画//设置动画执行时间[UIView setAnimationDuration:2.0];//设置代理[UIView setAnimationDelegate:self];//设置动画执行完毕调用的事件[UIView setAnimationDidStopSelector:@selector(didStopAnimation)];self.customView.center = CGPointMake(200, 300); // 更改位置[UIView commitAnimations];</code></pre><ul><li>UIView封装动画与CALayer 动画对比<br>使用 UIView和CALayer都能实现动画效果, 一般来说, 开发中用UIView封装的动画情况较多.<br>区别: <font color="a52a2a">UIView封装的动画执行完毕之后不会反弹。即如果是通过CALayer核心动画改变layer的位置状态，表面上看虽然已经改变了，但是实际上它的位置是没有改变的。</font></li></ul><h3 id="三-block-动画"><a href="#三-block-动画" class="headerlink" title="三. block 动画"></a>三. block 动画</h3><pre><code class="objc">+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion</code></pre><p>参数解析:</p><blockquote><p>duration：动画的持续时间<br>delay：动画延迟delay秒后开始<br>options：动画的节奏控制<br>animations：将改变视图属性的代码放在这个block中<br>completion：动画结束后，会自动调用这个block</p></blockquote><pre><code class="objc">[UIView animateWithDuration:4.0 // 动画时长                 animations:^{                     // code}];//...</code></pre><p>转场动画</p><pre><code class="objc">+ (void)transitionWithView:(UIView *)view duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion</code></pre><p>参数解析:</p><blockquote><p>duration：动画的持续时间<br>view：需要进行转场动画的视图<br>options：转场动画的类型<br>animations：将改变视图属性的代码放在这个block中<br>completion：动画结束后，会自动调用这个block</p></blockquote><pre><code class="objc">+ (void)transitionFromView:(UIView *)fromView toView:(UIView *)toView duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options completion:(void (^)(BOOL finished))completion</code></pre><p>方法调用完毕后，相当于执行了下面两句代码：</p><p>// 添加toView到父视图</p><p><code>[fromView.superview addSubview:toView];</code></p><p>// 把fromView从父视图中移除</p><p><code>[fromView removeFromSuperview];</code></p><p>参数解析:</p><blockquote><p>duration：动画的持续时间<br>options：转场动画的类型<br>animations：将改变视图属性的代码放在这个block中<br>completion：动画结束后，会自动调用这个block</p></blockquote><h3 id="四-关键帧动画"><a href="#四-关键帧动画" class="headerlink" title="四. 关键帧动画"></a>四. 关键帧动画</h3><p><font color="10d3c4">UIView动画</font> 已经具备高级的方法来创建动画, 而且可以更好地理解和构建动画. iOS 7后有了一个新的方法 <font color="10d3c4">animateKeyframeWithDuration</font> 的方法, 可以用它来创建更多更复杂的动画效果. 而不需要区实用核心动画(Core Animation).</p><ul><li>创建关键帧方法:</li></ul><pre><code class="objc">/** *  添加关键帧方法 * *  @param duration   动画时长 *  @param delay      动画延迟 *  @param options    动画效果选项 *  @param animations 动画执行代码 *  @param completion 动画结束执行代码 */+ (void)animateKeyframesWithDuration:(NSTimeInterval)duration                               delay:(NSTimeInterval)delay                             options:(UIViewKeyframeAnimationOptions)options                          animations:(void (^)(void))animations                          completion:(void (^)(BOOL finished))completion;</code></pre><ul><li>添加关键帧方法</li></ul><pre><code class="objc">/** *  添加关键帧 * *  @param frameStartTime 动画相对开始时间 *  @param frameDuration  动画相对持续时间 *  @param animations     动画执行代码 */+ (void)addKeyframeWithRelativeStartTime:(double)frameStartTime                        relativeDuration:(double)frameDuration                              animations:(void (^)(void))animations;</code></pre><p>以上说的相对时间，也就是说：“它们自身会根据动画总持续时长自动匹配其运行时长”。</p><p>eg:</p><pre><code class="objc">void (^keyFrameBlock)() = ^(){    // 创建颜色数组    NSArray *arrayColors = @[[UIColor orangeColor],                             [UIColor yellowColor],                             [UIColor greenColor],                             [UIColor blueColor],                             [UIColor purpleColor],                             [UIColor redColor]];    NSUInteger colorCount = [arrayColors count];    // 循环添加关键帧    for (NSUInteger i = 0; i &lt; colorCount; i++) {        [UIView addKeyframeWithRelativeStartTime:i / (CGFloat)colorCount                                relativeDuration:1 / (CGFloat)colorCount                                      animations:^{                                          [_graduallyView setBackgroundColor:arrayColors[i]];                                      }];    }};[UIView animateKeyframesWithDuration:4.0                               delay:0.0                             options:UIViewKeyframeAnimationOptionCalculationModeCubic | UIViewAnimationOptionCurveLinear                          animations:keyFrameBlock                          completion:^(BOOL finished) {                              // 动画完成后执行                              // code...                          }];</code></pre><h3 id="五-UIImageView的帧动画"><a href="#五-UIImageView的帧动画" class="headerlink" title="五. UIImageView的帧动画"></a>五. UIImageView的帧动画</h3><p>UIImageView可以让一系列的图片在特定的时间内按顺序显示<br>相关属性解析:</p><blockquote><p>animationImages：要显示的图片(一个装着UIImage的NSArray)<br>animationDuration：完整地显示一次animationImages中的所有图片所需的时间<br>animationRepeatCount：动画的执行次数(默认为0，代表无限循环)</p></blockquote><p>相关方法解析:</p><blockquote><ul><li>(void)startAnimating; 开始动画</li><li>(void)stopAnimating;  停止动画</li><li>(BOOL)isAnimating;  是否正在运行动画</li></ul></blockquote><hr><p>动画的一些应用 (不定时更新):<br>…</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git简易指南</title>
      <link href="/2015/11/06/Git%E7%AE%80%E6%98%93%E6%8C%87%E5%8D%97/"/>
      <url>/2015/11/06/Git%E7%AE%80%E6%98%93%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>Git(读音为/gɪt/)是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。[1]  Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。<br>Git算是开发人员必须掌握的一个工具了。很多命令对于初学者来说，比较难记，也容易搅混，所以整理了一下，待以后使用到的时候查阅一下。</p><h2 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h2><h3 id="创建新仓库"><a href="#创建新仓库" class="headerlink" title="创建新仓库"></a>创建新仓库</h3><p>创建新文件夹, 打开, 然后执行 <code>git init</code> 以创建新的 <font color="a52a2a">git</font> 仓库</p><h3 id="检出仓库"><a href="#检出仓库" class="headerlink" title="检出仓库"></a>检出仓库</h3><p>执行下面的命令以创建一个本地仓库的克隆版本: </p><p><code>git clone /path/to/repository</code></p><p>如果是远端服务器上的仓库, 你的命令会是这个样子:</p><p><code>git clone username@host:/path/to/repository</code></p><h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h3><p>你的本地仓库由 git 维护的三棵”树”组成. </p><p>第一个是你的 <font color="a52a2a">工作目录</font>, 它持有实际文件;</p><p>第二个是 <font color="a52a2a">缓存区(Index)</font> , 它像个缓存区域, 临时保存你的改动; </p><p>最后是 <font color="a52a2a">HEAD</font>, 指向你最近一次提交后的结果.</p><a id="more"></a><h3 id="添加与提交"><a href="#添加与提交" class="headerlink" title="添加与提交"></a>添加与提交</h3><p>你可以计划改动 (把它们添加到缓存区), 使用如下命令:</p><p><code>git add &lt;filename&gt;</code></p><p><code>git add *</code></p><p>这时 git 基本工作流程的第一步; 使用如下命令以实际提交改动:</p><p><code>git commit -m "代码提交信息"</code></p><p>现在这些代码就提交到了 <font color="a52a2a">HEAD</font> 但没提交到远端仓库.</p><h3 id="推送改动"><a href="#推送改动" class="headerlink" title="推送改动"></a>推送改动</h3><p>当改动已经在本地仓库后, 执行下面的命令将改动 push 到远程仓库: </p><p><code>git push origin master</code></p><p>可以把 <font color="a52a2a">master</font> 换成你想要 push 的任何分支.</p><p>如果还没有克隆现有仓库, 并想要将你的仓库连接到某个远程服务器, 使用下面的命令: </p><p><code>git remote add origin &lt;server&gt;</code></p><p>这样就能将改动推送到所添加的服务器上去了.</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>分支是用来隔绝不同模块开发避免相互影响的. 在创建仓库时, <font color="a52a2a">master</font> 是默认的. 可以再其他分支上进心开发, 完成后再将它们合并到住分支上.</p><p>创建一个叫做 <font color="a52a2a">feature_a</font> 的分支, 并切换过去:</p><p><code>git checkout -b feature_a</code></p><p>切换会回主分支:</p><p><code>git checkout master</code></p><p>再把新建的分支删除: </p><p><code>git branch -d feature_a</code></p><p>除非将分支推送到远程仓库, 不然该分支就是 <font color="a52a2a"> 别人看不到的 </font> :</p><p><code>git push origin &lt;branch&gt;</code></p><p>查看远程分支：</p><p><code>$ git branch -a</code></p><p>查看本地分支：</p><p><code>$ git branch</code></p><h3 id="更新与合并"><a href="#更新与合并" class="headerlink" title="更新与合并"></a>更新与合并</h3><p>要更新你的本地仓库至最新改动, 执行: </p><p><code>git pull</code></p><p>以在你的工作目录中 <font color="a52a2a">fetch</font> 并 <font color="a52a2a">merge</font> 远程的改动.</p><p>要合并其他分支到你的当前分支 (例如 <font color="a52a2a">master</font> ), 执行:</p><p><code>git marge &lt;brance&gt;</code></p><p>两种情况下, git 都会尝试区自动合并改动. 然而可能有 冲突. 将这些冲突解决更改后, 需要执行如下命令将它们标记成合并成功:</p><p><code>git add &lt;filename&gt;</code></p><p>在合并改动之前, 也可以使用如下命令查看: </p><p><code>git diff &lt;source_branch&gt; &lt;target_branch&gt;</code></p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>可以通过以下命令创建一个叫做 <font color="a52a2a">1.0.0</font> 的标签:</p><p><code>git tag 1.0.0 1b231d63ff</code></p><p><font color="a52a2a"> 1b231d63ff </font> 是你想要标记的提交 ID 的前10位支付. 使用如下命令获取提交 ID:</p><p><code>git log</code></p><p>也可以少于10位, 只要能保证它是唯一的.</p><h3 id="替换本地改动"><a href="#替换本地改动" class="headerlink" title="替换本地改动"></a>替换本地改动</h3><p>如果需要恢复代码到本地. 可以实用如下命令替换掉本地改动:</p><p><code>git checkout -- &lt;filename&gt;</code></p><p>此命令会实用 <font color="a52a2a">HEAD</font> 中的最新内容替换掉你的工作目录中的文件. 已添加到缓存区的改动, 以及新文件, 都不受影响.</p><p>如果想要丢弃本地所有的改动和提交, 可以到服务器上获取最新的版本并将你本地主分支指向它:</p><p><code>git fetch origin</code></p><p><code>git reset --hard origin/master</code></p><h3 id="解决合并冲突："><a href="#解决合并冲突：" class="headerlink" title="解决合并冲突："></a>解决合并冲突：</h3><p><a href="https://www.cnblogs.com/baby123/p/6588378.html" target="_blank" rel="noopener">https://www.cnblogs.com/baby123/p/6588378.html</a></p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>内建的图形化 git:</p><p><code>gitk</code></p><p>彩色的 git 输出</p><p><code>git config color.ui true</code></p><p>显示历史记录时, 只显示一行注释信息: </p><p><code>git config format.pretty oneline</code></p><p>交互地添加文件至缓存区</p><p><code>git add -i</code></p><hr><h2 id="遇到的一些问题"><a href="#遇到的一些问题" class="headerlink" title="遇到的一些问题"></a>遇到的一些问题</h2><h3 id="解决在通过git命令-git-pull-的时候出现Threre-is-no-tracking-information-for-the-current-branch-Please-specify-which-branch-you-want-to-merge-with。"><a href="#解决在通过git命令-git-pull-的时候出现Threre-is-no-tracking-information-for-the-current-branch-Please-specify-which-branch-you-want-to-merge-with。" class="headerlink" title="解决在通过git命令 git pull 的时候出现Threre is no tracking information for the current branch . Please specify which branch you want to merge with。"></a>解决在通过git命令 git pull 的时候出现Threre is no tracking information for the current branch . Please specify which branch you want to merge with。</h3><p> 就是需要指定本地projet分支，跟远程仓库项目分支之间的关系，比如，我们需要本地master对应远程的master<br>是因为本地分支和远程分支没有建立联系 (使用git branch -vv 可以查看本地分支和远程分支的关联关系) .根据命令行提示只需要执行以下命令即可:</p><pre><code class="bash"># git branch --set-upstream-to=origin/远程分支的名字 本地分支的名字git branch --set-upstream-to master origin/master</code></pre><p>解决方法来自:<a href="http://blog.csdn.net/tterminator/article/details/78108550" target="_blank" rel="noopener">http://blog.csdn.net/tterminator/article/details/78108550</a></p><h3 id="刚刚创建git仓库，遇到问题git-错误-fatal-Not-a-valid-object-name-39-master-39"><a href="#刚刚创建git仓库，遇到问题git-错误-fatal-Not-a-valid-object-name-39-master-39" class="headerlink" title="刚刚创建git仓库，遇到问题git 错误 fatal: Not a valid object name: 'master'"></a>刚刚创建git仓库，遇到问题git 错误 <code>fatal: Not a valid object name: 'master'</code></h3><p>  刚创建的git仓库默认的master分支要在第一次commit之后才会真正建立，否则就像你声明了个对象但没初始化一样<br>解决办法：先<code>git add</code>。添加所有项目文件到本地仓库缓存，再<code>git commit -m "init commit"</code>提交到本地仓库，之后就可以随心所欲地创建或切换分支了。（这里给出的是可以直接操作成功的，add和commit可以按自己需要写）。</p><p>  而当git pull 遇到fatal: refusing to merge unrelated histories</p><pre><code class="bash">git pull origin master --allow-unrelated-histories</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objective 4种延时方法简单记录</title>
      <link href="/2015/10/09/%E5%9B%9B%E7%A7%8D%E5%BB%B6%E6%97%B6%E6%89%A7%E8%A1%8C%E6%9F%90%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%8A%E5%85%B6%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB/"/>
      <url>/2015/10/09/%E5%9B%9B%E7%A7%8D%E5%BB%B6%E6%97%B6%E6%89%A7%E8%A1%8C%E6%9F%90%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%8A%E5%85%B6%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p> OC开发相关注意事项四作为备忘列举了四种延时执行某函数的方法及其一些区别。<br>假如延时1秒时间执行下面的方法。</p><pre><code class="objc">- (void)delayMethod { NSLog(@"execute"); }</code></pre><h5 id="1-performSelector方法"><a href="#1-performSelector方法" class="headerlink" title="1.performSelector方法"></a>1.<code>performSelector</code>方法</h5><pre><code class="objc">[self performSelector:@selector(delayMethod) withObject:nil afterDelay:1.0f];</code></pre><p>此方式要求必须在主线程中执行，否则无效。</p><p>是一种非阻塞的执行方式，</p><h5 id="2-定时器-NSTimer"><a href="#2-定时器-NSTimer" class="headerlink" title="2.定时器:NSTimer"></a>2.定时器:<code>NSTimer</code></h5><pre><code class="objc">[NSTimer scheduledTimerWithTimeInterval:1.0f target:self selector:@selector(delayMethod) userInfo:nil repeats:NO];</code></pre><p>此方式要求必须在主线程中执行，否则无效。</p><p>是一种非阻塞的执行方式，</p><p>可以通过NSTimer类的- (void)invalidate;取消执行。</p><h5 id="3-sleep方式"><a href="#3-sleep方式" class="headerlink" title="3.sleep方式"></a>3.<code>sleep</code>方式</h5><pre><code class="objc">[NSThread sleepForTimeInterval:1.0f]; [self delayMethod];</code></pre><p>此方式在主线程和子线程中均可执行。</p><p>是一种阻塞的执行方式，建方放到子线程中，以免卡住界面</p><p>没有找到取消执行的方法。</p><h5 id="4-GCD方式"><a href="#4-GCD方式" class="headerlink" title="4.GCD方式"></a>4.GCD方式</h5><pre><code class="objc">double delayInSeconds = 1.0;  __block ViewController* bself = self;  dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));dispatch_after(popTime, dispatch_get_main_queue(), ^(void){  [bself delayMethod]; });</code></pre><p>此方式在可以在参数中选择执行的线程。</p><p>是一种非阻塞的执行方式，</p><p>没有找到取消执行的方法。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
