<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[OC 深入记录]]></title>
      <url>http://www.donglyu.com/2016/08/24/%5BOC%5DObjective-C%E6%B7%B1%E5%85%A5%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h2 id="第1章-OC-基本"><a href="#第1章-OC-基本" class="headerlink" title="第1章 OC 基本"></a>第1章 OC 基本</h2><h3 id="1-内存相关"><a href="#1-内存相关" class="headerlink" title="1. 内存相关"></a>1. 内存相关</h3><p>分配在堆中的内存必须直接管理, 而分配在栈中的用于保存变量的内存则会在其栈弹出时自动清理.<br>    Objective-C将堆内存管理抽象出来了. 不需要用malloc及free来分配或释放对象所占内存. Objective-C运行期环境把这部分工作抽象为一套内存管理框架-“引用计数”</p>
<p>在OC中, 有时会遇到定义里不含*的变量, 可能会使用<code>栈空间</code>. 这些变量所保存的不是Objective-C对象, 比如CoreGraphics中的CGRect.</p>
<hr>
<h3 id="2-在类的头文件中尽量少引入其他头文件"><a href="#2-在类的头文件中尽量少引入其他头文件" class="headerlink" title="2. 在类的头文件中尽量少引入其他头文件"></a>2. 在类的头文件中尽量少引入其他头文件</h3><p>而是采用向前声明(forward declaring)<br>减少类的使用者, 所需引入的头文件数量,减少编译时间.<br>也能解决两个类互相引用的问题</p>
<a id="more"></a>
<hr>
<h3 id="3-多用字面量语法-少用与之等价的方法"><a href="#3-多用字面量语法-少用与之等价的方法" class="headerlink" title="3. 多用字面量语法, 少用与之等价的方法"></a>3. 多用字面量语法, 少用与之等价的方法</h3><p>字面量语法,比如:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *something = <span class="string">@"Effective Objective-C 2.0"</span>;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//字面数值</span></div><div class="line"><span class="built_in">NSNumber</span> *someNumber = [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1</span>]; -&gt; <span class="built_in">NSNUmber</span> *someNumber = @<span class="number">1</span>;</div><div class="line"><span class="comment">//字面量数组</span></div><div class="line"><span class="built_in">NSArray</span> *animals = @[<span class="string">@"cat"</span>, <span class="string">@"dog"</span>];<span class="comment">// 数组中若有nil会 抛出异常.</span></div><div class="line"><span class="comment">//字面量字典</span></div><div class="line"><span class="built_in">NSDictionary</span> *personData = @&#123;</div><div class="line"><span class="string">@"firstName"</span> : <span class="string">@"Matt"</span>,</div><div class="line"><span class="string">@"lastName"</span> : <span class="string">@"za"</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//可变数组</span></div><div class="line">mutableArray[<span class="number">1</span>] = <span class="string">@"dog"</span>;<span class="comment">// 尽量通过下标操作来访问数组, 或者字典中的所对应的元素.</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="4-多用类型常量-少用-define-预处理指令"><a href="#4-多用类型常量-少用-define-预处理指令" class="headerlink" title="4. 多用类型常量, 少用#define 预处理指令"></a>4. 多用类型常量, 少用#define 预处理指令</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> kAnimationDuration = <span class="number">0.3</span>;</div></pre></td></tr></table></figure>
<p>命名, 若常量局限于某”编译单元”(也就是实现文件中, implementation中),则在前面加字母k; 若常量在类之外可见, 则通常以类名为前缀.<br>尽量不要在头文件中声明预处理指令或定义常量 static const.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AnimatedView</span>: <span class="title">UIView</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> kAnimationDuration = <span class="number">0.3</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AnimatedView</span></span></div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="comment">// static修饰意味着, 该变量仅局限于此变量的编译单元(在OC语境下, 一般通常指每个类的实现文件(.m))中.</span></div><div class="line">如不加<span class="keyword">static</span>, 在另一.m文件中也声明了同名变量, 会抛出常见的duplicate_symbol错误</div></pre></td></tr></table></figure>
<p>实际上, 如果一个变量既声明为static, 有声明为const, 那么编译器根本不会创建符号, 而是想#define预处理指令一样, 把所有遇到的变量都替换成常值. 不过这种方式定义的常量是带有类型信息的, 这点也相当关键.</p>
<ul>
<li>通知, 发送者和接受者都需要个外界可见的常量变量(即通知的名称).</li>
</ul>
<p>这时,此类变量需放在”全局符号表”(global symbol table)中, 以便可以在定义该变量的编译单元之外使用.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In the header file</span></div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> EOCStringConstant;</div><div class="line"></div><div class="line"><span class="comment">// In the implementation file</span></div><div class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> EOCStringConstant = <span class="string">@"VALUENOTIFICATION"</span>;</div></pre></td></tr></table></figure>
<p>常量定义从右至左解读,这里是”一个常量, 而这个常量是个指针, 指向一个NSString对象”<br>这里面的命名要注意谨慎, 避免名称冲突, 最好用与值相关的类名做前缀.</p>
<h3 id="5-用枚举表示状态、选项、状态码"><a href="#5-用枚举表示状态、选项、状态码" class="headerlink" title="5. 用枚举表示状态、选项、状态码"></a>5. 用枚举表示状态、选项、状态码</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> EOCConnectionStateConnectionState&#123;</div><div class="line">	EOCConnectionStateDisconnected = <span class="number">1</span>,</div><div class="line">	EOCConnectionStateConnecting,</div><div class="line">	EOCConnectionStateConnected,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>定义可以彼此组合的枚举. 定义的对后, 各选项之间就可通过”按位或操作符”(bitwise OR operator)来组合.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> <span class="built_in">UIViewAutoresizing</span> &#123;</div><div class="line">	<span class="built_in">UIViewAutoresizingNone</span>						= <span class="number">0</span>,</div><div class="line">	<span class="built_in">UIViewAutoresizingFlexbleLeftMargin</span>		= <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</div><div class="line">	<span class="built_in">UIViewAutoresizingFlexbleWidth</span>				= <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</div><div class="line">	<span class="built_in">UIViewAutoresizingFlexbleRighMargin</span> 		= <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</div><div class="line">	.....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在处理枚举类型的switch语句中不要实现default分支. 这样的话, 加入新枚举之后, 编译器就会提示开发者. switch语句并未处理所有枚举.</li>
</ul>
<hr>
<h2 id="第2章-对象、消息、运行期"><a href="#第2章-对象、消息、运行期" class="headerlink" title="第2章 对象、消息、运行期"></a>第2章 对象、消息、运行期</h2><h3 id="6-理解属性这一概念"><a href="#6-理解属性这一概念" class="headerlink" title="6.理解属性这一概念"></a>6.理解属性这一概念</h3><p>属性用来通过存取放方法来访问实例变量, 是OC提供的一个简洁方便管理的抽象机制. @property语法. 如果用了这些属性了, 编译器会自动编写访问这些属性所需的方法, 次过程叫”自动合成”(autosynthesis),并添加对应的实例变量. 也可以在类的实现代码里通过<code>@synthesize</code>语法来指定实例变量的名字</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@implementaion EOCPerson</div><div class="line"><span class="keyword">@synthesize</span> fireName = _myFirstname;</div><div class="line"><span class="keyword">@synthesize</span> lastName = _myLastName;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>可通过<code>@dynamic</code>关键字来告诉编译器不要自动创建实现属性所用的实例变量和存取方法.</p>
<p>修饰属性的特质关键字</p>
<ul>
<li>weak 表明定义了一种”非拥有关系”. 为这种属性设置新值时, 设置方法既不保留新值, 也不释放旧值. 当属性所指的对象遭到销毁时, 属性值也会清空(nil).</li>
<li>unsafe_unretained 该特质的语义表达一种”非拥有关系”, 当目标对象遭到销毁时, 属性值不会自动清空(unsafe), 这一点和weak不同.</li>
<li>在iOS程序是, 应用nonatomic属性, 避免影响性能</li>
</ul>
<p><br></p>
<hr>
<h3 id="7-在对对象内部尽量直接访问实例变量"><a href="#7-在对对象内部尽量直接访问实例变量" class="headerlink" title="7. 在对对象内部尽量直接访问实例变量"></a>7. 在对对象内部尽量直接访问实例变量</h3><p>直接访问实例变量, 速度会快一点, 但是对一个声明的copy的属性, 那么并不会拷贝该属性, 只会保留新值并释放旧值. 也不能触发”键值观察”(KVO), 一般比较折中的方式是写入实例变量时, 通过其”设置方法”来做, 而在读取实例变量是, 则直接访问.<br>注意的地方:<br>在初始化方法中应该如何设置属性值, 这种情况总是应该直接访问实例变量, 因为子类可能overide重写了设置方法.</p>
<p>对于懒加载或者说惰性初始化(lazy initialization)来说,就必须通过存取方法来访问属性.</p>
<p><br></p>
<hr>
<h3 id="8-理解”对象等同性”"><a href="#8-理解”对象等同性”" class="headerlink" title="8. 理解”对象等同性”"></a>8. 理解”对象等同性”</h3><p>有时,按照==操作符比较出来的结果未必是我们想要的, 该操作比较的是两个指针本身, 而不是所指的对象. 应该使用NSObject协议中声明的<code>isEqual</code><br>NSObject协议中有两个用于判断等同性的关键方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)isEqual:(<span class="keyword">id</span>)object;</div><div class="line">- (<span class="built_in">NSUInteger</span>)hash;</div></pre></td></tr></table></figure>
<ul>
<li><p>若想检测对象的等同性, 请提供<code>isEqual:</code>与<code>hash</code>方法.</p>
</li>
<li><p>相同的对象必须具有相同的哈希码, 但两个哈希码相同的对象却未必相同.</p>
</li>
<li><p>编写hash方法时, 应该使用计算速度快而且哈希码碰撞几率低的算法.</p>
</li>
</ul>
<p><br></p>
<hr>
<h3 id="9-以”类族模式”隐藏实现细节"><a href="#9-以”类族模式”隐藏实现细节" class="headerlink" title="9.以”类族模式”隐藏实现细节."></a>9.以”类族模式”隐藏实现细节.</h3><p>类方法(也叫类别方法)<br>类族模式可以把实现细节隐藏在一套简单的公共接口后面.</p>
<p>系统框架中经常使用类族(NSArray)</p>
<p><br></p>
<hr>
<h3 id="11-理解objc-msgSend的作用"><a href="#11-理解objc-msgSend的作用" class="headerlink" title="11. 理解objc_msgSend的作用"></a>11. 理解objc_msgSend的作用</h3><p>传递消息, C语言使用静态绑定(static binding), 在编译期内就能决定运行时所应调用的函数.函数地址实际上是硬编码在指令之中的.</p>
<p>so 对应的有动态绑定, 在OC中, 如果向某对象传递消息, 那就会使用动态绑定机制来决定需要调用的方法.</p>
<ul>
<li>给某对象”发送消息”(invoke a message)也就相当于在该对象上”调用方法”(call a method)</li>
<li>发给某对象的全部消息都要由”动态消息派发系统”(dynamic message dispatch system)来处理, 该系统会查处对应的方法, 并执行其代码.</li>
</ul>
<p><br></p>
<hr>
<h3 id="12-理解消息转发机制"><a href="#12-理解消息转发机制" class="headerlink" title="12. 理解消息转发机制"></a>12. 理解消息转发机制</h3><ul>
<li>若对象无法响应某个选择子, 则进入消息转发流程.</li>
<li>通过运行期的动态方法解析功能, 我们可以在需要用到某个方法时再讲其加入类中.</li>
<li>对象可以把其无法解读的某些选择子转交给其他对象来处理.</li>
<li>经过上述两步后, 如果还是没有办法处理选择子, 那就启动完整的消息转发机制.</li>
</ul>
<p><br></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[阶段总结]]></title>
      <url>http://www.donglyu.com/2016/08/23/%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>8月</p>
<p>Swift还是在学习中,可能会搁置一段时间. 基本语法是了解了, 在了解过程也发现某些语法确实和看到的资料不同, 有人开玩笑说, 每过一段时间就好像是学一门新的语言.😁</p>
<a id="more"></a>
<p>但是以目前的Swift语言的状态来说, 确实不太适合作为某些公司的主力开发语言<br>因此之后的比例会减少, 继续OC.</p>
<p>Swift包括网络库等等, 都要熟悉, 头疼.<br>后续会抽空更新Swift语言的相关知识整理, 也是方便自己之后的查阅~~. </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[简单整理Swift与Objective-C的一些不同]]></title>
      <url>http://www.donglyu.com/2016/08/23/%E7%AE%80%E5%8D%95%E6%95%B4%E7%90%86Swift%E4%B8%8EObjective-C%E7%9A%84%E4%B8%8D%E5%90%8C/</url>
      <content type="html"><![CDATA[<ul>
<li>在OC中对代码进行逻辑组织用的是#pragma mark - , 生成分割线<br>而在swift中有了一些新的语法<br>如: <code>//MARK:</code> <code>//FIXME</code> <code>TODO:</code></li>
</ul>
<a id="more"></a>
<p><code>//MARK: -</code> 生成分割线</p>
<p><code>//MARK:</code> 说明</p>
<ul>
<li>Swift中对类进行扩展<br>OC中采用的是分类, 而Swift中没有分类, 相对应的只有扩展(<code>Extensions</code>)<br>以UIView为例 , 新建UIView+Ext.swift</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">import Foundation</div><div class="line">import <span class="built_in">UIKit</span></div><div class="line"></div><div class="line"></div><div class="line">extension <span class="built_in">UIView</span> &#123;</div><div class="line">    public var x: <span class="built_in">CGFloat</span>&#123;</div><div class="line">        get&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.frame.origin.x</div><div class="line">        &#125;</div><div class="line">        set&#123;</div><div class="line">            var r = <span class="keyword">self</span>.frame</div><div class="line">            r.origin.x = newValue</div><div class="line">            <span class="keyword">self</span>.frame = r</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// ....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>… 持续更新</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Photos Framework记录]]></title>
      <url>http://www.donglyu.com/2016/08/22/Photos%20Framework%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>几个概念是接触Photos需要了解的.</p>
<h2 id="1-PHAsset-、PHAssetCollection、PHCollectionList"><a href="#1-PHAsset-、PHAssetCollection、PHCollectionList" class="headerlink" title="1. PHAsset 、PHAssetCollection、PHCollectionList"></a>1. PHAsset 、PHAssetCollection、PHCollectionList</h2><p>PHAsset 、PHAssetCollection、PHCollectionList 是Photos框架中的模型类，PHAsset类是数据模型，描述图片或者视频文件数据；PHAssetCollection描述了包括相册、moments、智能相册以及共享照片流等一系列图片或者视频文件的集合的元数据；PHCollectionList是一组资源集合，可能是一组Assets，也可能是一组collection<br><br></p>
<h3 id="1-1-PHAsset-存储获取图片和视频文件的元数据"><a href="#1-1-PHAsset-存储获取图片和视频文件的元数据" class="headerlink" title="1.1 PHAsset: 存储获取图片和视频文件的元数据."></a>1.1 PHAsset: <strong>存储获取图片和视频文件的元数据.</strong></h3><p>这些图片和视频文件可能在手机内, 或者只存在iCloud(当开启了iCloud照片图片功能上传到iCloud了)中,<br>相比以前的ALAsset,提供了更多的资源信息.</p>
<p>有几个要点</p>
<blockquote>
<ul>
<li>需要使用[PHAsset fetchAsset…]系列类方法获取.</li>
<li>PHAsset对象只包含原数据, 不包含图片或视频的数据. 要图片和视频数据, 需要使用PHImageManager加载<a id="more"></a>
</li>
</ul>
</blockquote>
<p>重要的属性:</p>
<blockquote>
<ul>
<li><code>mediaType</code> : 资源类型  图片/音频/视频</li>
<li><code>mediaSubtypes</code> : 全景图、HDR图片、屏幕截图、live Photo</li>
<li><code>Favorite</code> : 标记资源是否被用户标为”收藏”</li>
<li><code>hidden</code> : 是否被用户设置为隐藏</li>
<li><code>representsBurst</code> 和 <code>burstSelectionTypes</code>: 对于一个资源，如果其 PHAsset 的 representsBurst 属性为 true，则表示这个资源是一系列连拍照片中的代表照片 (多张照片是在用户按住快门时拍摄的)。它还有一个属性是 burstIdentifier，如果想要获取连拍照片中的剩余的其他照片，可以通过将这个值传入 fetchAssetsWithBurstIdentifier(…) 方法来获取。用户可以在连拍的照片中做标记；此外，系统也会自动用各种试探来标记用户可能会选择的潜在代表照片。这个元数据是可以通过 PHAsset 的 burstSelectionTypes 属性来访问。这个属性是用三个常量组成的位掩码：.UserPick 表示用户手动标记的资源，.AutoPick 表示用户可能标记的潜在资源，.None 表示没有标记的资源。</li>
</ul>
</blockquote>
<p><br></p>
<ul>
<li><code>sourceType</code> : 资源可以来源于用户相册、iCloud、iTunes同步</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PHAssetSourceTypeNone, </div><div class="line">PHAssetSourceTypeUserLibrary,</div><div class="line">PHAssetSOurceTypeCloudShared,</div><div class="line">PHAssetSourceTypeiTunesSynced</div></pre></td></tr></table></figure>
<ul>
<li>localIdentifier</li>
</ul>
<p>Photos框架中的根类PHObject只有一个公开接口localIdentifier, 是对象的<em>唯一标识符</em>.PHObject实现了<code>-isEqual</code>和<code>-hash</code>方法. 可以直接使用localIdentifier属性对PHObject及其子类迭代进行对比</p>
<h3 id="1-2-PHAssetCollection"><a href="#1-2-PHAssetCollection" class="headerlink" title="1.2 PHAssetCollection"></a>1.2 PHAssetCollection</h3><p>PHAssetColletion是一组有序的资源集合, 包含相册,智能相册,照片流等等.<br><br><br><br></p>
<h3 id="1-3-PHCollectionList"><a href="#1-3-PHCollectionList" class="headerlink" title="1.3 PHCollectionList"></a>1.3 PHCollectionList</h3><p>一组有序的资源集合的集合</p>
<h2 id="2-获取数据"><a href="#2-获取数据" class="headerlink" title="2. 获取数据"></a>2. 获取数据</h2><p>PHAsset 、PHAssetCollection、PHCollectionList</p>
<h3 id="2-1-PHAsset获取PHAsset的类方法"><a href="#2-1-PHAsset获取PHAsset的类方法" class="headerlink" title="2.1 PHAsset获取PHAsset的类方法"></a>2.1 PHAsset获取PHAsset的类方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+ fetchAssetsInAssetCollection:options:</div><div class="line">+ fetchAssetsWithMediaType:options:</div><div class="line">+ fetchAssetsWithLocalIdentifiers:options:</div><div class="line">+ fetchKeyAssetsInAssetCollection:options:</div><div class="line">+ fetchAssetsWithOptions:</div><div class="line">+ fetchAssetsWithBurstIdentifier:options:</div><div class="line">+ fetchAssetsWithALAssetURLs:options:</div></pre></td></tr></table></figure>
<ul>
<li>PHFetchOptions</li>
</ul>
<p>1-predicate: 选择的约束条件</p>
<p>2-sortDescriptors 对结果进行排序</p>
<p>3-includeHiddenAssets 获取结果是否包含被隐藏的资源</p>
<p>4-includeAllBurstAssets 获取结果是否包含联排资源</p>
<p>属性: </p>
<blockquote>
<ol>
<li>predicate: 选择的约束条件</li>
<li>sortDescriptors 对结果进行排序</li>
<li>includeHiddenAssets 获取结果是否包含被隐藏的资源</li>
<li>includeAllBurstAssets 获取结果是否包含连拍资源</li>
</ol>
</blockquote>
<p>示例:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">PHFetchOptions *options = [[PHFetchOptions alloc] init];</div><div class="line">options.wantsIncrementalChangeDetails = <span class="literal">YES</span>;</div><div class="line">options.includeAllBurstAssets = <span class="literal">YES</span>;</div><div class="line">options.includeHiddenAssets = <span class="literal">YES</span>;</div><div class="line"><span class="comment">// 只取图片</span></div><div class="line">options.predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"mediaType == %d"</span>,PHAssetMediaTypeImage];</div><div class="line"><span class="comment">// 按时间排序</span></div><div class="line">options.sortDescriptors = @[[<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@"creationDate"</span> ascending:<span class="literal">YES</span>]];</div><div class="line"></div><div class="line">PHFetchResult *albums = [PHAssetCollection fetchAssetCollectionsWithType:PHAssetCollectionTypeSmartAlbum subtype:PHAssetCollectionSubtypeSmartAlbumAllHidden options:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<ul>
<li>PHFetchResult</li>
</ul>
<p>类似数组, 存储获取到的asset对象集合.<br>操作方式也和NSArray数组类似</p>
<h2 id="3-修改数据-写入相册"><a href="#3-修改数据-写入相册" class="headerlink" title="3. 修改数据, 写入相册"></a>3. 修改数据, 写入相册</h2><p>// …. 待写</p>
<h3 id="3-1-PHPhotoLibrary"><a href="#3-1-PHPhotoLibrary" class="headerlink" title="3.1 PHPhotoLibrary"></a>3.1 PHPhotoLibrary</h3><p>系统中PHPhotoLibrary单例对象 是用来维护用户照片库。当我们需要编辑资源对象元数据、资源内容、或者插入新的资源对象等，都可以借助通过PHPhotoLibrary单例对象执行block，block中创建我们指定的请求对象(比如PHAssetChangeRequest,PHAssetCollectionChangeRequest, PHCollectionListChangeRequest的对象)。photoLibraryDidChange(changeInfo: PHChange!)中进行.</p>
<p><br></p>
<h2 id="4-请求图片数据"><a href="#4-请求图片数据" class="headerlink" title="4 请求图片数据"></a>4 请求图片数据</h2><h3 id="4-1-PHImageManager"><a href="#4-1-PHImageManager" class="headerlink" title="4.1 PHImageManager"></a>4.1 PHImageManager</h3><p>请求图片主要用了<code>PHImageManager</code>, <code>[PHImageManager defaultManager]</code>其提供了加载图片和视频的方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 请求图片</span></div><div class="line">- requestImageForAsset:targetSize:contentMode:options:resultHandler:</div><div class="line">- requestImageDataForAsset:options:resultHandler:</div><div class="line"><span class="comment">// 请求视频</span></div><div class="line">- requestPlayerItemForVideo:options:resultHandler:</div><div class="line">- requestExportSessionForVideo:options:exportPreset:resultHandler:</div><div class="line">- requestAVAssetForVideo:options:resultHandler:</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="4-2-请求图片"><a href="#4-2-请求图片" class="headerlink" title="4.2 请求图片"></a>4.2 请求图片</h3><p>// …</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Swift 记录04 start building UI]]></title>
      <url>http://www.donglyu.com/2016/08/09/Swift%20%E8%AE%B0%E5%BD%9504%20start%20building%20UI/</url>
      <content type="html"><![CDATA[<p>创建工程和OC创建工程类似, 只是最后选择Swift语言.</p>
<p>和OC中AppDelegate.h AppDelegate.app对应的是AppDelegate.swift.</p>
<p>AppDelegate.swift有两个基础功能:</p>
<a id="more"></a>
<ul>
<li><p>创建程序的入口和一个run loop传递输入事件到app中(是 @UIApplicationMain 通过此属性来实现的)</p>
<p>定义了AppDelegate 类, the blueprint for the app delegate object. 代理创建了内容和事件响应的window</p>
<p>The appDelegate clas contain a single property: window.With this property the app delegate keeps track of the window in which all of your app content is drawn. The window property is an optional, which means it may have no value (be nil) at some point.</p>
</li>
</ul>
<p><code>var window: UIWindow?</code></p>
<p>The AppDelegate class also contains template implementations of important methods. These predefined methods allow the application object to talk to the app delegate.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool</div><div class="line">func applicationWillResignActive(application: UIApplication)</div><div class="line">func applicationDidEnterBackground(application: UIApplication)</div><div class="line">func applicationWillEnterForeground(application: UIApplication)</div><div class="line">func applicationDidBecomeActive(application: UIApplication)</div><div class="line">func applicationWillTerminate(application: UIApplication)</div></pre></td></tr></table></figure>
<p>和OC中一样, 系统自动handle这些方法, 不用手动处理.</p>
<p>使用storyBoard添加控件,拉线建立联系和OC中一样…在此省略.</p>
<ul>
<li>以文字编辑框为例 UITextField.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 添加一个UITextField, 遵守其UITextFieldDelegate协议.</div><div class="line">class ViewController: UIViewController, UITextFieldDelegate &#123;</div><div class="line">	// ...</div><div class="line">	</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">func textFieldShouldReturn(textField: UITextField) -&gt; Bool &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当textfield不再是第一响应者后自动调用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func textFieldDidEndEditing(textField: UITextField) &#123;</div><div class="line">    mealNameLabel.text = textField.text</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>待续…</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Swift 基础记录 03 [枚举&结构体&协议]]]></title>
      <url>http://www.donglyu.com/2016/08/08/Swift%E5%9F%BA%E7%A1%80%E8%AE%B0%E5%BD%9503%20%E6%9E%9A%E4%B8%BE%E7%BB%93%E6%9E%84%E4%BD%93%E5%8D%8F%E8%AE%AE/</url>
      <content type="html"><![CDATA[<h4 id="枚举-amp-结构体-amp-协议"><a href="#枚举-amp-结构体-amp-协议" class="headerlink" title="枚举&amp;结构体&amp;协议"></a>枚举&amp;结构体&amp;协议</h4><p>枚举和结构体和类有着类似的功能, 但是可以在不同的上下文中使用<br>Enumerations define a common type for a group of related values and enable you to work with those values in a type-safe way within your code. Enumerations can have methods associated with them.</p>
<p>同时, 枚举和结构体不支持继承.</p>
<p>&lt;类和结构体必须在它们被创建时把它们所有的属性设置为合理的值。存储属性不能为不确定状态&gt;</p>
<a id="more"></a>
<h5 id="1-枚举"><a href="#1-枚举" class="headerlink" title="1.枚举"></a>1.枚举</h5><p>use <code>enum</code> to create an enumeration.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> Rank: Int &#123;</div><div class="line">	<span class="keyword">case</span> Ace = <span class="number">1</span></div><div class="line">	<span class="keyword">case</span> Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten</div><div class="line">	<span class="keyword">case</span> Jack, Queen, King</div><div class="line">	func simpleDescription() -&gt; String &#123;</div><div class="line">		<span class="keyword">switch</span> <span class="keyword">self</span>&#123;</div><div class="line">			<span class="keyword">case</span> .Ace:</div><div class="line">				<span class="keyword">return</span> <span class="string">"ace"</span></div><div class="line">			<span class="keyword">case</span> .Jack:</div><div class="line">				<span class="keyword">return</span> <span class="string">"jack"</span></div><div class="line">			<span class="keyword">case</span> .Queen:</div><div class="line">				<span class="keyword">return</span> <span class="string">"queen"</span></div><div class="line">			<span class="keyword">case</span> .King:</div><div class="line">				<span class="keyword">return</span> <span class="string">"king"</span></div><div class="line">			<span class="keyword">default</span>: </div><div class="line">				<span class="keyword">return</span> String(<span class="keyword">self</span>.rawValue)</div><div class="line">				<span class="comment">// rawValue : Int</span></div><div class="line">		</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">let ace = Rank.Ace</div><div class="line">let aceRawValue = ace.rawValue</div></pre></td></tr></table></figure>
<p>使用<code>init?(rawValue:)</code>来创建一个enum的实例</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> let convertedRank = Rank(rawValue: <span class="number">3</span>)&#123;</div><div class="line">	let threeDescription = convertedRank.simpleDescription()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> Suit &#123;</div><div class="line">    <span class="keyword">case</span> Spades, Hearts, Diamonds, Clubs</div><div class="line">    func simpleDescription() -&gt; String &#123;</div><div class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</div><div class="line">            <span class="keyword">case</span> .Spades:</div><div class="line">                <span class="keyword">return</span> <span class="string">"spades"</span></div><div class="line">            <span class="keyword">case</span> .Hearts:</div><div class="line">                <span class="keyword">return</span> <span class="string">"hearts"</span></div><div class="line">            <span class="keyword">case</span> .Diamonds:</div><div class="line">                <span class="keyword">return</span> <span class="string">"diamonds"</span></div><div class="line">            <span class="keyword">case</span> .Clubs:</div><div class="line">                <span class="keyword">return</span> <span class="string">"clubs"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let hearts = Suit.Hearts</div><div class="line">let heartsDescription = hearts.simpleDescription()</div></pre></td></tr></table></figure>
<h5 id="2-结构体"><a href="#2-结构体" class="headerlink" title="2.结构体"></a>2.结构体</h5><ul>
<li>结构体和类很有着和类一些相同的行为. 包括方法和对象初始化器. 区别就是结构器在代码中传递时, 总是copy过去的, 而类则是通过引用, 是同一个地址. 结构体更适合定义轻量型, 不需要继承, 和类型转换的场景.</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Card &#123;</div><div class="line">    var rank: Rank</div><div class="line">    var suit: Suit</div><div class="line">    func simpleDescription() -&gt; String &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"The \(rank.simpleDescription()) of \(suit.simpleDescription())"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let threeOfSpades = Card(rank: .Three, suit: .Spades)</div><div class="line">let threeOfSpadesDescription = threeOfSpades.simpleDescription()</div></pre></td></tr></table></figure>
<h5 id="3-协议-protocols"><a href="#3-协议-protocols" class="headerlink" title="3.协议(protocols)"></a>3.协议(protocols)</h5><p>一个协议定义了一系列满足特定需求任务的方法和属性的集合(蓝图), 协议不提供任何方法的实现, 只是描述实现长什么样,协议可以被类(class), 结构体(structure),或枚举(enumeration)</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">protocol ExampleProtocol &#123;</div><div class="line">     var simpleDescription: String &#123; get &#125;</div><div class="line">     func adjust()</div><div class="line">&#125;</div><div class="line"></div><div class="line">```objc</div><div class="line">`&#123; get &#125;` 表明属性是只可读的.</div><div class="line">通过`:`接在类名, <span class="keyword">enum</span>或structures后,表示遵守其协议</div></pre></td></tr></table></figure>
<p>// 实现simpleDescription 属性和adjust()协议方法<br>class SimpleClass: ExampleProtocol{<br>    var simpleDescription: String = “A very simple class.”<br>    var anotherProperty: Int = 69105<br>    func adjust(){<br>        simpleDescription += “   Now 100% adjusted.”<br>    }</p>
<p>}</p>
<p>var a = SimpleClass()<br>a.adjust()<br>let aDescription = a.simpleDescription</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Protocols are first-<span class="keyword">class</span> types, which means they can be treated like other named types. For example, you can create an ExampleProtocol array and call adjust() on each of the instances <span class="keyword">in</span> it (because any instance <span class="keyword">in</span> that array would be guaranteed to implement adjust(), one of the protocol’s requirements).</div></pre></td></tr></table></figure>
<p>class SimpleClass2: ExampleProtocol {<br>    var simpleDescription: String = “Another very simple class.”<br>    func adjust() {<br>        simpleDescription += “  Adjusted.”<br>    }<br>}</p>
<p>var protocolArray: [ExampleProtocol] = [SimpleClass(), SimpleClass(), SimpleClass2()]<br>for instance in protocolArray {<br>    instance.adjust()<br>}<br>protocolArray</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">#### 4.Swift and Cocoa Touch</div><div class="line"></div><div class="line">Swift从设计上就考虑和Cocoa Touch的无缝性.</div><div class="line">Cocoa Touch中标准库 `String` and `Array`</div><div class="line"></div><div class="line">还有一些其他可用的frameworks `UIKit`</div><div class="line">在`UIKit`中提供了很多for UI的类</div><div class="line"></div><div class="line">首先需要导入类:</div><div class="line">`import UIKit`</div><div class="line">然后正常使用:</div><div class="line"></div><div class="line">```objc</div><div class="line">let redSquare = UIView(frame: CGRect(x: 0, y: 0, width: 44, height: 44))</div><div class="line">redSquare.backgroundColor = UIColor.redColor()</div></pre></td></tr></table></figure>
<p>下一步就是Building the UI, 开始使用Swift构建UI了…, 可以把之前学到的慢慢应用在代码中…掌握</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Swift 基础记录 01 [基础类型和控制流]]]></title>
      <url>http://www.donglyu.com/2016/08/07/Swift%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B001%20%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
      <content type="html"><![CDATA[<h4 id="1-基础类型"><a href="#1-基础类型" class="headerlink" title="1.基础类型"></a>1.基础类型</h4><ul>
<li>use let to make constant and var to make a variable.</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var myVariable = <span class="number">42</span></div><div class="line">myVariable = <span class="number">43</span></div><div class="line">let myConstant = <span class="number">45</span></div></pre></td></tr></table></figure>
<p>在swfit,每个变量和常量都有一个类型. 不用显式的写出类型</p>
<a id="more"></a>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let implicitInteger = <span class="number">70</span></div><div class="line">let implicitDouble = <span class="number">70.0</span></div><div class="line">let explicitDouble: Double = <span class="number">70</span></div></pre></td></tr></table></figure>
<p>一旦被指明了类型后, 类型不能更换.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let label = <span class="string">"the width is "</span></div><div class="line">let width = <span class="number">94</span></div><div class="line">let widthLabel  = label + String(width)</div><div class="line"></div><div class="line"><span class="comment">// 用\来表示插入一个string</span></div><div class="line">let a = <span class="number">1</span></div><div class="line">let resutl = <span class="string">"1+1 = \(a+a)."</span></div></pre></td></tr></table></figure>
<ul>
<li><code>?</code>  optionals(选配)在Swift中使用较普遍, 用来处理不存在的值<br>Swift和其他语言不同, Swift里面不会自动给变量赋初始值, 变量不会有默认值, 所以要求使用变量前必须要对其初始化. 这时可以使用optional类型, 后面加个?就好了.</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// strValue自动得到默认值:nil(表示值不存在,而非指针)</span></div><div class="line">var strValue: String?</div><div class="line"><span class="comment">// 判断optianl是否有值.</span></div><div class="line"><span class="keyword">if</span> strValue&#123;</div><div class="line">	<span class="comment">//...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// ------</span></div><div class="line"><span class="comment">// optional binding  </span></div><div class="line"><span class="comment">// 如果strValue == nil, 那么结果就是nil,不会调用String的hasValue  </span></div><div class="line"><span class="comment">// 如果strValue != nil, 就返回strValue对应的hashValue值并赋值给常量hashValue  </span></div><div class="line"><span class="keyword">if</span> let hashValue = strValue?.hashValue &#123;  </div><div class="line">  <span class="comment">// do something if neccessary  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let optionalInt: Int? = <span class="number">9</span></div><div class="line"></div><div class="line">let actualInt: Int = optionalInt!</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 如果myString 不是数字类型的字符, 转换后possibleInt 变成nil.</span></div><div class="line">var myString = <span class="string">"7"</span></div><div class="line">var possibleInt = Int(myString)</div><div class="line">print(possibleInt)</div></pre></td></tr></table></figure>
<ul>
<li><code>!</code> 使用<code>!</code>来强制拆包(unwrap)获取值.<br>使用<code>!</code>来声明变量, 会成为隐式强拆类型, 表示这个类型永远不会出现nil的情况. 但一旦出现了nil,在调用时就会崩溃.</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var strValue: String?  </div><div class="line">strValue = <span class="string">"1234"</span>  </div><div class="line">  </div><div class="line">let integer = strValue!.toInt()  </div><div class="line"><span class="comment">// 更安全的写法是  </span></div><div class="line"><span class="keyword">if</span> strValue &#123;  </div><div class="line">  let integer = strValue!.toInt()  </div><div class="line">｝</div></pre></td></tr></table></figure>
<ul>
<li><code>!</code>&amp;<code>?</code> 使用总结</li>
</ul>
<p>1）当我们需要声明这样一个变量，变量在设计初始化函数中没有进行初始化时，就需要声明这个变量为optional类型。因为变量在使用前必须先声明，并且在设计初始化函数中进行初始化。比如我们在viewDidLoad函数中才进行初始化的控件（类成员），就需要声明为optional且必须是var声明，因为let声明的常量只能是在初始化函数中进行初始化。</p>
<p>（2）当我们不知道是否会有值的时候，这个变量可以声明为optional,比如代理，我们并没有要求必须传代理过来，那么就需要声明为optional。</p>
<p>（3）作为函数参数时，如果这个参数可以没有值，那么就使用optional类型，比如传代理的时候，通常就是可选的，可以设置为nil</p>
<hr>
<ul>
<li>数组(有序), 通过([])创建, 下标index从0开始</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var ratingList = [<span class="string">"poor"</span>, <span class="string">"Fine"</span>, <span class="string">"Good"</span>, <span class="string">"Excellent"</span>]</div><div class="line">ratingList[<span class="number">1</span>] = <span class="string">"OK"</span></div><div class="line"></div><div class="line"><span class="comment">// create an empty array.</span></div><div class="line">let empthArray = [String]()</div></pre></td></tr></table></figure>
<ul>
<li>注释, 注释和OC一致 , //  &amp;  /<em> … </em>/</li>
</ul>
<p>An implicitly unwrapped optional is an optional that can also be used like a nonoptional value, without the need to unwrap the optional value each time it’s accessed. This is because an implicitly unwrapped optional is assumed to always have a value after that value is initially set, although the value can change. Implicitly unwrapped optional types are indicated with an exclamation mark (!) instead of a question mark (?).</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var implicitlyUnwrappedOptionalInt: Int!</div></pre></td></tr></table></figure>
<hr>
<h4 id="2-控制流"><a href="#2-控制流" class="headerlink" title="2.控制流"></a>2.控制流</h4><ul>
<li>if , switch</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// if</span></div><div class="line">let number = <span class="number">23</span></div><div class="line"><span class="keyword">if</span> number &lt; <span class="number">10</span> &#123;</div><div class="line">	printf(<span class="string">"The number is small"</span>)</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> number &gt; <span class="number">100</span>&#123;</div><div class="line">	printf(<span class="string">"..."</span>)</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// for </span></div><div class="line">left scroes = [<span class="number">74</span>, <span class="number">35</span>, <span class="number">75</span>, <span class="number">108</span>, <span class="number">12</span>]</div><div class="line">var teamScore = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> score <span class="keyword">in</span> scroes &#123;</div><div class="line">	<span class="keyword">if</span> score &gt; <span class="number">50</span>&#123;</div><div class="line">		teamScore += <span class="number">3</span></div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">		teamScore += <span class="number">1</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">printf(teamScore)</div></pre></td></tr></table></figure>
<ul>
<li>Use optional binding in an if statement to check whether an optional contains a value.</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var optionalName: String? = <span class="string">"John Appleseed"</span></div><div class="line">var greeting = <span class="string">"Hello!"</span></div><div class="line"><span class="keyword">if</span> let name = optionalName &#123;</div><div class="line">    greeting = <span class="string">"Hello, \(name)"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>You can use a single if statement to bind multiple values. A where clause can be added to a case to further scope the conditional statement. In this case, the if statement executes only if the binding is successful for all of these values and all conditions are met.</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var optionalHello :String? = <span class="string">"Hello"</span></div><div class="line"><span class="keyword">if</span> let hello = optionalhello where hello.hasPrefix(<span class="string">"H"</span>), let name = optionalName&#123;</div><div class="line">	greeting = <span class="string">"\(Hello), \(name)"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Switch(条件分支语句are quite powerful.)</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">let vegetable = <span class="string">"red pepper"</span></div><div class="line"><span class="keyword">switch</span> vegetable&#123;</div><div class="line">	<span class="keyword">case</span> <span class="string">"celery"</span>:</div><div class="line">		let vegetableComment = <span class="string">"Add some raisins and make ants on a log."</span></div><div class="line">	<span class="keyword">case</span> <span class="string">"cucumber"</span>, <span class="string">"watercress"</span>:</div><div class="line">		let vegetableComment = <span class="string">"That would make a good tea sandwitch."</span></div><div class="line">	<span class="keyword">case</span> let x where x.hasSuffix(<span class="string">"pepper"</span>):</div><div class="line">		let vegetableComment = <span class="string">"Is it a spicy \(x)?"</span></div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		let vegetableComment = <span class="string">"Evertything tastes good in soup."</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">// let 可以用来匹配常量的一部分</span></div><div class="line"><span class="comment">// case 多个条件用 ","来分隔</span></div><div class="line"><span class="comment">// default在没有列出所有可能条件下, 必需</span></div></pre></td></tr></table></figure>
<ul>
<li>for<br>use the half-open range operator (..&lt;) to make a range of indexes.<br>&amp; range operator (…)</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// for circle 0,1,2,3.  不包括4</span></div><div class="line">var firstForLoop = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span>.&lt;<span class="number">4</span>&#123;</div><div class="line">	firstForLoop += i</div><div class="line">&#125;</div><div class="line">pritf(firstForLoop)</div><div class="line"></div><div class="line"><span class="comment">// for circle 0,1,2,3,4.  包括4</span></div><div class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0.</span>.<span class="number">.4</span>&#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// The underscore (_) represents a wildcard, which you can use when you don’t need to know which iteration of the loop is currently executing.</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Swift 基础记录 02 [函数和方法 类&初始化]]]></title>
      <url>http://www.donglyu.com/2016/08/07/Swift%E5%9F%BA%E7%A1%80%E8%AE%B0%E5%BD%9502%20%E5%8A%9F%E8%83%BD%E5%92%8C%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h5 id="1-函数和方法"><a href="#1-函数和方法" class="headerlink" title="1.函数和方法"></a>1.函数和方法</h5><ul>
<li><p>A function is a reusable, named piece of code that can be referred to from many places in a program.</p>
<p>  使用func来声明一个函数, 可以不带或带多个参数 : <code>name: Type</code>.   函数返回值 写在 <code>-&gt;</code>后,</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func greet(name: String, day: String) -&gt; String &#123;</div><div class="line">	<span class="keyword">return</span> <span class="string">"Hello \(name), today is \(day)."</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而调用函数则需要跟上参数名称, 第一个参数名字不需要带上.</p>
<a id="more"></a>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">greet(<span class="string">"Anna"</span>, day: <span class="string">"Tuesday"</span>)</div><div class="line">greet(<span class="string">"Bob"</span>, day: <span class="string">"Friday"</span>)</div><div class="line"></div><div class="line">var array = [<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"dragonfruit"</span>]</div><div class="line">array.insert(<span class="string">"cherry"</span>, atIndex: <span class="number">2</span>)</div></pre></td></tr></table></figure>
<h5 id="2-类-amp-初始化"><a href="#2-类-amp-初始化" class="headerlink" title="2.类&amp;初始化"></a>2.类&amp;初始化</h5><ul>
<li>定义类 <code>class</code> Shape</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Shape &#123;</div><div class="line">	var numberOfSides = <span class="number">0</span></div><div class="line">	func simpleDescription() -&gt; String &#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"A shape with \(numberOfSides) sides."</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用<code>class</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var shape = Shape()</div><div class="line">shape.numberOfSides = <span class="number">7</span></div><div class="line">var shapeDescription = shape.simpleDescription()</div></pre></td></tr></table></figure>
<ul>
<li>初始化<br>现在的Shape类 缺少一个重要的东西:类的初始化</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> NamedShape &#123;</div><div class="line">	</div><div class="line">	init(name: String)&#123;</div><div class="line">		<span class="keyword">self</span>.name = name</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	func simpleDescription() -&gt; String&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"A shape with \(numberOfSides) sides."</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而初始化一个类时不写<code>init</code>,而仅仅是通过以下方式调用</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let namedShape = NamedShape(name: <span class="string">"my named shape"</span>)</div></pre></td></tr></table></figure>
<ul>
<li>继承<br>通过 <code>:</code>接其父类就可</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Square: NamedShape &#123;</div><div class="line">    var sideLength: Double</div><div class="line"></div><div class="line">    init(sideLength: Double, name: String) &#123;</div><div class="line">        <span class="keyword">self</span>.sideLength = sideLength</div><div class="line">        <span class="keyword">super</span>.init(name: name)</div><div class="line">        numberOfSides = <span class="number">4</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    func area() -&gt;  Double &#123;</div><div class="line">        <span class="keyword">return</span> sideLength * sideLength</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    override func simpleDescription() -&gt; String &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"A square with sides of length \(sideLength)."</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let testSquare = Square(sideLength: <span class="number">5.2</span>, name: <span class="string">"my test square"</span>)</div><div class="line">testSquare.area()</div><div class="line">testSquare.simpleDescription()</div></pre></td></tr></table></figure>
<p>注意: Square类的初始化过程有三步:</p>
<pre><code>1. 为子类Square声明的属性赋值
2. 调用父类(NamedShape)的初始化方法
3. 更改父类Namedshape的属性, 以及其他方法,getter&amp;setter等方法.
</code></pre><p>有时, 根据传入参数, 我们需要返回一个fail . 用<code>init?</code>来声明一个可失败的初始化方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Circle: NamedShape &#123;</div><div class="line">    var radius: Double</div><div class="line"></div><div class="line">    init?(radius: Double, name: String) &#123;</div><div class="line">        <span class="keyword">self</span>.radius = radius</div><div class="line">        <span class="keyword">super</span>.init(name: name)</div><div class="line">        numberOfSides = <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> radius &lt;= <span class="number">0</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    override func simpleDescription() -&gt; String &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"A circle with a radius of \(radius)."</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let successfulCircle = Circle(radius: <span class="number">4.2</span>, name: <span class="string">"successful circle"</span>)</div><div class="line">let failedCircle = Circle(radius: <span class="number">-7</span>, name: <span class="string">"failed circle"</span>)</div></pre></td></tr></table></figure>
<p>其他关键字:<br>designated<br>convenience<br>required  标识强制类实现此方法</p>
<p>所有不加修饰的init方法都需要在方法中确保非Optional的实例变量被赋值初始化,而在子类中也强制 （显式或隐式地）调用super版本的designated初始化，所以无论如何走何种路径，被初始化的对象总是可以完成完整的初始化的。</p>
<p>与designated初始化方法对应的是在init前加上convenience关键字的初始化方法。这类方法是Swift初始化方法中的“二等公民”，只作为补充和提供使用上的方便。所有的convenience初始化方法都必须调用同一个类中的designated初始化完成设置，另外convenience的初始化方法是不能被子类重写或从子类中以super的方式被调用的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> ClassA &#123;</div><div class="line">    let numA: Int</div><div class="line">    init(num: Int) &#123;</div><div class="line">        numA = num</div><div class="line">    &#125;</div><div class="line">    convenience init(bigNum: Bool) &#123;</div><div class="line">        <span class="keyword">self</span>.init(num: bigNum ? <span class="number">10000</span> : <span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> ClassB: ClassA &#123;</div><div class="line">    let numB: Int</div><div class="line">    override init(num: Int) &#123;</div><div class="line">        numB = num + <span class="number">1</span></div><div class="line">        <span class="keyword">super</span>.init(num: num)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只要在子类中实现重写了父类convenience方法所需要的init方法的话，我们在子类中就也可以使用父类的convenience初始化方法了。比如在上面的代码中，我们在ClassB里实现了init(num: Int)的重写。这样，即使在ClassB中没有bigNum版本的convenience init(bigNum: Bool)，我们仍然还是可以用这个方法来完成子类初始化：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let anObj = ClassB(bigNum: <span class="literal">true</span>)</div><div class="line"><span class="comment">// anObj.numA = 10000, anObj.numB = 10001</span></div></pre></td></tr></table></figure>
<p>初始化方法永远遵循以下两个原则：</p>
<p>1.初始化路径必须保证对象完全初始化，这可以通过调用本类型的designated初始化方法来得到保证；</p>
<p>2.子类的designated初始化方法必须调用父类的designated方法，以保证父类也完成初始化。</p>
<hr>
<p>官方原文从底层介绍比较复杂, 建议有需求阅读原文.<br>本人看了一下有点抽象和晕, 看了下别人总结: </p>
<p> 1、自定义初始化方法要先调用自己类默认初始化方法，自己重写默认初始化方法要先调用父类默认初始化方法</p>
<p> 2、应该要先调用父类的构造器或者自身的默认构造器，以防止先给属性赋值了然后才调用父类或者自身的默认构造器把以前的赋值覆盖了</p>
<p>原文: (<a href="http://justcoding.iteye.com/blog/2080763" target="_blank" rel="external">http://justcoding.iteye.com/blog/2080763</a>)</p>
<hr>
<p>待看:</p>
<p>Initializers can have quite a few keywords associated with them. A designated initializer indicates that it’s one of the primary initializers for a class; any initializer within a class must ultimately call through to a designated initializer. A convenience initializer is a secondary initializer, which adds additional behavior or customization, but must eventually call through to a designated initializer. Designated and convenience initializers are indicated with the <code>designated</code> and <code>convenience</code> keywords, respectively.</p>
<p>A <code>required</code> keyword next to an initializer indicates that every subclass of the class that has that initializer must implement its own version of the initializer (if it implements any initializer).</p>
<p>Type casting is a way to check the type of an instance, and to treat that instance as if it’s a different superclass or subclass from somewhere else in its own class hierarchy.</p>
<p>A constant or variable of a certain class type may actually refer to an instance of a subclass behind the scenes. Where you believe this is the case, you can try to downcast to the subclass type using a type cast operator.</p>
<p>Because downcasting can fail, the type cast operator comes in two different forms. The optional form, <code>as?</code>, returns an optional value of the type you are trying to downcast to. The forced form, as!, attempts the downcast and force-unwraps the result as a single compound action.</p>
<p>Use the optional type cast operator (<code>as?</code>) when you’re not sure if the downcast will succeed. This form of the operator will always return an optional value, and the value will be nil if the downcast was not possible. This lets you check for a successful downcast.</p>
<p>Use the forced type cast operator (<code>as!</code>) only when you’re sure that the downcast will always succeed. This form of the operator will trigger a runtime error if you try to downcast to an incorrect class type.</p>
<p>This example shows the use of the optional type cast operator (as?) to check whether a shape in an array of shapes is a circle or a square. You increment the count of the squares and triangles variables by one each time the corresponding shape is found, printing the values at the end.</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Triangle: NamedShape &#123;</div><div class="line">    init(sideLength: Double, name: String) &#123;</div><div class="line">        <span class="keyword">super</span>.init(name: name)</div><div class="line">        numberOfSides = <span class="number">3</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let shapesArray = [Triangle(sideLength: <span class="number">1.5</span>, name: <span class="string">"triangle1"</span>), Triangle(sideLength: <span class="number">4.2</span>, name: <span class="string">"triangle2"</span>), Square(sideLength: <span class="number">3.2</span>, name: <span class="string">"square1"</span>), Square(sideLength: <span class="number">2.7</span>, name: <span class="string">"square2"</span>)]</div><div class="line">var squares = <span class="number">0</span></div><div class="line">var triangles = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> shape <span class="keyword">in</span> shapesArray &#123;</div><div class="line">   <span class="keyword">if</span> let square = shape as? Square &#123;</div><div class="line">      squares += <span class="number">1</span></div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> let triangle = shape as? Triangle &#123;</div><div class="line">      triangles += <span class="number">1</span></div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">print(<span class="string">"\(squares) squares and \(triangles) triangles."</span>)</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我的mvp,mvvm理解]]></title>
      <url>http://www.donglyu.com/2016/03/25/%E6%88%91%E7%9A%84mvp_mvvm%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>控制器Controller是app的“胶水代码”：协调模型和视图之间的所有交互, 过于臃肿。而作为对比的 Model过于轻量级. 等等原因, 原本的mvc缺陷体现</p>
<h5 id="mvvm"><a href="#mvvm" class="headerlink" title="mvvm"></a>mvvm</h5><p>Model-View-ViewModel<br>在mvvm中, view和view controller正式联系在一起, 可以视为一个组件,<br>视图view仍然不能直接引用模型model, controller也不能.但能引用视图模型view Model<br>view Model适合放置用户输入验证逻辑,视图显示逻辑, 发起网络请求和其他各种各种的代码.<br>刚开始使用mvvm的最好方式, 可以可将一小部分逻辑放入视图模型, 然后当你逐渐习惯于使用这个范式的时候再迁移.</p>
<h5 id="mvp"><a href="#mvp" class="headerlink" title="mvp"></a>mvp</h5><p>M: 逻辑Model层<br>V: 视图层<br>P: protocol协议层</p>
<p>Model层类似  MVVM的viewModel, 主要负责存储抽象逻辑数据, 另外Model还有部分工作实现对应的协议层协议. 提供协议对应的各种属性以及服务.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CocoaPods安装和使用]]></title>
      <url>http://www.donglyu.com/2016/03/08/CocoaPods%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="一-CocoaPods安装"><a href="#一-CocoaPods安装" class="headerlink" title="一. CocoaPods安装:"></a>一. CocoaPods安装:</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>cocoaPods是用 Ruby 实现的, 要想使用它就需要有 Ruby 环境, 幸运的是OS X 系统默认支持 Ruby, 打开终端输入命令安装 cocoaPods</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo gem install -n /usr/local/bin cocoapods</div></pre></td></tr></table></figure>
<p>CocoaPods是以Ruby gem包的形式被安装的。在安装执行的过程中，可能会问我们是不是更新rake，输入y即可。这是因为rake gem包会在安装的过程中检查更细，如果有可用的新版本就会出现刚才的选项。<br>在安装进程结束的时候，执行命令：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pod setup</div></pre></td></tr></table></figure>
<p>如果没有报错，就说明一切安装就成功了！<br><br></p>
<a id="more"></a>
<h3 id="2-安装中可能遇到的问题"><a href="#2-安装中可能遇到的问题" class="headerlink" title="2. 安装中可能遇到的问题:"></a>2. 安装中可能遇到的问题:</h3><h4 id="2-1-gem-install-cocoapods-命令半天后没反应"><a href="#2-1-gem-install-cocoapods-命令半天后没反应" class="headerlink" title="2.1 gem install cocoapods 命令半天后没反应"></a>2.1 gem install cocoapods 命令半天后没反应</h4><ol>
<li>首先可使用代理, 继续安装</li>
<li>用淘宝的RubyGems镜像来代替官方版<br>执行以下代码:</li>
</ol>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gem sources --remove <span class="symbol">https:</span>/<span class="regexp">/rubygems.org/</span></div><div class="line">gem sources -a <span class="symbol">http:</span>/<span class="regexp">/ruby.taobao.org/</span></div><div class="line">gem sources -l</div></pre></td></tr></table></figure>
<h4 id="2-2-gem版本过老"><a href="#2-2-gem版本过老" class="headerlink" title="2.2 gem版本过老"></a>2.2 gem版本过老</h4><p>gem是管理Ruby库和程序的标准包，如果它的版本过低也可能导致安装失败，解决方案自然是升级gem，执行下述命令即可：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo gem update --system</div></pre></td></tr></table></figure>
<h4 id="2-3-pod-setup-后卡住半天不反应"><a href="#2-3-pod-setup-后卡住半天不反应" class="headerlink" title="2.3 pod setup 后卡住半天不反应"></a>2.3 pod setup 后卡住半天不反应</h4><p>实际上, 这时也并非真的卡住了, 只是pod 在安装第三方库的索引目录(160MB, 较大容易下载出错).因此有如下方法解决</p>
<ol>
<li>前往<a href="https://github.com/CocoaPods/Specs" target="_blank" rel="external">https://github.com/CocoaPods/Specs</a> 下载该索引. (可通过 GitHub Desktop 下载)</li>
<li>Specs 文件夹更名<code>master</code>然后拷进repos文件夹下[目录在<code>/Users/用户名/.cocoapods/repos</code>]</li>
<li>完全退出终端，重启终端，pod功能即可正常使用。</li>
</ol>
<p>解释：pod setup的本质就是将<code>https://github.com/CocoaPods/Specs上的Specs</code>项目clone到<code>/Users/用户名/.cocoapods/repos</code>目录下。若此目录下已有Specs项目，则会将项目更新到最新的状态。由于Specs很大，容易导致pod setup失败。这时就需要我们手动安装Specs。若直接从github上下载zip文件，由于缺少git文件，会导致cocoa pods不使用。若用git clone，由于文件过大，容易导致失败。但是使用GitHub Desktop软件，则会提高clone的成功率，并且会给出clone的进度。</p>
<p>2 ) Pod install 或 pod update 很慢时, 可以使用下面两句来更新. 表示忽略升级 specs 库</p>
<p>实际上这两条命令是取消了repo的更新，从而变快了pod的速度。但是，假如开发者本地的repo真的已经过时了（就是第三方的地址list有点旧旧的），则无法逃避repo的更新，所以使用还是要pod repo update，依然是慢的不能忍。</p>
<p>所以，此处需要对pod的source换源<br>有大神提供了几个镜像，使用如下方法换掉repo的源</p>
<p>3 ) pod repo 换源</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pod repo</div></pre></td></tr></table></figure>
<p>会出现以下的字眼:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">master</div><div class="line">- <span class="symbol">Type:</span> git (master)</div><div class="line">- <span class="symbol">URL:</span>  <span class="symbol">https:</span>/<span class="regexp">/github.com/</span>CocoaPods/Specs.git</div><div class="line">- <span class="symbol">Path:</span> /Users/donglyu/.cocoapods/repos/master</div></pre></td></tr></table></figure>
<p>这个repo记录着许许多多第三方库的地址，默认选择了github作为源，假如开发者需要升级repo，实际上就是从github上面把一个庞大无比的地址list克隆到本地一个叫什么 .CocoaPods之类的隐藏文件夹里面。<br>通过下面的方法替换掉源</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ pod repo remove master</div><div class="line">$ pod repo add master https://gitcafe.com/akuandev/Specs.git</div><div class="line">$ pod repo update</div></pre></td></tr></table></figure>
<p>目前可选源举例:<br><code>source &#39;https://github.com/CocoaPods/Specs.git&#39;</code></p>
<p>完成了上述两处地方更改之后，就可以直接使用</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ pod install</div><div class="line">$ pod update</div></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p><br></p>
<h2 id="二-使用-CocoaPods"><a href="#二-使用-CocoaPods" class="headerlink" title="二. 使用 CocoaPods"></a>二. 使用 CocoaPods</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">pod search JSONKit</div><div class="line">touch Podfile</div><div class="line">open -e Podfile</div><div class="line">platform <span class="symbol">:ios</span></div><div class="line"> </div><div class="line">pod <span class="string">'JSONKit'</span>, <span class="string">'~&gt; 1.5pre'</span></div><div class="line">pod install</div></pre></td></tr></table></figure>
<ul>
<li>Podfile中具体内容 :</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">platform <span class="symbol">:ios</span></div><div class="line">pod <span class="string">'Reachability'</span>, <span class="string">'3.1.0'</span></div><div class="line"><span class="symbol">platform:</span>ios, <span class="string">'6.0'</span></div><div class="line">pod <span class="string">'JSONKit'</span>,<span class="string">'1.4'</span></div><div class="line">pod <span class="string">'AFNetworking'</span>, <span class="string">'~&gt; 2.3.1'</span></div></pre></td></tr></table></figure>
<p>一些说明: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">pod ‘AFNetworking’      //不显式指定依赖库版本，表示每次都获取最新版本</div><div class="line">pod ‘AFNetworking’,  ‘2.0’     //只使用2.0版本</div><div class="line">pod ‘AFNetworking’, ‘&gt;2.0′     //使用高于2.0的版本</div><div class="line">pod ‘AFNetworking’, ‘&gt;=2.0′     //使用大于或等于2.0的版本</div><div class="line">pod ‘AFNetworking’, ‘&lt;2.0′     //使用小于2.0的版本</div><div class="line">pod ‘AFNetworking’, ‘&lt;=2.0′     //使用小于或等于2.0的版本</div><div class="line">pod ‘AFNetworking’, ‘~&gt;0.1.2′     //使用大于等于0.1.2但小于0.2的版本，相当于&gt;=0.1.2并且&lt;0.2.0</div><div class="line">pod ‘AFNetworking’, ‘~&gt;0.1′     //使用大于等于0.1但小于1.0的版本</div><div class="line">pod ‘AFNetworking’, ‘~&gt;0′ //高于0的版本，写这个限制和什么都不写是一个效果，都表示使用最新版本</div></pre></td></tr></table></figure>
<p>当发现无法引入库时, 尝试下面这个方法<br>可以在target-Build Settings下修改“User Header Search Paths”项，新增<code>${SRCROOT}</code>并选择<code>rcursive</code></p>
<p><br></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GCD处理多个异步处理的同步方法]]></title>
      <url>http://www.donglyu.com/2016/02/08/GCD%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h4 id="1-并行队列中执行任务-并在并行队列中加入多个串行队列"><a href="#1-并行队列中执行任务-并在并行队列中加入多个串行队列" class="headerlink" title="1.并行队列中执行任务, 并在并行队列中加入多个串行队列"></a>1.并行队列中执行任务, 并在并行队列中加入多个串行队列</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line"></div><div class="line"><span class="comment">// Start the first service</span></div><div class="line">dispatch_group_enter(group);</div><div class="line">[<span class="keyword">self</span>.configService startWithCompletion:^(ConfigResponse *results, <span class="built_in">NSError</span>* error)&#123;</div><div class="line">    <span class="comment">// Do something with the results</span></div><div class="line">    configError = error;</div><div class="line">    dispatch_group_leave(group);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// Start the second service</span></div><div class="line">dispatch_group_enter(group);</div><div class="line"><span class="comment">//异步操作(网络请求等)</span></div><div class="line">[<span class="keyword">self</span>.preferenceService startWithCompletion:^(PreferenceResponse *results, <span class="built_in">NSError</span>* error)&#123;</div><div class="line">    <span class="comment">// Do something with the results</span></div><div class="line">    preferenceError = error;</div><div class="line">    dispatch_group_leave(group);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 监视队列中的任务都结束后, 汇总结果</span></div><div class="line">dispatch_group_notify(group,dispatch_get_main_queue(),^&#123;</div><div class="line">    <span class="comment">// Assess any errors</span></div><div class="line">    <span class="built_in">NSError</span> *overallError = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">if</span> (configError || preferenceError)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// Either make a new error or assign one of them to the overall error</span></div><div class="line">        overallError = configError ?: preferenceError;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Now call the final completion block</span></div><div class="line">    completion(overallError);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="2-信号量"><a href="#2-信号量" class="headerlink" title="2. 信号量"></a>2. 信号量</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在创建信号量后, block中方法执行完后才会接着执行</span></div><div class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"MJPhotoBrowserForAsset"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"></div><div class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line"></div><div class="line">            [assetsLibrary assetForURL:mediaItem.assetURL resultBlock:^(ALAsset *asset) &#123;</div><div class="line"></div><div class="line">                mediaItem.curAsset = asset;</div><div class="line"></div><div class="line">                photo.image = [<span class="built_in">UIImage</span> imageWithCGImage:asset.defaultRepresentation.fullScreenImage];</div><div class="line"></div><div class="line">                dispatch_semaphore_signal(semaphore);</div><div class="line"></div><div class="line">            &#125; failureBlock:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line"></div><div class="line">                mediaItem.curAsset = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">                photo.url = [<span class="built_in">NSURL</span> URLWithString:mediaItem.urlStr]; <span class="comment">// 图片路径</span></div><div class="line"></div><div class="line">                dispatch_semaphore_signal(semaphore);</div><div class="line"></div><div class="line">            &#125;];</div><div class="line"></div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UITextView,UITextField记录]]></title>
      <url>http://www.donglyu.com/2016/02/01/UITextView,UITextField%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h4 id="一-UITextView"><a href="#一-UITextView" class="headerlink" title="一.UITextView"></a>一.UITextView</h4><p>1.点击return,隐藏键盘</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 实现UITextViewDelegate shouldChangeTextInRange方法</span></div><div class="line">-(<span class="built_in">BOOL</span>)textView:(<span class="built_in">UITextView</span> *)textView shouldChangeTextInRange:(<span class="built_in">NSRange</span>)range replacementText:(<span class="built_in">NSString</span>*)text </div><div class="line">&#123; </div><div class="line">    <span class="keyword">if</span> ([text isEqualToString:<span class="string">@"\n"</span>]) &#123; </div><div class="line">        [textView resignFirstResponder];  </div><div class="line">       <span class="keyword">return</span> <span class="literal">NO</span>; </div><div class="line">   &#125; </div><div class="line">   <span class="keyword">return</span> <span class="literal">YES</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="二-UITextField"><a href="#二-UITextField" class="headerlink" title="二. UITextField"></a>二. UITextField</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">当你想要收回弹出的键盘时却发现平时用的resignFirstResponder和endEditing都失去作用时，应该考虑一下当前的TextField是否为第一响应者，如果不是第一响应者的话，自然下面的几个方法都没有效果，解决办法有二：<span class="number">1</span>、找出当前第一响应者，然后resignFirstResponder。<span class="number">2</span>、先对TextField becomeFirstResponder 然后再 resignFirstResponder 。</div><div class="line"></div><div class="line">[<span class="keyword">self</span>.view endEditing:<span class="literal">YES</span>];  </div><div class="line">[<span class="keyword">self</span>.field resignFirstResponder];  </div><div class="line">[[<span class="built_in">UIApplication</span> sharedApplication].keyWindow endEditing:<span class="literal">YES</span>];  </div><div class="line">﻿</div><div class="line"></div><div class="line">当上面的方法都无效的时候，可以考虑用下面的方法：</div><div class="line"></div><div class="line"><span class="comment">// Presentation modes may keep the keyboard visible when not required. Default implementation affects UIModalPresentationFormSheet visibility.</span></div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)disablesAutomaticKeyboardDismissal <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">4</span>_3);</div><div class="line"></div><div class="line">直接<span class="keyword">return</span> <span class="literal">NO</span> 就好了。</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Markdown利器]]></title>
      <url>http://www.donglyu.com/2016/01/09/Markdown%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="http://macdown.uranusjr.com" target="_blank" rel="external">MacDown</a><br>Markdown, 可以实时看到代码效果             </li>
</ul>
<a id="more"></a>
<ul>
<li><a href="http://example.nehttp://www.typora.io/" target="_blank" rel="external">Typora</a><br>简单高效, 能够在在markdown和html格式自由复制粘贴, 比较智能, 推荐使用!</li>
<li><a href="http://25.io/mou/" target="_blank" rel="external">Mou</a><br>这个可以的,可以实时预览编辑效果.棒!</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[给项目添加一个合适的开源许可证]]></title>
      <url>http://www.donglyu.com/2016/01/08/%E7%BB%99%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%90%88%E9%80%82%E7%9A%84%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81/</url>
      <content type="html"><![CDATA[<p>将项目与代码开源，可以让更多的人与你共享代码，协同合作，让产品质量更高，更加适应社会的需求。然而，这并不代表该项目是可以被随意甚至是滥用的，想要成为真正的开源项目，不是单单把源代码开放在网上即可，必须在释出的项目当中说明，其代码是以某个开源许可证 (Open Source License) 来进行许可，将特定权利赋予给用户的同时，也规范公众的利用行为，让人们正确的享受开源所带来的好处与乐趣。</p>
<h3 id="开源许可证是什么"><a href="#开源许可证是什么" class="headerlink" title="开源许可证是什么"></a><strong>开源许可证是什么</strong></h3><p>为了维护作者和贡献者的合法权利，保证这些软件不被一些商业机构或个人窃取，影响软件的发展，开源社区开发出了各种的开源许可协议。许可证是具有法律效应的协议，目前已有超过 70 种被开放源代码促进会 (Open Source Initiative, OSI) 通过，其中 GPL、LGPL、Apache、BSD、MIT 等是最常见的。</p>
<h3 id="如何选择开源许可证"><a href="#如何选择开源许可证" class="headerlink" title="如何选择开源许可证"></a><strong>如何选择开源许可证</strong></h3><p>如何在这么多的许可证中选取一个适合自己项目的呢？我们可以通过下面这张图清晰地了解：</p>
<p><a href="http://blog.gitcafe.com/wp-content/uploads/2015/07/bg2011050101.png" target="_blank" rel="external"><img src="http://blog.gitcafe.com/wp-content/uploads/2015/07/bg2011050101.png" alt="bg201105010\"></a></p>
<p>图片来源于阮一峰的博客。</p>
<p>具体而言，这几种开源许可证的特点为：</p>
<h4 id="GNU-Lesser-General-Public-License-LGPL"><a href="#GNU-Lesser-General-Public-License-LGPL" class="headerlink" title="GNU Lesser General Public License (LGPL)"></a><strong>GNU Lesser General Public License (LGPL)</strong></h4><p>允许商业软件通过类库引用 (link) 方式使用 LGPL 类库而不需要开源商业软件的代码，但是如果修改 LGPL 协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用 LGPL 协议。。</p>
<h4 id="Mozilla-Public-License-MPL"><a href="#Mozilla-Public-License-MPL" class="headerlink" title="Mozilla Public License (MPL)"></a><strong>Mozilla Public License (MPL)</strong></h4><p>除了接口程序的源代码以 MPL 许可证的形式对外许可外，源代码库中的源代码就可以不用 MPL 许可证的方式强制对外许可。</p>
<h4 id="GNU-General-Public-License-GPL"><a href="#GNU-General-Public-License-GPL" class="headerlink" title="GNU General Public License (GPL)"></a><strong>GNU General Public License (GPL)</strong></h4><p>可以开源或者免费地使用代码与引用、修改衍生代码，但强制修改后和衍生的代码必须在发布和销售时也必须开放源代码给用户，因此经常与闭源商业软件的商业模式有所冲突。</p>
<h4 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a><strong>BSD</strong></h4><p>可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布，要包含许可协议的声明，但是不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。</p>
<h4 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a><strong>MIT</strong></h4><p>你必须在你的发行版里包含原许可协议的声明，无论你是以二进制发布的还是以源代码发布的。</p>
<h4 id="Apache-Licence"><a href="#Apache-Licence" class="headerlink" title="Apache Licence"></a><strong>Apache Licence</strong></h4><p>著名的非盈利开源组织 Apache 基金会采用的协议。该协议鼓励代码共享和尊重原作者的著作权，同样允许代码修改，作为开源或者商业软件再发布。</p>
<p>如果要在GitHub &amp; GitCafe等平台上发布开源代码就需要添加开源许可.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2015, 停滞, 行进, 停滞, 行进, 快步行进的一年]]></title>
      <url>http://www.donglyu.com/2015/12/31/2015%E5%81%9C%E6%BB%9E,%20%E8%A1%8C%E8%BF%9B,%20%E5%81%9C%E6%BB%9E,%20%E8%A1%8C%E8%BF%9B,%E5%BF%AB%E6%AD%A5%E8%A1%8C%E8%BF%9B%E7%9A%84%E4%B8%80%E5%B9%B4/</url>
      <content type="html"><![CDATA[<p>日历又要到翻到2016年了. 不同于上半年的玩玩耍耍过去了, 下半年更加的充实, 学的更多了, 更重要的有了明确的目标和方向了.  </p>
<p>越来越意识到自己的不足之处,  生活上2016希望能处理的更好, 待人处事, 沟通交流, 衣着, 形体, 感觉好多好多, 人丑多读书, 希望慢慢做到, 一步步改善, 在忘了的事, 看看希望的样子, 提醒和鞭策一下</p>
<p>少些时间去耍和去做无意义的事</p>
<p>工作上, 兴趣是最好的老师, 做iOS还是很有乐趣的. 看了很多的iOS前辈的经验, 总是有很多感触, 有冲动做一件事, 就要持续去做, done</p>
<p> 总是比不做, 做一半好. 有很多期望, 近几几个月的经验:拆分大的长的任务为一个个小任务, 来分别完成,真的很好使….</p>
<p>用好工具, 吸收和学习别人优秀的成果, 提升影响力. 工作上体现出差异性</p>
<p>用好github, 自己搭的blog, 这在以后是个绝好的工作敲门砖. 简书,博客园还是太小了…墙外的东西很多, 加以利用是绝好的.</p>
<p>思维导图要用好, 在某些时候对自身理解帮助很大.</p>
<p>尝试做出一些有帮助意义的具有”高感知价值的物品”</p>
<p>要想获得更多,得付出更多</p>
<p>学习一些公司愿意付钱的技术.~~~</p>
<p>另外, 英语!!!!!. 一方面更多的看国外开发文档, 确实很多英文资料更全, 讲的更透彻.</p>
<p>心里不太平静时, 听听歌,调解下.</p>
<p>2016, 快节奏工作学习的一年!!!! 期待</p>
<p><img src="http://ww3.sinaimg.cn/large/923848a3gw1ezj988mqizj20hs0hsq47.jpg" alt="http://ww3.sinaimg.cn/large/923848a3gw1ezj988mqizj20hs0hsq47.jpg"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[鸡汤一枚]]></title>
      <url>http://www.donglyu.com/2015/12/10/%E9%B8%A1%E6%B1%A4%E4%B8%80%E6%9E%9A/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">一、 素养   </div><div class="line">``` </div><div class="line"></div><div class="line">　　蓝斯登原则：在你往上爬的时候，一定要保持梯子的整洁，否则你下来时可能会滑倒。  </div><div class="line"></div><div class="line">　　提出者：美国管理学家蓝斯登。  </div><div class="line"></div><div class="line">　　点评：进退有度，才不至进退维谷；宠辱皆忘，方可以宠辱不惊。  </div><div class="line"></div><div class="line">　　</div><div class="line"></div><div class="line">　　卢维斯定理 ：谦虚不是把自己想得很糟，而是完全不想自己。  </div><div class="line"></div><div class="line">　　提出者：美国心理学家卢维斯  </div><div class="line"></div><div class="line">　　点评：如果把自己想得太好，就很容易将别人想得很糟。  </div><div class="line">　　　</div><div class="line">　　托利得定理： 测验一个人的智力是否属于上乘，只看脑子里能否同时容纳两种相反的思想，而无碍于其处世行事。  </div><div class="line"></div><div class="line">　　提出者：法国社会心理学家托利得  </div><div class="line"></div><div class="line">　　点评：思可相反，得须相成。    相关阅读：《如何提高你的思考能力》</div><div class="line"></div><div class="line">&lt;!-- more --&gt;</div><div class="line"></div><div class="line">``` </div><div class="line"> 二、统御</div></pre></td></tr></table></figure>
<p>　　</p>
<p>　　刺猬理论 ：刺猬在天冷时彼此靠拢取暖，但保持一定距离，以免互相刺伤。  </p>
<p>　　点评：保持亲密的重要方法，乃是保持适当的距离。  </p>
<p>　　</p>
<p>　　鲦鱼效应  </p>
<p>　　：鲦鱼因个体弱小而常常群居，并以强健者为自然首领。将一只稍强的鲦鱼脑后控制行为的部分割除后，此鱼便失去自制力，行动也发生紊乱，但其他鲦鱼却仍像从前一样盲目追随。  </p>
<p>　　</p>
<p>　　提出者：德国动物学家霍斯特  </p>
<p>　　点评：1、下属的悲剧总是领导一手造成的。 2、下属觉得最没劲的事，是他们跟着一位最差劲的领导。  </p>
<p>　　</p>
<p>　　雷鲍夫法则 ：在你着手建立合作和信任时要牢记我们语言中：  </p>
<p>　　1、最重要的八个字是：我承认我犯过错误  </p>
<p>　　2、最重要的七个字是：你干了一件好事  </p>
<p>　　3、最重要的六个字是：你的看法如何  </p>
<p>　　4、最重要的五个字是：咱们一起干  </p>
<p>　　5、最重要的四个字是：不妨试试  </p>
<p>　　6、最重要的三个字是：谢谢您  </p>
<p>　　7、最重要的两个字是：咱们  </p>
<p>　　8、最重要的一个字是：您  </p>
<p>　　提出者：美国管理学家雷鲍夫  </p>
<p>　　点评：1、最重要的四个字是：不妨试试； 2、最重要的一个字是：您  </p>
<p>　　</p>
<p>　　洛伯定理 ：对于一个经理人来说，最要紧的不是你在场时的情况，而是你不在场时发生了什么。  </p>
<p>　　提出者：美国管理学家洛伯  </p>
<p>　　点评：如果只想让下属听你的，那么当你不在身边时他们就不知道应该听谁的了。    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">三、沟通</div></pre></td></tr></table></figure>
<p>　　</p>
<p>　　斯坦纳定理 ：在哪里说得愈少，在哪里听到的就愈多。  </p>
<p>　　提出者：美国心理学家斯坦纳  </p>
<p>　　点评：只有很好听取别人的，才能更好说出自己的。  </p>
<p>　　</p>
<p>　　费斯诺定理：人两只耳朵却只有一张嘴巴，这意味着人应该多听少讲。  </p>
<p>　　提出者：英国联合航空公司总裁兼总经理费斯诺  </p>
<p>　　点评：说得过多了，说的就会成为做的障碍。  </p>
<p>　　</p>
<p>　　牢骚效应 ：凡是公司中有对工作发牢骚的人，那家公司或老板一定比没有这种人或有这种人而把牢骚埋在肚子里公司要成功得多。  </p>
<p>　　提出者：美国密歇根大学社会研究院  </p>
<p>　　点评：1、牢骚是改变不合理现状的催化剂。 2、牢骚虽不总是正确的，但认真对待牢骚却总是正确的。  </p>
<p>　　</p>
<p>　　避雷针效应  </p>
<p>　　：在高大建筑物顶端安装一个金属棒，用金属线与埋在地下的一块金属板连接起来，利用金属棒的尖端放电，使云层所带的电和地上的电逐渐中和，从而保护建筑物等避免雷击。  </p>
<p>　　点评：善疏则通，能导必安  相关阅读：《怎样才是有效沟通》</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">四、协调</div></pre></td></tr></table></figure>
<p>　　</p>
<p>　　氨基酸组合效应 ：组成人体蛋白的八种氨基酸，只要有一种含量不足，其他七种就无法合成蛋白质。  </p>
<p>　　点评：当缺一不可时，一就是一切。  </p>
<p>　　</p>
<p>　　米格-25效应  </p>
<p>：前苏联研制的米格-25喷气式战斗机的许多零部件与美国的相比都落后，但因设计者考虑了整体性能，故能在升降、速度、应急反应等方面成为当时世界一流。  </p>
<p>　　</p>
<p>　　点评：所谓最佳整体，乃是个体的最佳组合。  </p>
<p>　　</p>
<p>　　磨合效应 ：新组装的机器，通过一定时期的使用，把磨擦面上的加工痕迹磨光而变得更加密合。  </p>
<p>　　点评：要想达到完整的契合，须双方都做出必要的割舍。  
　　</p>
<pre><code>五、指导  
</code></pre><p>　　波特定理 ：当遭受许多批评时，下级往往只记住开头的一些，其余就不听了，因为他们忙于思索论据来反驳开头的批评。  </p>
<p>　　提出者：英国行为学家波特  </p>
<p>　　点评：总盯着下属的失误，是一个领导者的最大失误。  </p>
<p>　　</p>
<p>　　蓝斯登定律 ：跟一位朋友一起工作，远较在父亲之下工作有趣得多。  </p>
<p>　　提出者：美国管理学家蓝斯登  </p>
<p>　　点评：可敬不可亲，终难敬；有权没有威，常失权。  </p>
<p>　　</p>
<p>　　吉尔伯特法则 ：工作危机最确凿的信号，是没有人跟你说该怎样作。  </p>
<p>　　提出者：英国人力培训专家吉尔伯特  </p>
<p>　　点评：真正危险的事，是没人跟你谈危险。  </p>
<p>　　</p>
<p>　　权威暗示效应  </p>
<p>　　：一化学家称，他将测验一瓶臭气的传播速度，他打开瓶盖15秒后，前排学生即举手，称自己闻到臭气，而后排的人则陆续举手，纷纷称自己也已闻到，其实瓶中什么也没有。  </p>
<p>　　点评：迷信则轻信，盲目必盲从。      </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">六、组织</div></pre></td></tr></table></figure>
<p>　　</p>
<p>　　奥尼尔定理 ：所有的政治都是地方的。  </p>
<p>　　提出者：美国前众议院院长奥尼尔  </p>
<p>　　点评：只有能切身体会到的，群众才认为那是真实的。  </p>
<p>　　</p>
<p>　　定位效应：  </p>
<p>　　社会心理学家曾作过一个试验：在召集会议时先让人们自由选择位子，之后到室外休息片刻再进入室内入座，如此五至六次，发现大多数人都选择他们第一次坐过的位子。  </p>
<p>　　点评：凡是自己认定的，人们大都不想轻易改变它。  </p>
<p>　　</p>
<p>　　艾奇布恩定理 ：如果你遇见员工而不认得，或忘了他的名字，那你的公司就太大了点。  </p>
<p>　　提出者：英国史蒂芬约瑟剧院导演亚伦艾奇布恩  </p>
<p>　　点评：摊子一旦铺得过大，你就很难把它照顾周全。        </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">七、培养</div></pre></td></tr></table></figure>
<p>　　</p>
<p>　　吉格勒定理 ：除了生命本身，没有任何才能不需要后天的锻炼。  </p>
<p>　　提出者：美国培训专家吉格吉格勒  </p>
<p>　　点评：水无积无辽阔，人不养不成才。  </p>
<p>　　</p>
<p>　　犬獒效应  </p>
<p>　　：当年幼的藏犬长出牙齿并能撕咬时，主人就把它们放到一个没有食物和水的封闭环境里让这些幼犬自相撕咬，最后剩下一只活着的犬，这只犬称为獒。据说十只犬才能产生一只獒。  </p>
<p>　　点评：困境是造就强者的学校。        </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">八、选拔</div></pre></td></tr></table></figure>
<p>　　</p>
<p>　　近因效应 ：最近或最后的印象对人的认知有强烈的影响。  </p>
<p>　　提出者：美国社会心理学家洛钦斯。  </p>
<p>　　点评：结果往往会被视为过程的总结。  </p>
<p>　　</p>
<p>　　洒井法则 ：在招工时用尽浑身解数，使出各种方法，不如使自身成为一个好公司，这样人才自然而然会汇集而来。  </p>
<p>　　提出者：日本企业管理顾问酒井正敬。  </p>
<p>　　点评：不能吸引人才，已有的人才也留不住。  </p>
<p>　　</p>
<p>　　美即好效应 ：对一个外表英俊漂亮的人，人们很容易误认为他或她的其他方面也很不错。  </p>
<p>　　提出者：美国心理学家丹尼尔麦克尼尔。  </p>
<p>　　点评：印象一旦以情绪为基础，这一印象常会偏离事实。    </p>
<p>   　　</p>
<p>　　奥格尔维法则 ：如果我们每个人都雇用比我们自己都更强的人，我们就能成为巨人公司。  </p>
<p>　　提出者：美国奥格尔维马瑟公司总裁奥格尔维。  </p>
<p>　　点评：如果你所用的人都比你差，那么他们就只能作出比你更差的事情。  </p>
<p>　　</p>
<p>　　皮尔卡丹定理 ：用人上一加一不等于二，搞不好等于零。  </p>
<p>　　提出者：法国著名企业家皮尔卡丹。  </p>
<p>　　点评：组合失当，常失整体优势，安排得宜，才成最佳配置。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">十、激励</div></pre></td></tr></table></figure>
<p>　　</p>
<p>　　马蝇效应 ：再懒惰的马，只要身上有马蝇叮咬，它也会精神抖擞，飞快奔跑。  </p>
<p>　　点评：有正确的刺激，才会有正确的反应。  </p>
<p>　　</p>
<p>　　倒u形假说  </p>
<p>　　当一个人处于轻度兴奋时，能把工作作得最好。当一个人一点儿兴奋都没有时，也就没有作好工作的动力了；相应地，当一个人处于极</p>
<p>度兴奋时，随之而来的压力可能会使他完不成本该完成的工作。世界网坛名将贝克尔之所以被称为常胜将军，其秘诀之一即是在比赛中自始至</p>
<p>终防止过度兴奋，而保持半兴奋状态。所以有人亦将倒u形假说称为贝克尔境界。  </p>
<p>　　提出者：英国心理学家罗伯特?耶基斯和多德林。  </p>
<p>　　点评：1、激情过热，激情就会把理智烧光。 2、热情中的冷静让人清醒，冷静中的热情使人执着。 </p>
<hr>
<p>　　<br>End!</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS GCD记录]]></title>
      <url>http://www.donglyu.com/2015/12/07/iOS-GCD%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h4 id="GCD异步"><a href="#GCD异步" class="headerlink" title="GCD异步"></a>GCD异步</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123; </div><div class="line">   <span class="comment">// 处理耗时操作的代码块...</span></div><div class="line">   <span class="comment">// do something.</span></div><div class="line"><span class="comment">//通知主线程刷新 </span></div><div class="line">	<span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123; </div><div class="line">	<span class="comment">//回调或者说是通知主线程刷新，  </span></div><div class="line">	&#125;); </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>dispatch_async开启一个异步操作，第一个参数是指定一个gcd队列，第二个参数是分配一个处理事物的程序块到该队列。 </p>
<p>dispatch_get_global_queue(0, 0)，指用了全局队列。 </p>
<p>一般来说系统本身会有3个队列。 </p>
<p>global_queue，current_queue,以及main_queue. </p>
<p>获取一个全局队列是接受两个参数，第一个是我分配的事物处理程序块队列优先级。分高低和默认，0为默认2为高，-2为低 </p>
<p>======</p>
<h4 id="GCD之并发概念"><a href="#GCD之并发概念" class="headerlink" title="GCD之并发概念:"></a>GCD之并发概念:</h4><p>异步的核心概念就是一个新线程，一个消息回调通知。 </p>
<p>异步解决了线程堵塞，而并发则是在异步的基础上，提高了符合特性事件的处理时间效率</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;  </div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">NSURL</span> * url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://avatar.csdn.net/2/C/D/1_totogo2010.jpg"</span>];  </div><div class="line"></div><div class="line"><span class="built_in">NSData</span> * data = [[<span class="built_in">NSData</span> alloc]initWithContentsOfURL:url];  </div><div class="line"></div><div class="line"><span class="built_in">UIImage</span> *image = [[<span class="built_in">UIImage</span> alloc]initWithData:data];  </div><div class="line"></div><div class="line"><span class="keyword">if</span> (data != <span class="literal">nil</span>) &#123;  </div><div class="line"></div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;  </div><div class="line"></div><div class="line">        <span class="keyword">self</span>.imageView.image = image;  </div><div class="line"></div><div class="line">     &#125;);  </div><div class="line"></div><div class="line">&#125;  </div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<hr>
<h4 id="iOS下使用block-GCD实现异步处理"><a href="#iOS下使用block-GCD实现异步处理" class="headerlink" title="iOS下使用block+GCD实现异步处理."></a>iOS下使用block+GCD实现异步处理.</h4><p>文章原地址: <a href="http://my.oschina.net/fvmitnick/blog/185089?fromerr=xpS0DGVX" target="_blank" rel="external">http://my.oschina.net/fvmitnick/blog/185089?fromerr=xpS0DGVX</a></p>
<ul>
<li>因为任何对UI的操作，在iOS中实际上并不是立刻执行，只是做了个<em>标记</em>，在当前事件循环(runloop)完成后，在下一个事件循环开始前，系统根据做的标记来决定屏幕哪一块需要更新，并进行重绘.</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不论哪种异步方式，最后一定要有一个办法通知主线程任务已完成。具体到iOS，有若干方法可以使用，比如：</span></div><div class="line"></div><div class="line"><span class="comment">// delegate, KVO, NSNotification, performSelectorOnMainThread:等。</span></div><div class="line"><span class="comment">//使用KVO方式观察后台任务的结束</span></div><div class="line"></div><div class="line">[calcOperation addObserver:<span class="keyword">self</span> keyPath:<span class="string">@"isFinished"</span>...];</div><div class="line">- (<span class="keyword">void</span>) observeValueForKey:keyPath ofObject:object . &#123;</div><div class="line">  <span class="keyword">if</span>([<span class="string">@"isFinished"</span> isEqualToString:keyPath] &amp;&amp; [object isKindOfClass:[MyPICalcOperation <span class="keyword">class</span>]]) &#123;</div><div class="line">  	<span class="comment">// 观察到了我们想要的状态变化，即运算结束。这里我们调用回调处理结果。确保回调在主线程上进行</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#####注意事项:</p>
<ol>
<li>UI操作必须在主线程上完成。</li>
<li>耗时的同步网络、同步IO、运算等操作不要在主线程上跑，以避免阻塞</li>
<li>一个好的程序，对任何耗时操作都要给用户提供半路取消的选择。要做到这一点，还是需要增加一些代码 </li>
<li>block就象一个object，也有自己的生存周期问题，也会出现类似野指针和内存泄漏的情况。如果你自己做一个基于block的异步库供别人使用，非 常容易产生循环引用的错误（对方的app class retain了你的异步库，你的异步库retain了app提供的回调block，而block中一般又通过self引用了app class本身），需要特别小心。 </li>
<li>假如在运算完成前用户就退出这个页面（比如回退到上一页），运算还是会进行，view controller的销毁被延后到运算结束的时候。假如不想要这个效果的话，一是要实现1中的取消机制，二是要在块中避免引用self（否则会被自动 retain）。具体看文档。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CoreData使用记录学习01]]></title>
      <url>http://www.donglyu.com/2015/12/06/CoreData%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A001/</url>
      <content type="html"><![CDATA[<p>Core Data是苹果针对Mac和iOS平台开发的一个框架, 通过CoreData可以在本地生成数据库sqlite,提供了ORM的功能，将对象和数据模型相互转换 . 通过Core Data管理和操作. 能够快速达到项目的存储数据的需求.<br>      CoreData优点：能够合理管理内存，避免使用sql的麻烦，高效, 由于是苹果提供的解决方案, 所以不用太过担心会有其他问题.  我的观念就是先使用上了后再考虑其他, 问题有一个就解决一个.<br>Core Data 默认使用Sqlite. 因此在沙盒Document文件夹中找到.sqlite的数据库文件. </p>
<p> 这里顺便提一个一个比较好用的快速打开模拟器沙盒路径的工具: <a href="https://github.com/opensim/opensim" target="_blank" rel="external">https://github.com/opensim/opensim</a></p>
<h3 id="1-使用CoreData"><a href="#1-使用CoreData" class="headerlink" title="1.使用CoreData"></a>1.使用CoreData</h3><ol>
<li>创建工程时, 勾选Use Core Data</li>
<li>手动添加, (如何要想向创建时没有选择Use Core Data<br>如果不知道该添加什么, 一个比较便捷的方法, 是直接新建一个空白工程, 勾选Use Core Data后, 对比AppDelegate.h中的代码, 然后再将多的内容添加到工程中.)</li>
</ol>
<a id="more"></a>
<p>添加Core Data后, 在AppDelegate.h中就有帮我们生成用于管理、存储这些模型的对象，我们可以通过添加AppDelegate头文件来使用.<br>添加Core Data后, 就是建立数据模型,说到模型, 就要提一下Core Data常用的6个对象：</p>
<blockquote>
<p>1、NSManagedObjectContext<br>管理对象，上下文，持久性存储模型对象<br>2、NSManagedObjectModel<br>被管理的数据模型，数据结构<br>3、NSPersistentStoreCoordinator<br>连接数据库的<br>4、NSManagedObject<br>被管理的数据记录<br>5、NSFetchRequest<br>数据请求<br>6、NSEntityDescription<br>表格实体结构<br>此外还需要知道.xcdatamodel文件编译后为.momd或者.mom文件  </p>
</blockquote>
<p>一.开始  </p>
<blockquote>
<p>右键添加一个Core data -&gt; Data Model(如果创建工程时, 直接勾选use core data, 会直接默认生成.xcdatamodeld).<br>选中.xcdatamodeld主要使用到了下列一些东西:<br>Entity: 实体(我们要生成的模型对象的实体, User, Car, Person等等)<br>Attributes:实体对象属性<br>ReaationShips:关系<br>Fetched Properties:</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1106214-2fa5fda1a8bff45e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="&gt;_&lt;"></p>
<p>另外多表关联内容可以看看: <a href="http://www.jianshu.com/p/e9f3b5e0cd19" target="_blank" rel="external">http://www.jianshu.com/p/e9f3b5e0cd19</a></p>
<p>二.创建实体管理 </p>
<p>右键添加一个Core data -&gt; NSManagedObject subclass, 一直选择,  选中Car, Wheel.  到最后会实现<br><img src="http://upload-images.jianshu.io/upload_images/1106214-265946bce916ef5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20151206-1"></p>
<p>三.导入AppDelegate.h头文件, 开始管理数据库  </p>
<p>主要操作:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//先取出coredata上下文管理者</span></div><div class="line">AppDelegate *appDelegate = [[<span class="built_in">UIApplication</span> sharedApplication] delegate];</div><div class="line"><span class="built_in">NSManagedObjectContext</span> *context = appDelegate.managedObjectContext;</div><div class="line"></div><div class="line"><span class="comment">//1.保存新数据</span></div><div class="line">Car *car = [<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName: <span class="string">@"Car"</span> inManagedObjectContext: context];</div><div class="line">car.carName = label1.text;</div><div class="line">car.carType = label2.text;</div><div class="line">[appDelegate saveContext];</div><div class="line"></div><div class="line"><span class="comment">//2.查询数据</span></div><div class="line"><span class="built_in">NSError</span> *error;</div><div class="line"><span class="built_in">NSFetchRequest</span> *request = [<span class="built_in">NSFetchRequest</span> new];</div><div class="line"><span class="built_in">NSEntityDescription</span> *entity = [<span class="built_in">NSEntityDescription</span> entityForName: <span class="string">@"Car"</span> inManagedObjectContext: context];</div><div class="line">[request setEntity: entity];</div><div class="line"><span class="built_in">NSPredicate</span> *predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"carName=%@"</span>, carName];</div><div class="line">[request setPredicate:predicate];</div><div class="line"><span class="built_in">NSArray</span> *results = [[context executeFetchRequest: request error: &amp;error] <span class="keyword">copy</span>];</div><div class="line"><span class="keyword">for</span> (Car *car <span class="keyword">in</span> results) &#123;</div><div class="line">　	<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, car.carName);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//3.更新数据</span></div><div class="line">&#123;</div><div class="line"><span class="built_in">NSFetchRequest</span>** request=[[<span class="built_in">NSFetchRequest</span> alloc] init];</div><div class="line"><span class="built_in">NSEntityDescription</span> *car=<span class="built_in">NSEntityDescription</span> entityForName:<span class="string">@"car"</span> inManagedObjectContext:_myAppDelegate.managedObjectContext];  </div><div class="line">[request setEntity:car];</div><div class="line"><span class="comment">///查询条件</span></div><div class="line"><span class="built_in">NSPredicate</span>* predicate=[<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"carName==%@"</span>,<span class="string">@"name"</span>];</div><div class="line"> [request setPredicate:predicate];</div><div class="line"><span class="built_in">NSError</span>* error=<span class="literal">nil</span>;</div><div class="line"><span class="built_in">NSMutableArray</span>* mutableFetchResult=[[_myAppDelegate.managedObjectContext executeFetchRequest:request error:&amp;error] mutableCopy]; </div><div class="line"><span class="keyword">if</span> (mutableFetchResult==<span class="literal">nil</span>) &#123;</div><div class="line">　<span class="built_in">NSLog</span>(<span class="string">@"Error:%@"</span>,error); </div><div class="line">&#125;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"The count of entry: %i"</span>,[mutableFetchResult count]);  </div><div class="line"> <span class="keyword">for</span> (Car* car <span class="keyword">in</span> mutableFetchResult) &#123;  </div><div class="line">　car.carName = <span class="string">@"name1"</span>  ;</div><div class="line">    ...    </div><div class="line">&#125; </div><div class="line"><span class="comment">//更新后要进行保存，否则没更新  </span></div><div class="line">[_myAppDelegate.managedObjectContext save:&amp;error];</div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">//4.删除数据  </span></div><div class="line">  &#123;</div><div class="line">  <span class="built_in">NSFetchRequest</span>* request=[[<span class="built_in">NSFetchRequest</span> alloc] init];  </div><div class="line">      <span class="built_in">NSEntityDescription</span>* car=[<span class="built_in">NSEntityDescription</span> entityForName:<span class="string">@"Car"</span> inManagedObjectContext:_myAppDelegate.managedObjectContext];  </div><div class="line">      [request setEntity:car];  </div><div class="line">      <span class="built_in">NSPredicate</span>* predicate=[<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"carName==%@"</span>,<span class="string">@"name"</span>];  </div><div class="line">      [request setPredicate:predicate];  </div><div class="line">      <span class="built_in">NSError</span>* error=<span class="literal">nil</span>;  </div><div class="line">      <span class="built_in">NSMutableArray</span>* mutableFetchResult=[[_myAppDelegate.managedObjectContext executeFetchRequest:request error:&amp;error] mutableCopy];  </div><div class="line">      <span class="keyword">if</span> (mutableFetchResult==<span class="literal">nil</span>) &#123;  </div><div class="line">  　 <span class="built_in">NSLog</span>(<span class="string">@"Error:%@"</span>,error);  </div><div class="line">      &#125;  </div><div class="line">      <span class="built_in">NSLog</span>(<span class="string">@"The count of entry: %i"</span>,[mutableFetchResult count]);  </div><div class="line">      <span class="keyword">for</span> (Car *car <span class="keyword">in</span> mutableFetchResult) &#123;  </div><div class="line">  　　 [_myAppDelegate.managedObjectContext deleteObject:car];  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">if</span> ([_myAppDelegate.managedObjectContext save:&amp;error]) &#123;  </div><div class="line">  　<span class="built_in">NSLog</span>(<span class="string">@"Error:%@,%@"</span>,error,[error userInfo]);  </div><div class="line">  　&#125;  </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>条件查询的更多内容, 可以查看官方文档:<br><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Predicates/Articles/pCreating.html" target="_blank" rel="external">https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Predicates/Articles/pCreating.html</a></li>
</ul>
<h3 id="2-NSFetchRequest-常用方法-setEntity"><a href="#2-NSFetchRequest-常用方法-setEntity" class="headerlink" title="2.NSFetchRequest 常用方法 -setEntity:"></a>2.NSFetchRequest 常用方法 -setEntity:</h3><p>设置你要查询的数据对象的类型（Entity）</p>
<ul>
<li>-setPredicate:<br>设置查询条件</li>
<li>-setFetchLimit:<br>设置最大查询对象数目</li>
<li>-setSortDescriptors:<br>设置查询结果的排序方法  </li>
</ul>
<ul>
<li>-setAffectedStores:<br>设置可以在哪些数据存储中查询<br>[request setFetchBatchSize:500];//从数据库里每次加载500条数据来筛选数据<br>[request setFetchOffset:sizeCount];//读取数据库的游标偏移量，从游标开始读取数据<br>sizeCount = 10;<br>[request setFetchLimit:10];//每次要取多少条数据，10就是每次从数据库读取10条数据<br>NSPredicate用于查询和过滤<br>在SQL中作为查询条件通常用WHERE，但在COREDATA中作为查询条件就可以用到NSPredicate.<br>NSPredicate 不单可以和COREDATA中的FetchRequest 配合使用。也可以与NSArray配合使用<br>一个线程用一个NSManagedObjectContext对象.<br>使用coredata 在项目中建立表，它会自己来生成数据库，而在每个表中都有它自己生成的Z_PK,Z_ENT,Z_OPT 这三个字段，<br>Z_PK     表的主键，从1开始递增， 具有唯一性<br>可以通过主键访问和获取对象的途径:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSFetchRequest</span>* request = [[<span class="built_in">NSFetchRequest</span> alloc] init];</div><div class="line">request setEntity:entity];</div><div class="line">[request setResultType:<span class="built_in">NSManagedObjectIDResultType</span>];</div><div class="line">[request setFetchBatchSize:<span class="number">20</span>];</div><div class="line"><span class="built_in">NSError</span>* error = <span class="literal">nil</span>;</div><div class="line"><span class="built_in">NSArray</span>* items = [context executeFetchRequest:request error:&amp;error];</div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSManagedObjectID</span>* objectID <span class="keyword">in</span> items) &#123;</div><div class="line">　<span class="built_in">NSManagedObject</span>* object = [context objectWithID:objectID];</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Z_ENT  表在xcdatamodel 中的索引值，如果有6个表那么它的值的区间就是[1,6 ]<br>Z_OPT  表示的是每条数据被操作的次数，初始化值为1，只要是增删改查都会加1</p>
<h3 id="3-其他记录"><a href="#3-其他记录" class="headerlink" title="3.其他记录"></a>3.其他记录</h3><blockquote>
<p>方便查阅<br>1.通过core data存储任意类型的数据:<a href="http://blog.csdn.net/likendsl/article/details/8549333" target="_blank" rel="external">http://blog.csdn.net/likendsl/article/details/8549333</a><br>2.多表关联时, 动态设置删除关系.:<a href="http://blog.csdn.net/fengsh998/article/details/8090111" target="_blank" rel="external">http://blog.csdn.net/fengsh998/article/details/8090111</a><br>3.批量操作、聚合操作、WWDC 2015新特性: <a href="http://www.cocoachina.com/ios/20150730/12785.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20150730/12785.html</a>  </p>
</blockquote>
<h3 id="4-问题记录"><a href="#4-问题记录" class="headerlink" title="4.问题记录"></a>4.问题记录</h3><blockquote>
<p>当查询返回数据是fault时,  可以加上这句试试:<br>[request setReturnsObjectsAsFaults:NO];</p>
</blockquote>
<p>学习记录, 难免可能会有不准确的, 多多包涵~~</p>
<p>End!</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS三方轮子整理]]></title>
      <url>http://www.donglyu.com/2015/11/06/iOS%E4%B8%89%E6%96%B9%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<p>写在前面:  下面的这些都是在开发和学习过程中, 看到不错的内容, 在这儿, 统一做个整理, 需要的时候再研究下.<br>持续更新~~</p>
<p>========</p>
<p>##其他开源项目或者或者学习资料:</p>
<ul>
<li><p><a href="http://gold.xitu.io/entry/5632e66400b00ca870769c76" target="_blank" rel="external">海量iOS及Mac开源项目和学习资料</a></p>
</li>
<li><p><a href="http://www.52codes.net/article/465.html" target="_blank" rel="external">iOS及Mac开源项目和学习资料【超级全面】</a></p>
</li>
<li><p><a href="http://www.henishuo.com/ios-app-fully-code/" target="_blank" rel="external">iOS完整App资源收集(包括很多完整开源app)</a></p>
</li>
<li><p><a href="https://github.com/jobbole/awesome-ios-cn" target="_blank" rel="external">iOS资源大全中文版</a> GitHub 上有一个 Awesome - XXX 系列的资源整理。awesome-ios 就是 vsouza 发起维护的 iOS 资源列表，内容包括：框架、组件、测试、Apple Store、SDK、XCode、网站、书籍等。Swift 语言写成的项目会被标记为 ★ ，AppleWatch 的项目则会被标记为 ▲。这个就是中文版的.</p>
</li>
<li><p><a href="http://app.memect.com/doc/ios.html" target="_blank" rel="external">iOS资源库列表</a> from App开发日报.和上面这个差不多. </p>
</li>
<li><p><a href="https://github.com/dkhamsing/open-source-ios-apps" target="_blank" rel="external">开源apps: A collaborative list of 401 open-source iOS apps</a></p>
</li>
<li><p><a href="https://github.com/bayandin/awesome-awesomeness" target="_blank" rel="external">A curated list of amazingly awesome awesomeness. Also available on: Awesome-Awesomeness.ZEEF.com</a></p>
</li>
<li><p><a href="http://github.ibireme.com/github/list/ios/" target="_blank" rel="external">iOS GitHub备忘,某人整理的, 还不错</a></p>
</li>
</ul>
<p>========</p>
<h3 id="Menu"><a href="#Menu" class="headerlink" title="Menu"></a>Menu</h3><ul>
<li><a href="https://github.com/KittenYang/KYGooeyMenu" target="_blank" rel="external">带粘性的菜单 KYGooeyMenu</a></li>
<li>ZWSlideViewController  传统切换viewcontroller, 导航栏下也可滑动的那种.</li>
<li>MMDrawerController 普通的侧滑菜单，用MMDrawerController就搞定了。</li>
<li>ZWSlideViewController. is a view controller container that manages a customizable sliding views and menus.</li>
</ul>
<h3 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h3><ul>
<li><a href="https://github.com/nicklockwood/FXBlurView" target="_blank" rel="external">静态,动态模糊效果 FXBlurView</a></li>
</ul>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ul>
<li>PXAlertView 自定义风格的弹框风格.</li>
<li>LGAlertView 另外一个提示框.</li>
</ul>
<h3 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h3><ul>
<li>TTTAttributedLabel： 支持富文本显示的label</li>
<li>TOWebViewController： 内置浏览器 </li>
</ul>
<h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><ul>
<li><a href="https://github.com/suifengqjn/TBPlayer" target="_blank" rel="external">TBPlayer </a>视频边下边播播，把播放器播放过的数据流缓存到本地，支持拖动。采用avplayer</li>
</ul>
<p> ——– End! ———-</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[容易搞混的iOS属性地址整理]]></title>
      <url>http://www.donglyu.com/2015/10/26/%E5%AE%B9%E6%98%93%E6%90%9E%E6%B7%B7%E7%9A%84iOS%E5%B1%9E%E6%80%A7%E5%9C%B0%E5%9D%80%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<p>写在前面:  下面的这些都是在开发和学习过程中, 看到不错的整理, 都是比较小的, 琐碎的, 在这儿, 统一做个整理, 需要的时候再查阅<br>持续更新~~</p>
<p>======<br><a href="http://www.jianshu.com/p/457c80cbb487" target="_blank" rel="external">UINavigationBar属性及返回按钮总结</a></p>
<p><a href="http://www.jianshu.com/p/b2585c37e14b?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note" target="_blank" rel="external">更多的自定义navigationBar</a></p>
<p>====</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UIButton上图下文居中对齐方式]]></title>
      <url>http://www.donglyu.com/2015/10/25/UIButton%E4%B8%8A%E5%9B%BE%E4%B8%8B%E6%96%87%E5%B1%85%E4%B8%AD%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>通常在项目遇到要自定义工具栏, 有需要UIButton, 图片在上, 文字在下,图片文字都居中对齐.使用下面的轮子可以实现,居中对齐文字和图片,还可自定义间距:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">@interface UIButton (UIButtonExt)  </div><div class="line">- (void)centerImageAndTitle:(float)space;  </div><div class="line">- (void)centerImageAndTitle;  </div><div class="line">@end  </div><div class="line"> </div><div class="line">@implementation UIButton (UIButtonExt)  </div><div class="line">- (void)centerImageAndTitle:(float)spacing  </div><div class="line">&#123;      </div><div class="line">    // get the size of the elements here for readability  </div><div class="line">    CGSize imageSize = self.imageView.frame.size;  </div><div class="line">    CGSize titleSize = self.titleLabel.frame.size;  </div><div class="line"> </div><div class="line">    // get the height they will take up as a unit  </div><div class="line">    CGFloat totalHeight = (imageSize.height + titleSize.height + spacing);  </div><div class="line"> </div><div class="line">    // raise the image and push it right to center it  </div><div class="line">    self.imageEdgeInsets = UIEdgeInsetsMake(- (totalHeight - imageSize.height), 0.0, 0.0, - titleSize.width);  </div><div class="line"> </div><div class="line">    // lower the text and push it left to center it  </div><div class="line">    self.titleEdgeInsets = UIEdgeInsetsMake(0.0, - imageSize.width, - (totalHeight - titleSize.height),0.0);      </div><div class="line">&#125;  </div><div class="line"> </div><div class="line">- (void)centerImageAndTitle  </div><div class="line">&#123;  </div><div class="line">    const int DEFAULT_SPACING = 6.0f;  </div><div class="line">    [self centerImageAndTitle:DEFAULT_SPACING];  </div><div class="line"> &#125;  </div><div class="line">@end</div><div class="line">-(void)layoutSubviews &#123;</div><div class="line">    [super layoutSubviews];</div><div class="line"> </div><div class="line">    // Center image</div><div class="line">    CGPoint center = self.imageView.center;</div><div class="line">    center.x = self.frame.size.width/2;</div><div class="line">    center.y = self.imageView.frame.size.height/2;</div><div class="line">    self.imageView.center = center;</div><div class="line"> </div><div class="line">    //Center text</div><div class="line">    CGRect newFrame = [self titleLabel].frame;</div><div class="line">    newFrame.origin.x = 0;</div><div class="line">    newFrame.origin.y = self.imageView.frame.size.height + 5;</div><div class="line">    newFrame.size.width = self.frame.size.width;</div><div class="line"> </div><div class="line">    self.titleLabel.frame = newFrame;</div><div class="line">    self.titleLabel.textAlignment = UITextAlignmentCenter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[4种延时方法]]></title>
      <url>http://www.donglyu.com/2015/10/09/%E5%9B%9B%E7%A7%8D%E5%BB%B6%E6%97%B6%E6%89%A7%E8%A1%8C%E6%9F%90%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%8A%E5%85%B6%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>列举了四种延时执行某函数的方法及其一些区别。<br>假如延时1秒时间执行下面的方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)delayMethod &#123; <span class="built_in">NSLog</span>(<span class="string">@"execute"</span>); &#125;</div></pre></td></tr></table></figure>
<p>1.performSelector方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(delayMethod) withObject:<span class="literal">nil</span> afterDelay:<span class="number">1.0</span>f];</div></pre></td></tr></table></figure>
<p>此方式要求必须在主线程中执行，否则无效。</p>
<p>是一种非阻塞的执行方式，</p>
<p>2.定时器:NSTimer</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span>f target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(delayMethod) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</div></pre></td></tr></table></figure>
<p>此方式要求必须在主线程中执行，否则无效。</p>
<p>是一种非阻塞的执行方式，</p>
<p>可以通过NSTimer类的- (void)invalidate;取消执行。</p>
<p>3.sleep方式</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1.0</span>f]; </div><div class="line">[<span class="keyword">self</span> delayMethod];</div></pre></td></tr></table></figure>
<p>此方式在主线程和子线程中均可执行。</p>
<p>是一种阻塞的执行方式，建方放到子线程中，以免卡住界面</p>
<p>没有找到取消执行的方法。</p>
<p>4.GCD方式</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> delayInSeconds = <span class="number">1.0</span>; </div><div class="line"> __block ViewController* bself = <span class="keyword">self</span>; </div><div class="line"> dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * <span class="built_in">NSEC_PER_SEC</span>));</div><div class="line">dispatch_after(popTime, dispatch_get_main_queue(), ^(<span class="keyword">void</span>)&#123; </div><div class="line"> [bself delayMethod]; &#125;);</div></pre></td></tr></table></figure>
<p>此方式在可以在参数中选择执行的线程。</p>
<p>是一种非阻塞的执行方式，</p>
<p>没有找到取消执行的方法。</p>
]]></content>
    </entry>
    
  
  
</search>
