<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 面试问题实记 · lydsnm</title><meta name="description" content="面试问题实记 - lydsnm"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.lydsnm.top/atom.xml" title="lydsnm"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://life.lydsnm.top" target="_blank" class="nav-list-link">LYDSNM'S LIFE</a></li><li class="nav-list-item"><a href="https://weibo.com/u/2453162147" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/donglyu" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">面试问题实记</h1><div class="post-info">2018年12月9日</div><div class="post-content"><p>&emsp;&emsp;部分面试问题，记录一下，时刻督促~</p>
<h2 id="layer层，还有哪些layer子类，有些什么作用"><a href="#layer层，还有哪些layer子类，有些什么作用" class="headerlink" title="layer层，还有哪些layer子类，有些什么作用"></a>layer层，还有哪些layer子类，有些什么作用</h2><p>CATextLayer（CALayer的一个子类，专门用来显示文字）<br>CAGradientLayer(渐变图层）<br>CAShapeLayer（波浪）<br>CATiledLayer（专为加载超大图.eg:地图资源）<br>CATransformLayer（3D变换、3D动画）<br>CAGradientLayer （渐变色Layer）<br>CAReplicatorLayer （复制图层（多个相同图层组合起来动画）<a href="https://www.cnblogs.com/xianfeng-zhang/p/7759919.html）" target="_blank" rel="noopener">https://www.cnblogs.com/xianfeng-zhang/p/7759919.html）</a><br>CAScrollLayer  （滚动图层：for scrollView负责显示）<br>CAEmitterLayer （粒子发生器系统。用来创建实时的粒子动画：烟雾，火，雨，雪等。）<br>CAEAGLLayer （用来显示任意的OpenGL图形。OpenGL由近350个不同的函数调用组成，用来从简单的图元绘制复杂的三维景象，主要用途是CAD、科学可视化程序、虚拟现实、游戏程序设计。）<br>AVPlayerLayer （视频图层：本地网络视频播放AVPlayer）</p>
<p>CATextLayer使用CoreText进行绘制，渲染速度比使用WebKit的UILabel快很多。而且UILabel主要是管理内容，CATextLayer则是绘制内容、渲染文本。</p>
<hr>
<h2 id="锁，常用的有哪些，优缺点对比呢"><a href="#锁，常用的有哪些，优缺点对比呢" class="headerlink" title="锁，常用的有哪些，优缺点对比呢"></a>锁，常用的有哪些，优缺点对比呢</h2><p>先说几个概念：<br>临界区：指的是一块对公共资源进行访问的代码，并非一种机制或是算法。</p>
<p>自旋锁：是用于多线程同步的一种锁，线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。 自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。</p>
<p>互斥锁（Mutex）：是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。该目的通过将代码切片成一个一个的临界区而达成。</p>
<p>读写锁：是计算机程序的并发控制的一种同步机制，也称“共享-互斥锁”、多读者-单写者锁) 用于解决多线程对公共资源读写问题。读操作可并发重入，写操作是互斥的。 读写锁通常用互斥锁、条件变量、信号量实现。</p>
<p>信号量（semaphore）：是一种更高级的同步机制，互斥锁可以说是semaphore在仅取值0/1时的特例。信号量可以有更多的取值空间，用来实现更加复杂的同步，而不单单是线程间互斥。</p>
<p>几种常用的锁介绍：<a href="https://blog.csdn.net/banbaodevelop/article/details/79279221" target="_blank" rel="noopener">https://blog.csdn.net/banbaodevelop/article/details/79279221</a></p>
<p>条件锁：就是条件变量，当进程的某些资源要求不满足时就进入休眠，也就是锁住了。当资源被分配到了，条件锁打开，进程继续运行。</p>
<p>@synchronized 关键字加锁 互斥锁，性能较差不推荐使用</p>
<p>NSLock：是Foundation以对象形式暴露的锁，NSLock 互斥锁 不能多次调用 lock方法,会造成死锁。定义了lock和unlock方法<br>NSConditionLock 条件锁<br>条件锁，一个线程获得了锁，其它线程等待。</p>
<p>pthread_mutex：C语言</p>
<p><code>dispatch_semaphore</code> 信号量实现加锁<br>GCD中也已经提供了一种信号机制，使用它我们也可以来构建一把”锁”(从本质意义上讲，信号量与锁是有区别。):</p>
<h2 id="信号量之间的性能，为什么有些时候不好"><a href="#信号量之间的性能，为什么有些时候不好" class="headerlink" title="信号量之间的性能，为什么有些时候不好"></a>信号量之间的性能，为什么有些时候不好</h2><p>dispatch_semaphore<br>未知</p>
<h2 id="夜间模式的实现方式"><a href="#夜间模式的实现方式" class="headerlink" title="夜间模式的实现方式"></a>夜间模式的实现方式</h2><p>night_updateColor  通知， 运行时分类加属性。使用<a href="https://github.com/Draveness/DKNightVersion" target="_blank" rel="noopener">参考DKNightVersion</a>深化一下记忆。</p>
<h2 id="cell的优化思路有哪些"><a href="#cell的优化思路有哪些" class="headerlink" title="cell的优化思路有哪些"></a>cell的优化思路有哪些</h2><p><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/</a><br>优化一般有两个方向的原因：cpu消耗和gpu消耗。</p>
<h3 id="cpu消耗"><a href="#cpu消耗" class="headerlink" title="cpu消耗"></a>cpu消耗</h3><p>对象创建： 对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。layer层轻量一些。</p>
<p>对象调整：对象的调整也经常是消耗 CPU 资源的地方。比如layer，其实内部临时会创建方法。图层调整时，UIView和layer之间会出现很多的方法调用和通知。</p>
<p>对象销毁：布局计算，后台线程提前计算好布局，并对布局缓存</p>
<p>Autolayout： 复杂布局会有严重的性能问题。手动计算frame，或者用AsyncDisplayKit框架。来处理界面的问题</p>
<p>文本计算：如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。</p>
<p>如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象，然后自己计算了，并且 CoreText 对象还能保留以供稍后绘制使用。</p>
<p>文本渲染</p>
<p>图片加载和渲染：图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。</p>
<h3 id="GPU资源消耗"><a href="#GPU资源消耗" class="headerlink" title="GPU资源消耗"></a>GPU资源消耗</h3><p>纹理的渲染：尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。<br>视图的混合：应用应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示。</p>
<p>图形的生成：CALayer 的 border、圆角、阴影、遮罩（mask），<code>CASharpLayer</code> 的矢量图形显示，通常会触发<code>离屏渲染</code>（offscreen rendering），而离屏渲染通常发生在 GPU 中。当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 <code>CALayer.shouldRasterize</code> 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。<br>最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。</p>
<p>以上这些来自：<a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/</a> 可以看看。</p>
<h2 id="断点续传的思想"><a href="#断点续传的思想" class="headerlink" title="断点续传的思想"></a>断点续传的思想</h2><p><a href="https://www.jianshu.com/p/0e6deea7de87" target="_blank" rel="noopener">https://www.jianshu.com/p/0e6deea7de87</a></p>
<p>NSURLSessionDataTask，按字节写入。</p>
<p>要实现断点续传的功能，通常都需要客户端记录下当前的下载进度，并在需要续传的时候通知服务端本次需要下载的内容片段。<br>修改http头部 content-length（示被下载文件的字节数）</p>
<p>请求时：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置请求头</span></span><br><span class="line"><span class="comment">// Range : bytes=xxx-xxx，从已经下载的长度开始到文件总长度的最后都要下载</span></span><br><span class="line"><span class="built_in">NSString</span> *range = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"bytes=%zd-"</span>,  DownloadLength];</span><br><span class="line">[request setValue:range forHTTPHeaderField:<span class="string">@"Range"</span>];</span><br></pre></td></tr></table></figure>
<p>另外AFNetworking中也有对断点续传的实现。分别通过AFURLSessionManager的<code>downloadTaskWithRequest...</code>和<code>downloadTaskWithResumeData...</code></p>
<h2 id="coretext"><a href="#coretext" class="headerlink" title="coretext"></a>coretext</h2><p>Coretext 原理和简单使用：<a href="https://www.cnblogs.com/purple-sweet-pottoes/p/5109413.html" target="_blank" rel="noopener">https://www.cnblogs.com/purple-sweet-pottoes/p/5109413.html</a></p>
<p> Core Text是和Core Graphics配合使用的，一般是在UIView的drawRect方法中的Graphics Context上进行绘制的。 且Core Text真正负责绘制的是文本部分，图片还是需要自己去手动绘制，所以你必须关注很多绘制的细节部分。<br> Core Text是用来进行文字精细排版的。<br> 参考<a href="https://yq.aliyun.com/articles/35907?spm=5176.100240.searchblog.12.TGPd0O" target="_blank" rel="noopener">CoreText 入门</a></p>
<p> iOS UIKit的UIView的坐标系原点在左上角。<br>往底层看，Core Graphics的context使用的坐标系的原点是在左下角。而在iOS中的底层界面绘制就是通过Core Graphics进行的，那么坐标系列是如何变换的呢？ 在UIView的drawRect方法中我们可以通过UIGraphicsGetCurrentContext()来获得当前的Graphics Context。drawRect方法在被调用前，这个Graphics Context被创建和配置好，你只管使用便是。</p>
<p>Core Text一开始便是定位于桌面的排版系统，使用了传统的原点在左下角的坐标系，所以它在绘制文本的时候都是参照左下角的原点进行绘制的。</p>
<p>说起coreText就要说说开源框架<code>YYLabel</code>。这也是一个学习方向。</p>
<h3 id="YYLabel"><a href="#YYLabel" class="headerlink" title="YYLabel"></a>YYLabel</h3><p>简要介绍：YYLabel 直接继承 UIView，作者自己实现 Label 的渲染。UIGraphicsBeginImageContextWithOptions。<br> 分为普通渲染和异步渲染。异步：通过后台线程渲染图片。</p>
<h2 id="OC的多线程开发。"><a href="#OC的多线程开发。" class="headerlink" title="OC的多线程开发。"></a>OC的多线程开发。</h2><p>GCD全解：<a href="https://www.jianshu.com/p/2d57c72016c6" target="_blank" rel="noopener">https://www.jianshu.com/p/2d57c72016c6</a></p>
<p>串行（每次只有一个任务被执行。让任务一个接着一个地执行。（只开启一个线程，一个任务执行完毕后，再执行下一个任务））、并行队列。</p>
<p>GCD 队列组：dispatch_group</p>
<h2 id="套接字编程（socket）"><a href="#套接字编程（socket）" class="headerlink" title="套接字编程（socket）"></a>套接字编程（socket）</h2><p><a href="https://blog.csdn.net/dolacmeng/article/details/81085905" target="_blank" rel="noopener">https://blog.csdn.net/dolacmeng/article/details/81085905</a><br>socket的方式实现长连接。<br>IM即时通讯是通过Socket的方式实现长连接，可运用于<br>（1）直播聊天室、礼物<br>（2）微信、QQ等即时聊天<br>（3）游戏对话、技能等</p>
<p>套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行。建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket。建立连接时所需的寻址信息为IP地址和端口号</p>
<p>IP地址：用于区分那一台机器需要建立连接<br>端口号：用于区分和哪一个应用程序建立连接</p>
<p>套接字之间的连接过程分为三个步骤：<code>服务器监听</code>，<code>客户端请求</code>，<code>连接确认</code>。</p>
<p>创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。</p>
<p>Socket是我们使用TCP/IP 或者UDP/IP协议的<code>一组编程接口</code>，其介于应用层和传输层之间。传输层可以选择TCP或UDP，UDP是不可靠传输，为了保证数据的可靠性，实现起来会更加复杂(除非加上一些很多的其他私有协议，如QQ)，所以一般项目使用TCP即可.<br>我们在应用层，使用socket，轻易的实现了进程之间的通信</p>
<p>iOS使用Socket的常用方式有如下：<br>（1）<code>BSD Socket</code>：是UNIX系统中通用的网络接口，基于C语言，比较底层<br>（2）<code>CF Socket</code>：苹果官方提供，来自于<code>CoreFoundation</code>框架<br>（3）<code>AsyncSocket</code>：对BSD Socket的封装，OC语言<br>（4）ysocket：对BSD Socket的封装，Swift语言 </p>
<p>心跳包就是在客户端和服务器间定时通知对方自己状态的一个自己定义的命令字，按照一定的时间间隔发送，类似于心跳，所以叫做心跳包。<br>心跳包的发送，通常有两种技术<br>方法1：应用层自己实现的心跳包<br>方法2：TCP的KeepAlive保活机制</p>
<p>心跳包的详细内容： <a href="https://blog.csdn.net/qq_32010299/article/details/51787032" target="_blank" rel="noopener">https://blog.csdn.net/qq_32010299/article/details/51787032</a>  心跳检测步骤，等机制。</p>
<p>AsyncSocket的客户端开发和服务端简单开发。<a href="https://www.cnblogs.com/letougaozao/p/3842113.html" target="_blank" rel="noopener">https://www.cnblogs.com/letougaozao/p/3842113.html</a></p>
<h3 id="webSocket"><a href="#webSocket" class="headerlink" title="webSocket"></a>webSocket</h3><h2 id="sdk制作注意事项"><a href="#sdk制作注意事项" class="headerlink" title="sdk制作注意事项"></a>sdk制作注意事项</h2><p><a href="https://www.jianshu.com/p/56941218a0df" target="_blank" rel="noopener">https://www.jianshu.com/p/56941218a0df</a></p>
<ul>
<li><p>由于OC没有命名空间概念,很大问题是重名问题.有以下几个地方都需要注意添加前缀,前缀一定要有辨识度,类名、宏定义、枚举、通知、类别等命名时加静态库统一特殊前缀，以避免命名冲突:</p>
</li>
<li><p>第三方公用库或静态库不要打入SDK进行编译<br>我们常用的网络库使用AFNetworking,SDWebImage,虽然引入到项目中,但是.m不要勾选”target membership”选项,只需要引入.h就OK.或者通过cocoapod,创建sdk工程,通过<code>cocopads</code>管理项目依赖.</p>
</li>
</ul>
<p>常见的第三方框架,比如libssl.a,opencv.a,libcrypto.a等等,拖入工程的时候”Add to Target”(taget membership)都不要打勾.也就是sdk对这些公共库有依赖关系,但是最终生成的sdk不包含公共库的源码文件.</p>
<ul>
<li>尽量减少使用Category<br>那么需要在Build settings-&gt;Other Linker Flags中添加-ObjC参数,解决运行时unrecognized selector send to instance的crash错误.<br>使用-all_load或者-force_load xxx在编译期间非常耗时.<br>为了减少耗时,本人是将通用的类创建成常用的全局函数,static函数,inline函数(注意添加前缀)</li>
</ul>
<ul>
<li>支持通用平台arm,x86等 (模拟器和真机都要去做处理）<br>arm指令集版本 ，要选好所有的设备。</li>
</ul>
<ul>
<li><p>Debug模式,必要Log输出与crash日志收集 。。  log信息如果需要收集的话，还需要自建一套系统。</p>
</li>
<li><p>涉及界面的问题，最好用自动约束。</p>
</li>
<li><p>bundle命名问题，文件配置问题。</p>
</li>
</ul>
<hr>
<h2 id="viewcontroller-的生命周期"><a href="#viewcontroller-的生命周期" class="headerlink" title="viewcontroller 的生命周期"></a>viewcontroller 的生命周期</h2><h2 id="socket与http的关系"><a href="#socket与http的关系" class="headerlink" title="socket与http的关系"></a>socket与http的关系</h2><p>都是应用层。http是单项， socket建立链接时是需要http的。连接完毕后的数据传输是不需要http协议的。</p>
<h2 id="代理为什么用assgin、weak"><a href="#代理为什么用assgin、weak" class="headerlink" title="代理为什么用assgin、weak"></a>代理为什么用assgin、weak</h2><p>弱指针引用，减少内存释放问题。assign主要用来修饰基本的数据类型,weak用来修饰NSObject,两者对所修饰的数据都是<strong> 非拥有关系 </strong></p>
<h2 id="optional"><a href="#optional" class="headerlink" title="optional"></a>optional</h2><p>Swift 中的普通类型不再能设为nil。那如何表示这个值不存在呢？所以引进了Optional的概念：<b><font color="10d3c4">代表 nil 或某个具体的值</font></b>。<br>所以更恰当的理解应该是：String! 只是<code>理解意义上的不为nil</code>，其本质还是一个 Optional，从声明来说它和 String? 完全等价，所以也能够赋值为 nil 。</p>
<h2 id="图片上传用什么。"><a href="#图片上传用什么。" class="headerlink" title="图片上传用什么。"></a>图片上传用什么。</h2><p>AFHTTPSessionManager</p>
<h2 id="swift常用库"><a href="#swift常用库" class="headerlink" title="swift常用库"></a>swift常用库</h2><p>snapkit objectmapper swiftyjson<br>Alamofire<br>wcdb 了解学习一波</p>
<h2 id="组件化，常识"><a href="#组件化，常识" class="headerlink" title="组件化，常识"></a>组件化，常识</h2><ul>
<li><p>url-block 把调用组件使用的url和组件提供的服务block对应起来，保存到内存中，在使用组件的服务时，通过url找到对应的block，然后获取服务</p>
</li>
<li><p>protocol来定义服务接口</p>
</li>
</ul>
<p>等，当然还有其他方式~</p>
<p>组件化实施的方式<br>组件化可以利用git的源代码管理工具的便利性来实施，具体就是建立一个项目工程的私有化仓库，然后把各个组件的podspec上传到私有仓库，在需要用到组件时，直接从仓库里面取。</p>
<p>1.封装公共库和基础UI库<br>在具体的项目开发过程中，我们常会用到三方库和自己封装的UI库，我们可以把这些库封装成组件，然后在项目里用pod进行管理。其中，针对三方库，最好再封装一层，使我们的项目部直接依赖三方库，方便后续开发过程中的更换。</p>
<p>2.独立业务模块化<br>在开发过程中，对一些独立的模块，如：登录模块、账户模块等等，也可以封装成组件，因为这些组件是项目强依赖的，调用的频次比较多。另外，在拆分组件化的过程中，拆分的粒度要合适，尽量做到组件的独立性。同时，组件化是一个渐进的过程，不可能把一个完整的工程一下子全部组件化，要分步进行，通过不停的迭代，来最终实现项目的组件化。</p>
<p>3.服务接口最小化<br>在前两步都完成的情况下，我们可以根据组件被调用的需求来抽象出组件对外的最小化接口。这时，就可以选择具体应用哪种组件化方案来实施组件化了。</p>
<h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><p><a href="http://www.cnblogs.com/ranyonsue/p/5984001.html" target="_blank" rel="noopener">关于HTTP协议，一篇就够了</a></p>
<h2 id="内存分配使用是什么样的。"><a href="#内存分配使用是什么样的。" class="headerlink" title="内存分配使用是什么样的。"></a>内存分配使用是什么样的。</h2><p>arc  以及简单的mrc<br><a href="https://blog.csdn.net/youngkehpu/article/details/56282885" target="_blank" rel="noopener">https://blog.csdn.net/youngkehpu/article/details/56282885</a></p>
<p>1、代码区：用来存放函数的二进制代码，在运行时要防止被非法修改，只允许读取不允许操作<br>2、常量区：存储常量<br>3、静态区：（比如static声明的变量）<br>数据区：存放程序静态分配的变量和全局变量<br>BSS：包含了程序中未初始化全局变量<br>4、堆：由程序员分配和释放，存放进程运行中被动态分配的内存段，可大可小，根据存储的多少来调节大小。调用alloc等分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用realse释放内存时，被释放的内存从堆中被踢除（堆被缩减），因为我们现在iOS基本都使用ARC来管理对象，所以不用我们程序员来管理，但是我们要知道这个对象存储的位置<br>5、栈：栈是由编译器自动分配并释放，用来存放函数括弧“{}”中定义的变量。当函数被调用时，函数带有的参数也会被压入发起调用的进程栈中，待到调用结束后，函数的返回值也回被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。可以把栈看成一个临时数据寄存、交换的内存区。</p>
<p>以上中堆和静态区以及常量区都是连续的，栈和代码区都是独立存放的，栈是向低地址扩展的数据结构，是一块连续的内存的区域。堆是向高地址扩展的数据结构，是不连续的内存区域。堆和栈不会碰到一起，之间间隔很大，绝少有机会能碰到一起，况且堆是链表方式存储！</p>
<h2 id="kvo"><a href="#kvo" class="headerlink" title="kvo"></a>kvo</h2><p>基于runtime</p>
<p>相当于系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法<br>每个类对象中都有一个 isa 指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将 isa 指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的 setter 方法。</p>
<p>kvc<br>KVC是Key Value Coding的简称。它是一种可以通过字符串的名字（key）来访问类属性的机制。<br>isa-swizzing就是类型混合指针机制</p>
<p>KVC的内部机制：<br>一个对象在调用setValue的时候进行了如下操作：</p>
<p>（1）根据方法名找到运行方法的时候需要的环境参数<br>（2）他会从自己的isa指针结合环境参数，找到具体的方法实现接口。<br>（3）再直接查找得来的具体的实现方法</p>
<h2 id="runloop"><a href="#runloop" class="headerlink" title="runloop"></a>runloop</h2><p><a href="http://www.cocoachina.com/ios/20180515/23380.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20180515/23380.html</a></p>
<p>深入浅出runloop： <a href="https://www.jianshu.com/p/7bc36b111774" target="_blank" rel="noopener">https://www.jianshu.com/p/7bc36b111774</a> 这个比较清楚一点。<br>一个线程一次只能执行一个任务，执行完成后线程就会退出。RunLoop 机制能让线程随时处理事件但并不退出。这里说的随时是指：程序需要运行时就保持程序的持续运行，不需要的时候就进入休眠状态。</p>
<p>不开启runloop的线程，运行完了后就关闭了。</p>
<p>苹果提供的runloop：Event Loop线程的任务直到我们主动让线程退出为止永远不会结束<br>RunLoop本质就是个Event Loop的do while循环。<br>就如小节标题保持线程的存活，而不是线性的执行完任务就退出了。<br>并且能在不处理消息的时候让线程休眠，节约资源，在接收到消息的时候唤醒线程做出对应处理的消息循环机制<br>线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>
<p>线程默认不开启RunLoop，为什么我们的App或者说主线程却可以一直运行而不会结束？</p>
<p>主线程是唯一一个例外，当App启动以后主线程会自动开启一个RunLoop来保证主线程的存活并处理各种事件。而且从上面的源代码来看，任意一个子线程的RunLoop都会保证主线程的RunLoop的存在。</p>
<p>NSTimer定时器的触发正是基于RunLoop运行的，所以使用NSTimer之前必须注册到RunLoop。</p>
<p>FaceBook的AsyncDisplayKit</p>
<p>共同之处在于，通过合理利用RunLoop机制，将很多不是必须在主线程中执行的操作放在子线程中实现，然后在合适的时机同步到主线程中，这样可以节省在主线程执行操作的时间，避免卡顿</p>
<p>主线程中一般不需要我们手动添加autoreleasepool，但是，如果你希望某个对象或者变量尽快释放的时候我们也可以手动添加。</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>算法中，什么是哈希值，哈希值怎么生成的，有什么用？<br>2017年10月25日 15:34:50 QianSong_Promise 阅读数：8855<br>1、你可以把哈希值简单地理解成是一段数据（某个文件，或者是字符串）的DNA，或者身份证；</p>
<p>2、通过一定的哈希算法（典型的有MD5，SHA-1等），将一段较长的数据映射为较短小的数据，这段小数据就是大数据的哈希值。他有这样一个特点，他是唯一的，一旦大数据发生了变化，哪怕是一个微小的变化，他的哈希值也会发生变化。另外一方面，既然是DNA，那就保证了没有两个数据的哈希值是完全相同的。</p>
<p>3、正是因为这样的特点，它常常用来判断两个文件是否相同。比如，从网络上下载某个文件，只要把这个文件原来的哈希值同下载后得到的文件的哈希值进行对比，如果相同，则表示两个文件完全一致，下载过程没有损坏文件。而如果不一致，则表明下载得到的文件跟原来的文件不同，文件在下载过程中受到了损坏。</p>
<h2 id="iOS消息发送"><a href="#iOS消息发送" class="headerlink" title="iOS消息发送"></a>iOS消息发送</h2><p>消息直到运行时才会与方法实现进行绑定（在OC中方法调用是一个消息发送的过程）</p>
<p>消息发送的主要步骤如下：<br>1.首先检查这个selector是不是要忽略。<br>2.检测这个selector的target是不是nil，OC允许我们对一个nil对象执行任何方法不会Crash，因为运行时会被忽略掉。<br>3.如果上面两步都通过了，就开始查找这个类的实现IMP，先从cache里查找，如果找到了就运行对应的函数去执行相应的代码。<br>4.如果cache中没有找到就找类的方法列表中是否有对应的方法。<br>5.如果类的方法列表中找不到就到父类的方法列表中查找，一直找到NSObject类为止。<br>6.如果还是没找到就要开始进入动态方法解析（动态添加、重定向….）</p>
<p>链接：<a href="https://www.jianshu.com/p/f31871b58cf0" target="_blank" rel="noopener">https://www.jianshu.com/p/f31871b58cf0</a>  很重要~~~。</p>
<p>描述一下消息发送的过程？</p>
<h2 id="1-SEL和IMP-！！！"><a href="#1-SEL和IMP-！！！" class="headerlink" title="1. SEL和IMP ！！！"></a>1. SEL和IMP ！！！</h2><p>使用过UIControl的朋友应该知道addTarget:action:forControlEvents:这个方法，里面的action参数通常用到一个@selector()，而这个语句的结果就是得到了一个SEL变量。SEL变量我们就叫做一个selector。Selector其实很好理解，就是在发送消息/方法调用时标识是哪个消息（方法）的东西。这个通常都是通过方法全名得来的，就比如上面UIControl的（addTarget:action:forControlEvents:）。</p>
<p>IMP实际上就是具体的一个方法逻辑实现（implementation，貌似IMP就是这么来的）。这个和上面代码示例中的C语言函数指针概念相似。到funcA的指针和到funcB的指针都是IMP变量。</p>
<p>Obejctive-C的运行时系统提供的消息的分派机制把SEL和IMP关联起来。但每次消息发送/方法调用都做一遍查找显然是很麻烦很低效的，所以在Objective-C的runtime这里一定是有缓存机制的， 使得对每个类特定selector对应的IMP可以很快找到。</p>
<p>当然，即使用最好的数据结构和最快的查找算法，和直接执行C函数调用的静态绑定方式相比，也一定有性能损失。但比起Objective-C运行时为开发者提供的诸多动态特性相比，这些都是值得的。</p>
<h2 id="AFNetworking-内部实现。"><a href="#AFNetworking-内部实现。" class="headerlink" title="AFNetworking 内部实现。"></a>AFNetworking 内部实现。</h2><p>AFNSURLSessionManager.<br>它的子类： AFHTTPSessionManager</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/12/03/近期面试体验/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://www.lydsnm.top">lydsnm</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>